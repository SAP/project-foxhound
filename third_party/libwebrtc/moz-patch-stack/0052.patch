From: Andreas Pehrson <apehrson@mozilla.com>
Date: Tue, 2 Nov 2021 14:35:00 +0000
Subject: Bug 1729455 - Inject RTCStatsTimestampMakerRealtimeClock into Call
 instances. r=bwc

This patch makes libwebrtc use our clock for timestamps.
It also makes sure there's no use of the libwebrtc realtime clock, other than
for relative time tracking (like timeouts), and that future libwebrtc updates
don't introduce unaudited use of it.

Differential Revision: https://phabricator.services.mozilla.com/D127714
Mercurial Revision: https://hg.mozilla.org/mozilla-central/rev/0744d68b8c944e69945de4ac5c4ca71332e78ad8
---
 audio/channel_send.cc                       | 2 +-
 call/call.cc                                | 2 ++
 call/call_factory.cc                        | 4 ++++
 call/degraded_call.cc                       | 2 ++
 modules/audio_coding/acm2/acm_receiver.cc   | 2 +-
 modules/rtp_rtcp/include/flexfec_receiver.h | 2 ++
 modules/rtp_rtcp/source/flexfec_receiver.cc | 2 ++
 rtc_base/task_utils/repeating_task.h        | 4 ++--
 system_wrappers/include/clock.h             | 2 +-
 system_wrappers/source/clock.cc             | 2 +-
 10 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/audio/channel_send.cc b/audio/channel_send.cc
index 549e65a59c..8080f4a3b8 100644
--- a/audio/channel_send.cc
+++ b/audio/channel_send.cc
@@ -443,7 +443,7 @@ ChannelSend::ChannelSend(
       transport_controller->GetRtcpObserver();
   configuration.transport_feedback_callback =
       transport_controller->transport_feedback_observer();
-  configuration.clock = (clock ? clock : Clock::GetRealTimeClock());
+  configuration.clock = clock;
   configuration.audio = true;
   configuration.outgoing_transport = rtp_transport;
 
diff --git a/call/call.cc b/call/call.cc
index 42b3b988ea..d2ac705274 100644
--- a/call/call.cc
+++ b/call/call.cc
@@ -473,6 +473,7 @@ std::string Call::Stats::ToString(int64_t time_ms) const {
   return ss.str();
 }
 
+/* Mozilla: Avoid this since it could use GetRealTimeClock().
 std::unique_ptr<Call> Call::Create(const CallConfig& config) {
   Clock* clock =
       config.env.has_value() ? &config.env->clock() : Clock::GetRealTimeClock();
@@ -480,6 +481,7 @@ std::unique_ptr<Call> Call::Create(const CallConfig& config) {
                 RtpTransportControllerSendFactory().Create(
                     config.ExtractTransportConfig(), clock));
 }
+ */
 
 std::unique_ptr<Call> Call::Create(
     const CallConfig& config,
diff --git a/call/call_factory.cc b/call/call_factory.cc
index 043b11da37..78a4f1635f 100644
--- a/call/call_factory.cc
+++ b/call/call_factory.cc
@@ -94,6 +94,9 @@ std::unique_ptr<Call> CallFactory::CreateCall(const CallConfig& config) {
 
   RtpTransportConfig transportConfig = config.ExtractTransportConfig();
 
+  RTC_CHECK(false);
+  return nullptr;
+  /* Mozilla: Avoid this since it could use GetRealTimeClock().
   std::unique_ptr<Call> call =
       Call::Create(config, Clock::GetRealTimeClock(),
                    config.rtp_transport_controller_send_factory->Create(
@@ -106,6 +109,7 @@ std::unique_ptr<Call> CallFactory::CreateCall(const CallConfig& config) {
   }
 
   return call;
+   */
 }
 
 std::unique_ptr<CallFactoryInterface> CreateCallFactory() {
diff --git a/call/degraded_call.cc b/call/degraded_call.cc
index a511eda7bd..75a4a1cac0 100644
--- a/call/degraded_call.cc
+++ b/call/degraded_call.cc
@@ -126,6 +126,7 @@ bool DegradedCall::FakeNetworkPipeTransportAdapter::SendRtcp(
   return true;
 }
 
+/* Mozilla: Avoid this since it could use GetRealTimeClock().
 DegradedCall::DegradedCall(
     std::unique_ptr<Call> call,
     const std::vector<TimeScopedNetworkConfig>& send_configs,
@@ -162,6 +163,7 @@ DegradedCall::DegradedCall(
     }
   }
 }
+*/
 
 DegradedCall::~DegradedCall() {
   RTC_DCHECK_RUN_ON(call_->worker_thread());
diff --git a/modules/audio_coding/acm2/acm_receiver.cc b/modules/audio_coding/acm2/acm_receiver.cc
index a77e472ec1..a5bf88e547 100644
--- a/modules/audio_coding/acm2/acm_receiver.cc
+++ b/modules/audio_coding/acm2/acm_receiver.cc
@@ -50,7 +50,7 @@ std::unique_ptr<NetEq> CreateNetEq(
 
 AcmReceiver::Config::Config(
     rtc::scoped_refptr<AudioDecoderFactory> decoder_factory)
-    : clock(*Clock::GetRealTimeClock()), decoder_factory(decoder_factory) {
+    : clock(*Clock::GetRealTimeClockRaw()), decoder_factory(decoder_factory) {
   // Post-decode VAD is disabled by default in NetEq, however, Audio
   // Conference Mixer relies on VAD decisions and fails without them.
   neteq_config.enable_post_decode_vad = true;
diff --git a/modules/rtp_rtcp/include/flexfec_receiver.h b/modules/rtp_rtcp/include/flexfec_receiver.h
index a869c8ad41..b6a33882d1 100644
--- a/modules/rtp_rtcp/include/flexfec_receiver.h
+++ b/modules/rtp_rtcp/include/flexfec_receiver.h
@@ -30,9 +30,11 @@ class Clock;
 
 class FlexfecReceiver {
  public:
+  /* Mozilla: Avoid this since it could use GetRealTimeClock().
   FlexfecReceiver(uint32_t ssrc,
                   uint32_t protected_media_ssrc,
                   RecoveredPacketReceiver* recovered_packet_receiver);
+   */
   FlexfecReceiver(Clock* clock,
                   uint32_t ssrc,
                   uint32_t protected_media_ssrc,
diff --git a/modules/rtp_rtcp/source/flexfec_receiver.cc b/modules/rtp_rtcp/source/flexfec_receiver.cc
index 7f2cc0cb3c..2ba85a2157 100644
--- a/modules/rtp_rtcp/source/flexfec_receiver.cc
+++ b/modules/rtp_rtcp/source/flexfec_receiver.cc
@@ -31,6 +31,7 @@ constexpr TimeDelta kPacketLogInterval = TimeDelta::Seconds(10);
 
 }  // namespace
 
+/* Mozilla: Avoid this since it could use GetRealTimeClock().
 FlexfecReceiver::FlexfecReceiver(
     uint32_t ssrc,
     uint32_t protected_media_ssrc,
@@ -39,6 +40,7 @@ FlexfecReceiver::FlexfecReceiver(
                       ssrc,
                       protected_media_ssrc,
                       recovered_packet_receiver) {}
+ */
 
 FlexfecReceiver::FlexfecReceiver(
     Clock* clock,
diff --git a/rtc_base/task_utils/repeating_task.h b/rtc_base/task_utils/repeating_task.h
index c45de95ecc..28c691c3de 100644
--- a/rtc_base/task_utils/repeating_task.h
+++ b/rtc_base/task_utils/repeating_task.h
@@ -57,7 +57,7 @@ class RepeatingTaskHandle {
       absl::AnyInvocable<TimeDelta()> closure,
       TaskQueueBase::DelayPrecision precision =
           TaskQueueBase::DelayPrecision::kLow,
-      Clock* clock = Clock::GetRealTimeClock(),
+      Clock* clock = Clock::GetRealTimeClockRaw(),
       const Location& location = Location::Current());
 
   // DelayedStart is equivalent to Start except that the first invocation of the
@@ -68,7 +68,7 @@ class RepeatingTaskHandle {
       absl::AnyInvocable<TimeDelta()> closure,
       TaskQueueBase::DelayPrecision precision =
           TaskQueueBase::DelayPrecision::kLow,
-      Clock* clock = Clock::GetRealTimeClock(),
+      Clock* clock = Clock::GetRealTimeClockRaw(),
       const Location& location = Location::Current());
 
   // Stops future invocations of the repeating task closure. Can only be called
diff --git a/system_wrappers/include/clock.h b/system_wrappers/include/clock.h
index 60296070cc..214b34c970 100644
--- a/system_wrappers/include/clock.h
+++ b/system_wrappers/include/clock.h
@@ -49,7 +49,7 @@ class RTC_EXPORT Clock {
   }
 
   // Returns an instance of the real-time system clock implementation.
-  static Clock* GetRealTimeClock();
+  static Clock* GetRealTimeClockRaw();
 };
 
 class SimulatedClock : public Clock {
diff --git a/system_wrappers/source/clock.cc b/system_wrappers/source/clock.cc
index 88c99d6a68..f7460b831c 100644
--- a/system_wrappers/source/clock.cc
+++ b/system_wrappers/source/clock.cc
@@ -57,7 +57,7 @@ class RealTimeClock : public Clock {
   }
 };
 
-Clock* Clock::GetRealTimeClock() {
+Clock* Clock::GetRealTimeClockRaw() {
   static Clock* const clock = new RealTimeClock();
   return clock;
 }

/* Generated by wayland-scanner 1.23.0 */

#ifndef COLOR_MANAGEMENT_V1_CLIENT_PROTOCOL_H
#define COLOR_MANAGEMENT_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @page page_color_management_v1 The color_management_v1 protocol
 * color management protocol
 *
 * @section page_desc_color_management_v1 Description
 *
 * The aim of the color management extension is to allow clients to know
 * the color properties of outputs, and to tell the compositor about the color
 * properties of their content on surfaces. Doing this enables a compositor
 * to perform automatic color management of content for different outputs
 * according to how content is intended to look like.
 *
 * The color properties are represented as an image description object which
 * is immutable after it has been created. A wl_output always has an
 * associated image description that clients can observe. A wl_surface
 * always has an associated preferred image description as a hint chosen by
 * the compositor that clients can also observe. Clients can set an image
 * description on a wl_surface to denote the color characteristics of the
 * surface contents.
 *
 * An image description includes SDR and HDR colorimetry and encoding, HDR
 * metadata, and viewing environment parameters. An image description does
 * not include the properties set through color-representation extension.
 * It is expected that the color-representation extension is used in
 * conjunction with the color management extension when necessary,
 * particularly with the YUV family of pixel formats.
 *
 * Recommendation ITU-T H.273
 * "Coding-independent code points for video signal type identification"
 * shall be referred to as simply H.273 here.
 *
 * The color-and-hdr repository
 * (https://gitlab.freedesktop.org/pq/color-and-hdr) contains
 * background information on the protocol design and legacy color management.
 * It also contains a glossary, learning resources for digital color, tools,
 * samples and more.
 *
 * The terminology used in this protocol is based on common color science and
 * color encoding terminology where possible. The glossary in the color-and-hdr
 * repository shall be the authority on the definition of terms in this
 * protocol.
 *
 * @section page_ifaces_color_management_v1 Interfaces
 * - @subpage page_iface_xx_color_manager_v4 - color manager singleton
 * - @subpage page_iface_xx_color_management_output_v4 - output color properties
 * - @subpage page_iface_xx_color_management_surface_v4 - color management
 * extension to a surface
 * - @subpage page_iface_xx_color_management_feedback_surface_v4 - color
 * management extension to a surface
 * - @subpage page_iface_xx_image_description_creator_icc_v4 - holder of image
 * description ICC information
 * - @subpage page_iface_xx_image_description_creator_params_v4 - holder of
 * image description parameters
 * - @subpage page_iface_xx_image_description_v4 - Colorimetric image
 * description
 * - @subpage page_iface_xx_image_description_info_v4 - Colorimetric image
 * description information
 * @section page_copyright_color_management_v1 Copyright
 * <pre>
 *
 * Copyright 2019 Sebastian Wick
 * Copyright 2019 Erwin Burema
 * Copyright 2020 AMD
 * Copyright 2020-2024 Collabora, Ltd.
 * Copyright 2024 Xaver Hugl
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct wl_output;
struct wl_surface;
struct xx_color_management_feedback_surface_v4;
struct xx_color_management_output_v4;
struct xx_color_management_surface_v4;
struct xx_color_manager_v4;
struct xx_image_description_creator_icc_v4;
struct xx_image_description_creator_params_v4;
struct xx_image_description_info_v4;
struct xx_image_description_v4;

#ifndef XX_COLOR_MANAGER_V4_INTERFACE
#  define XX_COLOR_MANAGER_V4_INTERFACE
/**
 * @page page_iface_xx_color_manager_v4 xx_color_manager_v4
 * @section page_iface_xx_color_manager_v4_desc Description
 *
 * A global interface used for getting color management extensions for
 * wl_surface and wl_output objects, and for creating client defined image
 * description objects. The extension interfaces allow
 * getting the image description of outputs and setting the image
 * description of surfaces.
 * @section page_iface_xx_color_manager_v4_api API
 * See @ref iface_xx_color_manager_v4.
 */
/**
 * @defgroup iface_xx_color_manager_v4 The xx_color_manager_v4 interface
 *
 * A global interface used for getting color management extensions for
 * wl_surface and wl_output objects, and for creating client defined image
 * description objects. The extension interfaces allow
 * getting the image description of outputs and setting the image
 * description of surfaces.
 */
extern const struct wl_interface xx_color_manager_v4_interface;
#endif
#ifndef XX_COLOR_MANAGEMENT_OUTPUT_V4_INTERFACE
#  define XX_COLOR_MANAGEMENT_OUTPUT_V4_INTERFACE
/**
 * @page page_iface_xx_color_management_output_v4 xx_color_management_output_v4
 * @section page_iface_xx_color_management_output_v4_desc Description
 *
 * A xx_color_management_output_v4 describes the color properties of an
 * output.
 *
 * The xx_color_management_output_v4 is associated with the wl_output global
 * underlying the wl_output object. Therefore the client destroying the
 * wl_output object has no impact, but the compositor removing the output
 * global makes the xx_color_management_output_v4 object inert.
 * @section page_iface_xx_color_management_output_v4_api API
 * See @ref iface_xx_color_management_output_v4.
 */
/**
 * @defgroup iface_xx_color_management_output_v4 The
 * xx_color_management_output_v4 interface
 *
 * A xx_color_management_output_v4 describes the color properties of an
 * output.
 *
 * The xx_color_management_output_v4 is associated with the wl_output global
 * underlying the wl_output object. Therefore the client destroying the
 * wl_output object has no impact, but the compositor removing the output
 * global makes the xx_color_management_output_v4 object inert.
 */
extern const struct wl_interface xx_color_management_output_v4_interface;
#endif
#ifndef XX_COLOR_MANAGEMENT_SURFACE_V4_INTERFACE
#  define XX_COLOR_MANAGEMENT_SURFACE_V4_INTERFACE
/**
 * @page page_iface_xx_color_management_surface_v4
 * xx_color_management_surface_v4
 * @section page_iface_xx_color_management_surface_v4_desc Description
 *
 * A xx_color_management_surface_v4 allows the client to set the color
 * space and HDR properties of a surface.
 *
 * If the wl_surface associated with the xx_color_management_surface_v4 is
 * destroyed, the xx_color_management_surface_v4 object becomes inert.
 * @section page_iface_xx_color_management_surface_v4_api API
 * See @ref iface_xx_color_management_surface_v4.
 */
/**
 * @defgroup iface_xx_color_management_surface_v4 The
 * xx_color_management_surface_v4 interface
 *
 * A xx_color_management_surface_v4 allows the client to set the color
 * space and HDR properties of a surface.
 *
 * If the wl_surface associated with the xx_color_management_surface_v4 is
 * destroyed, the xx_color_management_surface_v4 object becomes inert.
 */
extern const struct wl_interface xx_color_management_surface_v4_interface;
#endif
#ifndef XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_INTERFACE
#  define XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_INTERFACE
/**
 * @page page_iface_xx_color_management_feedback_surface_v4
 * xx_color_management_feedback_surface_v4
 * @section page_iface_xx_color_management_feedback_surface_v4_desc Description
 *
 * A xx_color_management_feedback_surface_v4 allows the client to get the
 * preferred color description of a surface.
 *
 * If the wl_surface associated with this object is destroyed, the
 * xx_color_management_feedback_surface_v4 object becomes inert.
 * @section page_iface_xx_color_management_feedback_surface_v4_api API
 * See @ref iface_xx_color_management_feedback_surface_v4.
 */
/**
 * @defgroup iface_xx_color_management_feedback_surface_v4 The
 * xx_color_management_feedback_surface_v4 interface
 *
 * A xx_color_management_feedback_surface_v4 allows the client to get the
 * preferred color description of a surface.
 *
 * If the wl_surface associated with this object is destroyed, the
 * xx_color_management_feedback_surface_v4 object becomes inert.
 */
extern const struct wl_interface
    xx_color_management_feedback_surface_v4_interface;
#endif
#ifndef XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_INTERFACE
#  define XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_INTERFACE
/**
 * @page page_iface_xx_image_description_creator_icc_v4
 * xx_image_description_creator_icc_v4
 * @section page_iface_xx_image_description_creator_icc_v4_desc Description
 *
 * This type of object is used for collecting all the information required
 * to create a xx_image_description_v4 object from an ICC file. A complete
 * set of required parameters consists of these properties:
 * - ICC file
 *
 * Each required property must be set exactly once if the client is to create
 * an image description. The set requests verify that a property was not
 * already set. The create request verifies that all required properties are
 * set. There may be several alternative requests for setting each property,
 * and in that case the client must choose one of them.
 *
 * Once all properties have been set, the create request must be used to
 * create the image description object, destroying the creator in the
 * process.
 * @section page_iface_xx_image_description_creator_icc_v4_api API
 * See @ref iface_xx_image_description_creator_icc_v4.
 */
/**
 * @defgroup iface_xx_image_description_creator_icc_v4 The
 * xx_image_description_creator_icc_v4 interface
 *
 * This type of object is used for collecting all the information required
 * to create a xx_image_description_v4 object from an ICC file. A complete
 * set of required parameters consists of these properties:
 * - ICC file
 *
 * Each required property must be set exactly once if the client is to create
 * an image description. The set requests verify that a property was not
 * already set. The create request verifies that all required properties are
 * set. There may be several alternative requests for setting each property,
 * and in that case the client must choose one of them.
 *
 * Once all properties have been set, the create request must be used to
 * create the image description object, destroying the creator in the
 * process.
 */
extern const struct wl_interface xx_image_description_creator_icc_v4_interface;
#endif
#ifndef XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_INTERFACE
#  define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_INTERFACE
/**
 * @page page_iface_xx_image_description_creator_params_v4
 * xx_image_description_creator_params_v4
 * @section page_iface_xx_image_description_creator_params_v4_desc Description
 *
 * This type of object is used for collecting all the parameters required
 * to create a xx_image_description_v4 object. A complete set of required
 * parameters consists of these properties:
 * - transfer characteristic function (tf)
 * - chromaticities of primaries and white point (primary color volume)
 *
 * The following properties are optional and have a well-defined default
 * if not explicitly set:
 * - primary color volume luminance range
 * - reference white luminance level
 * - mastering display primaries and white point (target color volume)
 * - mastering luminance range
 * - maximum content light level
 * - maximum frame-average light level
 *
 * Each required property must be set exactly once if the client is to create
 * an image description. The set requests verify that a property was not
 * already set. The create request verifies that all required properties are
 * set. There may be several alternative requests for setting each property,
 * and in that case the client must choose one of them.
 *
 * Once all properties have been set, the create request must be used to
 * create the image description object, destroying the creator in the
 * process.
 * @section page_iface_xx_image_description_creator_params_v4_api API
 * See @ref iface_xx_image_description_creator_params_v4.
 */
/**
 * @defgroup iface_xx_image_description_creator_params_v4 The
 * xx_image_description_creator_params_v4 interface
 *
 * This type of object is used for collecting all the parameters required
 * to create a xx_image_description_v4 object. A complete set of required
 * parameters consists of these properties:
 * - transfer characteristic function (tf)
 * - chromaticities of primaries and white point (primary color volume)
 *
 * The following properties are optional and have a well-defined default
 * if not explicitly set:
 * - primary color volume luminance range
 * - reference white luminance level
 * - mastering display primaries and white point (target color volume)
 * - mastering luminance range
 * - maximum content light level
 * - maximum frame-average light level
 *
 * Each required property must be set exactly once if the client is to create
 * an image description. The set requests verify that a property was not
 * already set. The create request verifies that all required properties are
 * set. There may be several alternative requests for setting each property,
 * and in that case the client must choose one of them.
 *
 * Once all properties have been set, the create request must be used to
 * create the image description object, destroying the creator in the
 * process.
 */
extern const struct wl_interface
    xx_image_description_creator_params_v4_interface;
#endif
#ifndef XX_IMAGE_DESCRIPTION_V4_INTERFACE
#  define XX_IMAGE_DESCRIPTION_V4_INTERFACE
/**
 * @page page_iface_xx_image_description_v4 xx_image_description_v4
 * @section page_iface_xx_image_description_v4_desc Description
 *
 * An image description carries information about the color encoding used on
 * a surface when attached to a wl_surface via
 * xx_color_management_surface_v4.set_image_description. A compositor can use
 * this information to decode pixel values into colorimetrically meaningful
 * quantities.
 *
 * Note, that the xx_image_description_v4 object is not ready to be used
 * immediately after creation. The object eventually delivers either the
 * 'ready' or the 'failed' event, specified in all requests creating it. The
 * object is deemed "ready" after receiving the 'ready' event.
 *
 * An object which is not ready is illegal to use, it can only be destroyed.
 * Any other request in this interface shall result in the 'not_ready'
 * protocol error. Attempts to use an object which is not ready through other
 * interfaces shall raise protocol errors defined there.
 *
 * Once created and regardless of how it was created, a
 * xx_image_description_v4 object always refers to one fixed image
 * description. It cannot change after creation.
 * @section page_iface_xx_image_description_v4_api API
 * See @ref iface_xx_image_description_v4.
 */
/**
 * @defgroup iface_xx_image_description_v4 The xx_image_description_v4 interface
 *
 * An image description carries information about the color encoding used on
 * a surface when attached to a wl_surface via
 * xx_color_management_surface_v4.set_image_description. A compositor can use
 * this information to decode pixel values into colorimetrically meaningful
 * quantities.
 *
 * Note, that the xx_image_description_v4 object is not ready to be used
 * immediately after creation. The object eventually delivers either the
 * 'ready' or the 'failed' event, specified in all requests creating it. The
 * object is deemed "ready" after receiving the 'ready' event.
 *
 * An object which is not ready is illegal to use, it can only be destroyed.
 * Any other request in this interface shall result in the 'not_ready'
 * protocol error. Attempts to use an object which is not ready through other
 * interfaces shall raise protocol errors defined there.
 *
 * Once created and regardless of how it was created, a
 * xx_image_description_v4 object always refers to one fixed image
 * description. It cannot change after creation.
 */
extern const struct wl_interface xx_image_description_v4_interface;
#endif
#ifndef XX_IMAGE_DESCRIPTION_INFO_V4_INTERFACE
#  define XX_IMAGE_DESCRIPTION_INFO_V4_INTERFACE
/**
 * @page page_iface_xx_image_description_info_v4 xx_image_description_info_v4
 * @section page_iface_xx_image_description_info_v4_desc Description
 *
 * Sends all matching events describing an image description object exactly
 * once and finally sends the 'done' event.
 *
 * Once a xx_image_description_info_v4 object has delivered a 'done' event it
 * is automatically destroyed.
 *
 * Every xx_image_description_info_v4 created from the same
 * xx_image_description_v4 shall always return the exact same data.
 * @section page_iface_xx_image_description_info_v4_api API
 * See @ref iface_xx_image_description_info_v4.
 */
/**
 * @defgroup iface_xx_image_description_info_v4 The xx_image_description_info_v4
 * interface
 *
 * Sends all matching events describing an image description object exactly
 * once and finally sends the 'done' event.
 *
 * Once a xx_image_description_info_v4 object has delivered a 'done' event it
 * is automatically destroyed.
 *
 * Every xx_image_description_info_v4 created from the same
 * xx_image_description_v4 shall always return the exact same data.
 */
extern const struct wl_interface xx_image_description_info_v4_interface;
#endif

#ifndef XX_COLOR_MANAGER_V4_ERROR_ENUM
#  define XX_COLOR_MANAGER_V4_ERROR_ENUM
enum xx_color_manager_v4_error {
  /**
   * request not supported
   */
  XX_COLOR_MANAGER_V4_ERROR_UNSUPPORTED_FEATURE = 0,
  /**
   * color management surface exists already
   */
  XX_COLOR_MANAGER_V4_ERROR_SURFACE_EXISTS = 1,
};
#endif /* XX_COLOR_MANAGER_V4_ERROR_ENUM */

#ifndef XX_COLOR_MANAGER_V4_RENDER_INTENT_ENUM
#  define XX_COLOR_MANAGER_V4_RENDER_INTENT_ENUM
/**
 * @ingroup iface_xx_color_manager_v4
 * rendering intents
 *
 * See the ICC.1:2022 specification from the International Color Consortium
 * for more details about rendering intents.
 *
 * The principles of ICC defined rendering intents apply with all types of
 * image descriptions, not only those with ICC file profiles.
 *
 * Compositors must support the perceptual rendering intent. Other
 * rendering intents are optional.
 */
enum xx_color_manager_v4_render_intent {
  /**
   * perceptual
   */
  XX_COLOR_MANAGER_V4_RENDER_INTENT_PERCEPTUAL = 0,
  /**
   * media-relative colorimetric
   */
  XX_COLOR_MANAGER_V4_RENDER_INTENT_RELATIVE = 1,
  /**
   * saturation
   */
  XX_COLOR_MANAGER_V4_RENDER_INTENT_SATURATION = 2,
  /**
   * ICC-absolute colorimetric
   */
  XX_COLOR_MANAGER_V4_RENDER_INTENT_ABSOLUTE = 3,
  /**
   * media-relative colorimetric + black point compensation
   */
  XX_COLOR_MANAGER_V4_RENDER_INTENT_RELATIVE_BPC = 4,
};
#endif /* XX_COLOR_MANAGER_V4_RENDER_INTENT_ENUM */

#ifndef XX_COLOR_MANAGER_V4_FEATURE_ENUM
#  define XX_COLOR_MANAGER_V4_FEATURE_ENUM
/**
 * @ingroup iface_xx_color_manager_v4
 * compositor supported features
 */
enum xx_color_manager_v4_feature {
  /**
   * new_icc_creator request
   */
  XX_COLOR_MANAGER_V4_FEATURE_ICC_V2_V4 = 0,
  /**
   * new_parametric_creator request
   */
  XX_COLOR_MANAGER_V4_FEATURE_PARAMETRIC = 1,
  /**
   * parametric set_primaries request
   */
  XX_COLOR_MANAGER_V4_FEATURE_SET_PRIMARIES = 2,
  /**
   * parametric set_tf_power request
   */
  XX_COLOR_MANAGER_V4_FEATURE_SET_TF_POWER = 3,
  /**
   * parametric set_luminances request
   */
  XX_COLOR_MANAGER_V4_FEATURE_SET_LUMINANCES = 4,
  /**
   * parametric set_mastering_display_primaries request
   *
   * The compositor supports set_mastering_display_primaries
   * request with a target color volume fully contained inside the
   * primary color volume.
   */
  XX_COLOR_MANAGER_V4_FEATURE_SET_MASTERING_DISPLAY_PRIMARIES = 5,
  /**
   * parametric target exceeds primary color volume
   *
   * The compositor additionally supports target color volumes that
   * extend outside of the primary color volume.
   *
   * This can only be advertised if feature
   * set_mastering_display_primaries is supported as well.
   */
  XX_COLOR_MANAGER_V4_FEATURE_EXTENDED_TARGET_VOLUME = 6,
};
#endif /* XX_COLOR_MANAGER_V4_FEATURE_ENUM */

#ifndef XX_COLOR_MANAGER_V4_PRIMARIES_ENUM
#  define XX_COLOR_MANAGER_V4_PRIMARIES_ENUM
/**
 * @ingroup iface_xx_color_manager_v4
 * named color primaries
 *
 * Named color primaries used to encode well-known sets of primaries. H.273
 * is the authority, when it comes to the exact values of primaries and
 * authoritative specifications, where an equivalent code point exists.
 *
 * Descriptions do list the specifications for convenience.
 */
enum xx_color_manager_v4_primaries {
  /**
   * Color primaries for the sRGB color space as defined by the BT.709 standard
   *
   * Color primaries as defined by - Rec. ITU-R BT.709-6 - Rec.
   * ITU-R BT.1361-0 conventional colour gamut system and extended
   * colour gamut system (historical) - IEC 61966-2-1 sRGB or sYCC -
   * IEC 61966-2-4 - Society of Motion Picture and Television
   * Engineers (SMPTE) RP 177 (1993) Annex B Equivalent to H.273
   * ColourPrimaries code point 1.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_SRGB = 0,
  /**
   * Color primaries for PAL-M as defined by the BT.470 standard
   *
   * Color primaries as defined by - Rec. ITU-R BT.470-6 System M
   * (historical) - United States National Television System
   * Committee 1953 Recommendation for transmission standards for
   * color television - United States Federal Communications
   * Commission (2003) Title 47 Code of Federal Regulations 73.682
   * (a)(20) Equivalent to H.273 ColourPrimaries code point 4.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_PAL_M = 1,
  /**
   * Color primaries for PAL as defined by the BT.601 standard
   *
   * Color primaries as defined by - Rec. ITU-R BT.470-6 System B,
   * G (historical) - Rec. ITU-R BT.601-7 625 - Rec. ITU-R BT.1358-0
   * 625 (historical) - Rec. ITU-R BT.1700-0 625 PAL and 625 SECAM
   * Equivalent to H.273 ColourPrimaries code point 5.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_PAL = 2,
  /**
   * Color primaries for NTSC as defined by the BT.601 standard
   *
   * Color primaries as defined by - Rec. ITU-R BT.601-7 525 - Rec.
   * ITU-R BT.1358-1 525 or 625 (historical) - Rec. ITU-R BT.1700-0
   * NTSC - SMPTE 170M (2004) - SMPTE 240M (1999) (historical)
   * Equivalent to H.273 ColourPrimaries code point 6 and 7.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_NTSC = 3,
  /**
   * Generic film with colour filters using Illuminant C
   *
   * Color primaries as defined by H.273 for generic film.
   * Equivalent to H.273 ColourPrimaries code point 8.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_GENERIC_FILM = 4,
  /**
   * Color primaries as defined by the BT.2020 and BT.2100 standard
   *
   * Color primaries as defined by - Rec. ITU-R BT.2020-2 - Rec.
   * ITU-R BT.2100-0 Equivalent to H.273 ColourPrimaries code point
   * 9.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_BT2020 = 5,
  /**
   * Color primaries of the full CIE 1931 XYZ color space
   *
   * Color primaries as defined as the maximum of the CIE 1931 XYZ
   * color space by - SMPTE ST 428-1 - (CIE 1931 XYZ as in ISO
   * 11664-1) Equivalent to H.273 ColourPrimaries code point 10.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_CIE1931_XYZ = 6,
  /**
   * Color primaries of the DCI P3 color space as defined by the SMPTE RP 431
   * standard
   *
   * Color primaries as defined by Digital Cinema System and
   * published in SMPTE RP 431-2 (2011). Equivalent to H.273
   * ColourPrimaries code point 11.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_DCI_P3 = 7,
  /**
   * Color primaries of Display P3 variant of the DCI-P3 color space as defined
   * by the SMPTE EG 432 standard
   *
   * Color primaries as defined by Digital Cinema System and
   * published in SMPTE EG 432-1 (2010). Equivalent to H.273
   * ColourPrimaries code point 12.
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_DISPLAY_P3 = 8,
  /**
   * Color primaries of the Adobe RGB color space as defined by the ISO 12640
   * standard
   *
   * Color primaries as defined by Adobe as "Adobe RGB" and later
   * published by ISO 12640-4 (2011).
   */
  XX_COLOR_MANAGER_V4_PRIMARIES_ADOBE_RGB = 9,
};
#endif /* XX_COLOR_MANAGER_V4_PRIMARIES_ENUM */

#ifndef XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_ENUM
#  define XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_ENUM
/**
 * @ingroup iface_xx_color_manager_v4
 * named transfer functions
 *
 * Named transfer functions used to encode well-known transfer
 * characteristics. H.273 is the authority, when it comes to the exact
 * formulas and authoritative specifications, where an equivalent code
 * point exists.
 *
 * Descriptions do list the specifications for convenience.
 */
enum xx_color_manager_v4_transfer_function {
  /**
   * BT.709 transfer function
   *
   * Transfer characteristics as defined by - Rec. ITU-R BT.709-6 -
   * Rec. ITU-R BT.1361-0 conventional colour gamut system
   * (historical) Equivalent to H.273 TransferCharacteristics code
   * point 1, 6, 14, 15.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_BT709 = 0,
  /**
   * Assumed display gamma 2.2 transfer function
   *
   * Transfer characteristics as defined by - Rec. ITU-R BT.470-6
   * System M (historical) - United States National Television System
   * Committee 1953 Recommendation for transmission standards for
   * color television - United States Federal Communications
   * Commission (2003) Title 47 Code of Federal Regulations 73.682
   * (a) (20) - Rec. ITU-R BT.1700-0 625 PAL and 625 SECAM Equivalent
   * to H.273 TransferCharacteristics code point 4.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_GAMMA22 = 1,
  /**
   * Assumed display gamma 2.8 transfer function
   *
   * Transfer characteristics as defined by - Rec. ITU-R BT.470-6
   * System B, G (historical) Equivalent to H.273
   * TransferCharacteristics code point 5.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_GAMMA28 = 2,
  /**
   * SMPTE ST 240 transfer function
   *
   * Transfer characteristics as defined by - SMPTE ST 240 (1999)
   * Equivalent to H.273 TransferCharacteristics code point 7.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_ST240 = 3,
  /**
   * linear transfer function
   *
   * Linear transfer characteristics. Equivalent to H.273
   * TransferCharacteristics code point 8.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_LINEAR = 4,
  /**
   * logarithmic 100:1 transfer function
   *
   * Logarithmic transfer characteristic (100:1 range). Equivalent
   * to H.273 TransferCharacteristics code point 9.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_LOG_100 = 5,
  /**
   * logarithmic (100*Sqrt(10) : 1) transfer function
   *
   * Logarithmic transfer characteristic (100 * Sqrt(10) : 1
   * range). Equivalent to H.273 TransferCharacteristics code point
   * 10.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_LOG_316 = 6,
  /**
   * IEC 61966-2-4 transfer function
   *
   * Transfer characteristics as defined by - IEC 61966-2-4
   * Equivalent to H.273 TransferCharacteristics code point 11.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_XVYCC = 7,
  /**
   * BT.1361 extended transfer function
   *
   * Transfer characteristics as defined by - Rec. ITU-R BT.1361-0
   * extended colour gamut system (historical) Equivalent to H.273
   * TransferCharacteristics code point 12.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_BT1361 = 8,
  /**
   * sRGB piece-wise transfer function
   *
   * Transfer characteristics as defined by - IEC 61966-2-1 sRGB
   * Equivalent to H.273 TransferCharacteristics code point 13 with
   * MatrixCoefficients set to 0.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_SRGB = 9,
  /**
   * Extended sRGB piece-wise transfer function
   *
   * Transfer characteristics as defined by - IEC 61966-2-1 sYCC
   * Equivalent to H.273 TransferCharacteristics code point 13 with
   * MatrixCoefficients set to anything but 0.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_EXT_SRGB = 10,
  /**
   * perceptual quantizer transfer function
   *
   * Transfer characteristics as defined by - SMPTE ST 2084 (2014)
   * for 10-, 12-, 14- and 16-bit systems - Rec. ITU-R BT.2100-2
   * perceptual quantization (PQ) system Equivalent to H.273
   * TransferCharacteristics code point 16.
   *
   * This TF implies these default luminances - primary color volume
   * minimum: 0.005 cd/m² - primary color volume maximum: 10000
   * cd/m² - reference white: 203 cd/m²
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_ST2084_PQ = 11,
  /**
   * SMPTE ST 428 transfer function
   *
   * Transfer characteristics as defined by - SMPTE ST 428-1 (2019)
   * Equivalent to H.273 TransferCharacteristics code point 17.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_ST428 = 12,
  /**
   * hybrid log-gamma transfer function
   *
   * Transfer characteristics as defined by - ARIB STD-B67 (2015) -
   * Rec. ITU-R BT.2100-2 hybrid log-gamma (HLG) system Equivalent to
   * H.273 TransferCharacteristics code point 18.
   *
   * This TF implies these default luminances - primary color volume
   * minimum: 0.005 cd/m² - primary color volume maximum: 1000
   * cd/m² - reference white: 203 cd/m² Note: HLG is a scene
   * referred signal. All absolute luminance values used here for HLG
   * assume a 1000 cd/m² display.
   */
  XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_HLG = 13,
};
#endif /* XX_COLOR_MANAGER_V4_TRANSFER_FUNCTION_ENUM */

/**
 * @ingroup iface_xx_color_manager_v4
 * @struct xx_color_manager_v4_listener
 */
struct xx_color_manager_v4_listener {
  /**
   * supported rendering intent
   *
   * When this object is created, it shall immediately send this
   * event once for each rendering intent the compositor supports.
   * @param render_intent rendering intent
   */
  void (*supported_intent)(void* data,
                           struct xx_color_manager_v4* xx_color_manager_v4,
                           uint32_t render_intent);
  /**
   * supported features
   *
   * When this object is created, it shall immediately send this
   * event once for each compositor supported feature listed in the
   * enumeration.
   * @param feature supported feature
   */
  void (*supported_feature)(void* data,
                            struct xx_color_manager_v4* xx_color_manager_v4,
                            uint32_t feature);
  /**
   * supported named transfer characteristic
   *
   * When this object is created, it shall immediately send this
   * event once for each named transfer function the compositor
   * supports with the parametric image description creator.
   * @param tf Named transfer function
   */
  void (*supported_tf_named)(void* data,
                             struct xx_color_manager_v4* xx_color_manager_v4,
                             uint32_t tf);
  /**
   * supported named primaries
   *
   * When this object is created, it shall immediately send this
   * event once for each named set of primaries the compositor
   * supports with the parametric image description creator.
   * @param primaries Named color primaries
   */
  void (*supported_primaries_named)(
      void* data, struct xx_color_manager_v4* xx_color_manager_v4,
      uint32_t primaries);
};

/**
 * @ingroup iface_xx_color_manager_v4
 */
static inline int xx_color_manager_v4_add_listener(
    struct xx_color_manager_v4* xx_color_manager_v4,
    const struct xx_color_manager_v4_listener* listener, void* data) {
  return wl_proxy_add_listener((struct wl_proxy*)xx_color_manager_v4,
                               (void (**)(void))listener, data);
}

#define XX_COLOR_MANAGER_V4_DESTROY 0
#define XX_COLOR_MANAGER_V4_GET_OUTPUT 1
#define XX_COLOR_MANAGER_V4_GET_SURFACE 2
#define XX_COLOR_MANAGER_V4_GET_FEEDBACK_SURFACE 3
#define XX_COLOR_MANAGER_V4_NEW_ICC_CREATOR 4
#define XX_COLOR_MANAGER_V4_NEW_PARAMETRIC_CREATOR 5

/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_SUPPORTED_INTENT_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_SUPPORTED_FEATURE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_SUPPORTED_TF_NAMED_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_SUPPORTED_PRIMARIES_NAMED_SINCE_VERSION 1

/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_GET_OUTPUT_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_GET_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_GET_FEEDBACK_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_NEW_ICC_CREATOR_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_manager_v4
 */
#define XX_COLOR_MANAGER_V4_NEW_PARAMETRIC_CREATOR_SINCE_VERSION 1

/** @ingroup iface_xx_color_manager_v4 */
static inline void xx_color_manager_v4_set_user_data(
    struct xx_color_manager_v4* xx_color_manager_v4, void* user_data) {
  wl_proxy_set_user_data((struct wl_proxy*)xx_color_manager_v4, user_data);
}

/** @ingroup iface_xx_color_manager_v4 */
static inline void* xx_color_manager_v4_get_user_data(
    struct xx_color_manager_v4* xx_color_manager_v4) {
  return wl_proxy_get_user_data((struct wl_proxy*)xx_color_manager_v4);
}

static inline uint32_t xx_color_manager_v4_get_version(
    struct xx_color_manager_v4* xx_color_manager_v4) {
  return wl_proxy_get_version((struct wl_proxy*)xx_color_manager_v4);
}

/**
 * @ingroup iface_xx_color_manager_v4
 *
 * Destroy the xx_color_manager_v4 object. This does not affect any other
 * objects in any way.
 */
static inline void xx_color_manager_v4_destroy(
    struct xx_color_manager_v4* xx_color_manager_v4) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_manager_v4, XX_COLOR_MANAGER_V4_DESTROY, NULL,
      wl_proxy_get_version((struct wl_proxy*)xx_color_manager_v4),
      WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xx_color_manager_v4
 *
 * This creates a new xx_color_management_output_v4 object for the
 * given wl_output.
 *
 * See the xx_color_management_output_v4 interface for more details.
 */
static inline struct xx_color_management_output_v4*
xx_color_manager_v4_get_output(struct xx_color_manager_v4* xx_color_manager_v4,
                               struct wl_output* output) {
  struct wl_proxy* id;

  id = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_manager_v4, XX_COLOR_MANAGER_V4_GET_OUTPUT,
      &xx_color_management_output_v4_interface,
      wl_proxy_get_version((struct wl_proxy*)xx_color_manager_v4), 0, NULL,
      output);

  return (struct xx_color_management_output_v4*)id;
}

/**
 * @ingroup iface_xx_color_manager_v4
 *
 * If a xx_color_management_surface_v4 object already exists for the given
 * wl_surface, the protocol error surface_exists is raised.
 *
 * This creates a new color xx_color_management_surface_v4 object for the
 * given wl_surface.
 *
 * See the xx_color_management_surface_v4 interface for more details.
 */
static inline struct xx_color_management_surface_v4*
xx_color_manager_v4_get_surface(struct xx_color_manager_v4* xx_color_manager_v4,
                                struct wl_surface* surface) {
  struct wl_proxy* id;

  id = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_manager_v4, XX_COLOR_MANAGER_V4_GET_SURFACE,
      &xx_color_management_surface_v4_interface,
      wl_proxy_get_version((struct wl_proxy*)xx_color_manager_v4), 0, NULL,
      surface);

  return (struct xx_color_management_surface_v4*)id;
}

/**
 * @ingroup iface_xx_color_manager_v4
 *
 * This creates a new color xx_color_management_feedback_surface_v4 object
 * for the given wl_surface.
 *
 * See the xx_color_management_feedback_surface_v4 interface for more
 * details.
 */
static inline struct xx_color_management_feedback_surface_v4*
xx_color_manager_v4_get_feedback_surface(
    struct xx_color_manager_v4* xx_color_manager_v4,
    struct wl_surface* surface) {
  struct wl_proxy* id;

  id = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_manager_v4,
      XX_COLOR_MANAGER_V4_GET_FEEDBACK_SURFACE,
      &xx_color_management_feedback_surface_v4_interface,
      wl_proxy_get_version((struct wl_proxy*)xx_color_manager_v4), 0, NULL,
      surface);

  return (struct xx_color_management_feedback_surface_v4*)id;
}

/**
 * @ingroup iface_xx_color_manager_v4
 *
 * Makes a new ICC-based image description creator object with all
 * properties initially unset. The client can then use the object's
 * interface to define all the required properties for an image description
 * and finally create a xx_image_description_v4 object.
 *
 * This request can be used when the compositor advertises
 * xx_color_manager_v4.feature.icc_v2_v4.
 * Otherwise this request raises the protocol error unsupported_feature.
 */
static inline struct xx_image_description_creator_icc_v4*
xx_color_manager_v4_new_icc_creator(
    struct xx_color_manager_v4* xx_color_manager_v4) {
  struct wl_proxy* obj;

  obj = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_manager_v4,
      XX_COLOR_MANAGER_V4_NEW_ICC_CREATOR,
      &xx_image_description_creator_icc_v4_interface,
      wl_proxy_get_version((struct wl_proxy*)xx_color_manager_v4), 0, NULL);

  return (struct xx_image_description_creator_icc_v4*)obj;
}

/**
 * @ingroup iface_xx_color_manager_v4
 *
 * Makes a new parametric image description creator object with all
 * properties initially unset. The client can then use the object's
 * interface to define all the required properties for an image description
 * and finally create a xx_image_description_v4 object.
 *
 * This request can be used when the compositor advertises
 * xx_color_manager_v4.feature.parametric.
 * Otherwise this request raises the protocol error unsupported_feature.
 */
static inline struct xx_image_description_creator_params_v4*
xx_color_manager_v4_new_parametric_creator(
    struct xx_color_manager_v4* xx_color_manager_v4) {
  struct wl_proxy* obj;

  obj = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_manager_v4,
      XX_COLOR_MANAGER_V4_NEW_PARAMETRIC_CREATOR,
      &xx_image_description_creator_params_v4_interface,
      wl_proxy_get_version((struct wl_proxy*)xx_color_manager_v4), 0, NULL);

  return (struct xx_image_description_creator_params_v4*)obj;
}

/**
 * @ingroup iface_xx_color_management_output_v4
 * @struct xx_color_management_output_v4_listener
 */
struct xx_color_management_output_v4_listener {
  /**
   * image description changed
   *
   * This event is sent whenever the image description of the
   * output changed, followed by one wl_output.done event common to
   * output events across all extensions.
   *
   * If the client wants to use the updated image description, it
   * needs to do get_image_description again, because image
   * description objects are immutable.
   */
  void (*image_description_changed)(
      void* data,
      struct xx_color_management_output_v4* xx_color_management_output_v4);
};

/**
 * @ingroup iface_xx_color_management_output_v4
 */
static inline int xx_color_management_output_v4_add_listener(
    struct xx_color_management_output_v4* xx_color_management_output_v4,
    const struct xx_color_management_output_v4_listener* listener, void* data) {
  return wl_proxy_add_listener((struct wl_proxy*)xx_color_management_output_v4,
                               (void (**)(void))listener, data);
}

#define XX_COLOR_MANAGEMENT_OUTPUT_V4_DESTROY 0
#define XX_COLOR_MANAGEMENT_OUTPUT_V4_GET_IMAGE_DESCRIPTION 1

/**
 * @ingroup iface_xx_color_management_output_v4
 */
#define XX_COLOR_MANAGEMENT_OUTPUT_V4_IMAGE_DESCRIPTION_CHANGED_SINCE_VERSION 1

/**
 * @ingroup iface_xx_color_management_output_v4
 */
#define XX_COLOR_MANAGEMENT_OUTPUT_V4_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_management_output_v4
 */
#define XX_COLOR_MANAGEMENT_OUTPUT_V4_GET_IMAGE_DESCRIPTION_SINCE_VERSION 1

/** @ingroup iface_xx_color_management_output_v4 */
static inline void xx_color_management_output_v4_set_user_data(
    struct xx_color_management_output_v4* xx_color_management_output_v4,
    void* user_data) {
  wl_proxy_set_user_data((struct wl_proxy*)xx_color_management_output_v4,
                         user_data);
}

/** @ingroup iface_xx_color_management_output_v4 */
static inline void* xx_color_management_output_v4_get_user_data(
    struct xx_color_management_output_v4* xx_color_management_output_v4) {
  return wl_proxy_get_user_data(
      (struct wl_proxy*)xx_color_management_output_v4);
}

static inline uint32_t xx_color_management_output_v4_get_version(
    struct xx_color_management_output_v4* xx_color_management_output_v4) {
  return wl_proxy_get_version((struct wl_proxy*)xx_color_management_output_v4);
}

/**
 * @ingroup iface_xx_color_management_output_v4
 *
 * Destroy the color xx_color_management_output_v4 object. This does not
 * affect any remaining protocol objects.
 */
static inline void xx_color_management_output_v4_destroy(
    struct xx_color_management_output_v4* xx_color_management_output_v4) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_management_output_v4,
      XX_COLOR_MANAGEMENT_OUTPUT_V4_DESTROY, NULL,
      wl_proxy_get_version((struct wl_proxy*)xx_color_management_output_v4),
      WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xx_color_management_output_v4
 *
 * This creates a new xx_image_description_v4 object for the current image
 * description of the output. There always is exactly one image description
 * active for an output so the client should destroy the image description
 * created by earlier invocations of this request. This request is usually
 * sent as a reaction to the image_description_changed event or when
 * creating a xx_color_management_output_v4 object.
 *
 * The image description of an output represents the color encoding the
 * output expects. There might be performance and power advantages, as well
 * as improved color reproduction, if a content update matches the image
 * description of the output it is being shown on. If a content update is
 * shown on any other output than the one it matches the image description
 * of, then the color reproduction on those outputs might be considerably
 * worse.
 *
 * The created xx_image_description_v4 object preserves the image
 * description of the output from the time the object was created.
 *
 * The resulting image description object allows get_information request.
 *
 * If this protocol object is inert, the resulting image description object
 * shall immediately deliver the xx_image_description_v4.failed event with
 * the no_output cause.
 *
 * If the interface version is inadequate for the output's image
 * description, meaning that the client does not support all the events
 * needed to deliver the crucial information, the resulting image
 * description object shall immediately deliver the
 * xx_image_description_v4.failed event with the low_version cause.
 *
 * Otherwise the object shall immediately deliver the ready event.
 */
static inline struct xx_image_description_v4*
xx_color_management_output_v4_get_image_description(
    struct xx_color_management_output_v4* xx_color_management_output_v4) {
  struct wl_proxy* image_description;

  image_description = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_management_output_v4,
      XX_COLOR_MANAGEMENT_OUTPUT_V4_GET_IMAGE_DESCRIPTION,
      &xx_image_description_v4_interface,
      wl_proxy_get_version((struct wl_proxy*)xx_color_management_output_v4), 0,
      NULL);

  return (struct xx_image_description_v4*)image_description;
}

#ifndef XX_COLOR_MANAGEMENT_SURFACE_V4_ERROR_ENUM
#  define XX_COLOR_MANAGEMENT_SURFACE_V4_ERROR_ENUM
/**
 * @ingroup iface_xx_color_management_surface_v4
 * protocol errors
 */
enum xx_color_management_surface_v4_error {
  /**
   * unsupported rendering intent
   */
  XX_COLOR_MANAGEMENT_SURFACE_V4_ERROR_RENDER_INTENT = 0,
  /**
   * invalid image description
   */
  XX_COLOR_MANAGEMENT_SURFACE_V4_ERROR_IMAGE_DESCRIPTION = 1,
};
#endif /* XX_COLOR_MANAGEMENT_SURFACE_V4_ERROR_ENUM */

#define XX_COLOR_MANAGEMENT_SURFACE_V4_DESTROY 0
#define XX_COLOR_MANAGEMENT_SURFACE_V4_SET_IMAGE_DESCRIPTION 1
#define XX_COLOR_MANAGEMENT_SURFACE_V4_UNSET_IMAGE_DESCRIPTION 2

/**
 * @ingroup iface_xx_color_management_surface_v4
 */
#define XX_COLOR_MANAGEMENT_SURFACE_V4_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_management_surface_v4
 */
#define XX_COLOR_MANAGEMENT_SURFACE_V4_SET_IMAGE_DESCRIPTION_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_management_surface_v4
 */
#define XX_COLOR_MANAGEMENT_SURFACE_V4_UNSET_IMAGE_DESCRIPTION_SINCE_VERSION 1

/** @ingroup iface_xx_color_management_surface_v4 */
static inline void xx_color_management_surface_v4_set_user_data(
    struct xx_color_management_surface_v4* xx_color_management_surface_v4,
    void* user_data) {
  wl_proxy_set_user_data((struct wl_proxy*)xx_color_management_surface_v4,
                         user_data);
}

/** @ingroup iface_xx_color_management_surface_v4 */
static inline void* xx_color_management_surface_v4_get_user_data(
    struct xx_color_management_surface_v4* xx_color_management_surface_v4) {
  return wl_proxy_get_user_data(
      (struct wl_proxy*)xx_color_management_surface_v4);
}

static inline uint32_t xx_color_management_surface_v4_get_version(
    struct xx_color_management_surface_v4* xx_color_management_surface_v4) {
  return wl_proxy_get_version((struct wl_proxy*)xx_color_management_surface_v4);
}

/**
 * @ingroup iface_xx_color_management_surface_v4
 *
 * Destroy the xx_color_management_surface_v4 object and do the same as
 * unset_image_description.
 */
static inline void xx_color_management_surface_v4_destroy(
    struct xx_color_management_surface_v4* xx_color_management_surface_v4) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_management_surface_v4,
      XX_COLOR_MANAGEMENT_SURFACE_V4_DESTROY, NULL,
      wl_proxy_get_version((struct wl_proxy*)xx_color_management_surface_v4),
      WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xx_color_management_surface_v4
 *
 * Set the image description of the underlying surface. The image
 * description and rendering intent are double-buffered state, see
 * wl_surface.commit.
 *
 * It is the client's responsibility to understand the image description
 * it sets on a surface, and to provide content that matches that image
 * description. Compositors might convert images to match their own or any
 * other image descriptions.
 *
 * Image description whose creation gracefully failed (received
 * xx_image_description_v4.failed) are forbidden in this request, and in
 * such case the protocol error image_description is raised.
 *
 * All image descriptions whose creation succeeded (received
 * xx_image_description_v4.ready) are allowed and must always be accepted
 * by the compositor.
 *
 * A rendering intent provides the client's preference on how content
 * colors should be mapped to each output. The render_intent value must
 * be one advertised by the compositor with
 * xx_color_manager_v4.render_intent event, otherwise the protocol error
 * render_intent is raised.
 *
 * By default, a surface does not have an associated image description
 * nor a rendering intent. The handling of color on such surfaces is
 * compositor implementation defined. Compositors should handle such
 * surfaces as sRGB but may handle them differently if they have specific
 * requirements.
 */
static inline void xx_color_management_surface_v4_set_image_description(
    struct xx_color_management_surface_v4* xx_color_management_surface_v4,
    struct xx_image_description_v4* image_description, uint32_t render_intent) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_management_surface_v4,
      XX_COLOR_MANAGEMENT_SURFACE_V4_SET_IMAGE_DESCRIPTION, NULL,
      wl_proxy_get_version((struct wl_proxy*)xx_color_management_surface_v4), 0,
      image_description, render_intent);
}

/**
 * @ingroup iface_xx_color_management_surface_v4
 *
 * This request removes any image description from the surface. See
 * set_image_description for how a compositor handles a surface without
 * an image description. This is double-buffered state, see
 * wl_surface.commit.
 */
static inline void xx_color_management_surface_v4_unset_image_description(
    struct xx_color_management_surface_v4* xx_color_management_surface_v4) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_management_surface_v4,
      XX_COLOR_MANAGEMENT_SURFACE_V4_UNSET_IMAGE_DESCRIPTION, NULL,
      wl_proxy_get_version((struct wl_proxy*)xx_color_management_surface_v4),
      0);
}

#ifndef XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_ERROR_ENUM
#  define XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_ERROR_ENUM
/**
 * @ingroup iface_xx_color_management_feedback_surface_v4
 * protocol errors
 */
enum xx_color_management_feedback_surface_v4_error {
  /**
   * forbidden request on inert object
   */
  XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_ERROR_INERT = 0,
};
#endif /* XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_ERROR_ENUM */

/**
 * @ingroup iface_xx_color_management_feedback_surface_v4
 * @struct xx_color_management_feedback_surface_v4_listener
 */
struct xx_color_management_feedback_surface_v4_listener {
  /**
   * the preferred image description changed
   *
   * The preferred image description is the one which likely has
   * the most performance and/or quality benefits for the compositor
   * if used by the client for its wl_surface contents. This event is
   * sent whenever the compositor changes the wl_surface's preferred
   * image description.
   *
   * This event is merely a notification. When the client wants to
   * know what the preferred image description is, it shall use the
   * get_preferred request.
   *
   * The preferred image description is not automatically used for
   * anything. It is only a hint, and clients may set any valid image
   * description with set_image_description but there might be
   * performance and color accuracy improvements by providing the
   * wl_surface contents in the preferred image description.
   * Therefore clients that can, should render according to the
   * preferred image description
   */
  void (*preferred_changed)(void* data,
                            struct xx_color_management_feedback_surface_v4*
                                xx_color_management_feedback_surface_v4);
};

/**
 * @ingroup iface_xx_color_management_feedback_surface_v4
 */
static inline int xx_color_management_feedback_surface_v4_add_listener(
    struct xx_color_management_feedback_surface_v4*
        xx_color_management_feedback_surface_v4,
    const struct xx_color_management_feedback_surface_v4_listener* listener,
    void* data) {
  return wl_proxy_add_listener(
      (struct wl_proxy*)xx_color_management_feedback_surface_v4,
      (void (**)(void))listener, data);
}

#define XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_DESTROY 0
#define XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_GET_PREFERRED 1

/**
 * @ingroup iface_xx_color_management_feedback_surface_v4
 */
#define XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_PREFERRED_CHANGED_SINCE_VERSION \
  1

/**
 * @ingroup iface_xx_color_management_feedback_surface_v4
 */
#define XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xx_color_management_feedback_surface_v4
 */
#define XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_GET_PREFERRED_SINCE_VERSION 1

/** @ingroup iface_xx_color_management_feedback_surface_v4 */
static inline void xx_color_management_feedback_surface_v4_set_user_data(
    struct xx_color_management_feedback_surface_v4*
        xx_color_management_feedback_surface_v4,
    void* user_data) {
  wl_proxy_set_user_data(
      (struct wl_proxy*)xx_color_management_feedback_surface_v4, user_data);
}

/** @ingroup iface_xx_color_management_feedback_surface_v4 */
static inline void* xx_color_management_feedback_surface_v4_get_user_data(
    struct xx_color_management_feedback_surface_v4*
        xx_color_management_feedback_surface_v4) {
  return wl_proxy_get_user_data(
      (struct wl_proxy*)xx_color_management_feedback_surface_v4);
}

static inline uint32_t xx_color_management_feedback_surface_v4_get_version(
    struct xx_color_management_feedback_surface_v4*
        xx_color_management_feedback_surface_v4) {
  return wl_proxy_get_version(
      (struct wl_proxy*)xx_color_management_feedback_surface_v4);
}

/**
 * @ingroup iface_xx_color_management_feedback_surface_v4
 *
 * Destroy the xx_color_management_feedback_surface_v4 object.
 */
static inline void xx_color_management_feedback_surface_v4_destroy(
    struct xx_color_management_feedback_surface_v4*
        xx_color_management_feedback_surface_v4) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_management_feedback_surface_v4,
      XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_DESTROY, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_color_management_feedback_surface_v4),
      WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xx_color_management_feedback_surface_v4
 *
 * If this protocol object is inert, the protocol error inert is raised.
 *
 * The preferred image description represents the compositor's preferred
 * color encoding for this wl_surface at the current time. There might be
 * performance and power advantages, as well as improved color
 * reproduction, if the image description of a content update matches the
 * preferred image description.
 *
 * This creates a new xx_image_description_v4 object for the currently
 * preferred image description for the wl_surface. The client should
 * stop using and destroy the image descriptions created by earlier
 * invocations of this request for the associated wl_surface.
 * This request is usually sent as a reaction to the preferred_changed
 * event or when creating a xx_color_management_feedback_surface_v4 object
 * if the client is capable of adapting to image descriptions.
 *
 * The created xx_image_description_v4 object preserves the preferred image
 * description of the wl_surface from the time the object was created.
 *
 * The resulting image description object allows get_information request.
 *
 * If the interface version is inadequate for the preferred image
 * description, meaning that the client does not support all the
 * events needed to deliver the crucial information, the resulting image
 * description object shall immediately deliver the
 * xx_image_description_v4.failed event with the low_version cause,
 * otherwise the object shall immediately deliver the ready event.
 */
static inline struct xx_image_description_v4*
xx_color_management_feedback_surface_v4_get_preferred(
    struct xx_color_management_feedback_surface_v4*
        xx_color_management_feedback_surface_v4) {
  struct wl_proxy* image_description;

  image_description = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_color_management_feedback_surface_v4,
      XX_COLOR_MANAGEMENT_FEEDBACK_SURFACE_V4_GET_PREFERRED,
      &xx_image_description_v4_interface,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_color_management_feedback_surface_v4),
      0, NULL);

  return (struct xx_image_description_v4*)image_description;
}

#ifndef XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_ERROR_ENUM
#  define XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_ERROR_ENUM
/**
 * @ingroup iface_xx_image_description_creator_icc_v4
 * protocol errors
 */
enum xx_image_description_creator_icc_v4_error {
  /**
   * incomplete parameter set
   */
  XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_ERROR_INCOMPLETE_SET = 0,
  /**
   * property already set
   */
  XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_ERROR_ALREADY_SET = 1,
  /**
   * fd not seekable and readable
   */
  XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_ERROR_BAD_FD = 2,
  /**
   * no or too much data
   */
  XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_ERROR_BAD_SIZE = 3,
  /**
   * offset + length exceeds file size
   */
  XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_ERROR_OUT_OF_FILE = 4,
};
#endif /* XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_ERROR_ENUM */

#define XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_CREATE 0
#define XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_SET_ICC_FILE 1

/**
 * @ingroup iface_xx_image_description_creator_icc_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_CREATE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_creator_icc_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_SET_ICC_FILE_SINCE_VERSION 1

/** @ingroup iface_xx_image_description_creator_icc_v4 */
static inline void xx_image_description_creator_icc_v4_set_user_data(
    struct xx_image_description_creator_icc_v4*
        xx_image_description_creator_icc_v4,
    void* user_data) {
  wl_proxy_set_user_data((struct wl_proxy*)xx_image_description_creator_icc_v4,
                         user_data);
}

/** @ingroup iface_xx_image_description_creator_icc_v4 */
static inline void* xx_image_description_creator_icc_v4_get_user_data(
    struct xx_image_description_creator_icc_v4*
        xx_image_description_creator_icc_v4) {
  return wl_proxy_get_user_data(
      (struct wl_proxy*)xx_image_description_creator_icc_v4);
}

static inline uint32_t xx_image_description_creator_icc_v4_get_version(
    struct xx_image_description_creator_icc_v4*
        xx_image_description_creator_icc_v4) {
  return wl_proxy_get_version(
      (struct wl_proxy*)xx_image_description_creator_icc_v4);
}

/** @ingroup iface_xx_image_description_creator_icc_v4 */
static inline void xx_image_description_creator_icc_v4_destroy(
    struct xx_image_description_creator_icc_v4*
        xx_image_description_creator_icc_v4) {
  wl_proxy_destroy((struct wl_proxy*)xx_image_description_creator_icc_v4);
}

/**
 * @ingroup iface_xx_image_description_creator_icc_v4
 *
 * Create an image description object based on the ICC information
 * previously set on this object. A compositor must parse the ICC data in
 * some undefined but finite amount of time.
 *
 * The completeness of the parameter set is verified. If the set is not
 * complete, the protocol error incomplete_set is raised. For the
 * definition of a complete set, see the description of this interface.
 *
 * If the particular combination of the information is not supported
 * by the compositor, the resulting image description object shall
 * immediately deliver the xx_image_description_v4.failed event with the
 * 'unsupported' cause. If a valid image description was created from the
 * information, the xx_image_description_v4.ready event will eventually
 * be sent instead.
 *
 * This request destroys the xx_image_description_creator_icc_v4 object.
 *
 * The resulting image description object does not allow get_information
 * request.
 */
static inline struct xx_image_description_v4*
xx_image_description_creator_icc_v4_create(
    struct xx_image_description_creator_icc_v4*
        xx_image_description_creator_icc_v4) {
  struct wl_proxy* image_description;

  image_description = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_icc_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_CREATE,
      &xx_image_description_v4_interface,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_icc_v4),
      WL_MARSHAL_FLAG_DESTROY, NULL);

  return (struct xx_image_description_v4*)image_description;
}

/**
 * @ingroup iface_xx_image_description_creator_icc_v4
 *
 * Sets the ICC profile file to be used as the basis of the image
 * description.
 *
 * The data shall be found through the given fd at the given offset, having
 * the given length. The fd must seekable and readable. Violating these
 * requirements raises the bad_fd protocol error.
 *
 * If reading the data fails due to an error independent of the client, the
 * compositor shall send the xx_image_description_v4.failed event on the
 * created xx_image_description_v4 with the 'operating_system' cause.
 *
 * The maximum size of the ICC profile is 4 MB. If length is greater than
 * that or zero, the protocol error bad_size is raised. If offset + length
 * exceeds the file size, the protocol error out_of_file is raised.
 *
 * A compositor may read the file at any time starting from this request
 * and only until whichever happens first:
 * - If create request was issued, the xx_image_description_v4 object
 * delivers either failed or ready event; or
 * - if create request was not issued, this
 * xx_image_description_creator_icc_v4 object is destroyed.
 *
 * A compositor shall not modify the contents of the file, and the fd may
 * be sealed for writes and size changes. The client must ensure to its
 * best ability that the data does not change while the compositor is
 * reading it.
 *
 * The data must represent a valid ICC profile. The ICC profile version
 * must be 2 or 4, it must be a 3 channel profile and the class must be
 * Display or ColorSpace. Violating these requirements will not result in a
 * protocol error but will eventually send the
 * xx_image_description_v4.failed event on the created
 * xx_image_description_v4 with the 'unsupported' cause.
 *
 * See the International Color Consortium specification ICC.1:2022 for more
 * details about ICC profiles.
 *
 * If ICC file has already been set on this object, the protocol error
 * already_set is raised.
 */
static inline void xx_image_description_creator_icc_v4_set_icc_file(
    struct xx_image_description_creator_icc_v4*
        xx_image_description_creator_icc_v4,
    int32_t icc_profile, uint32_t offset, uint32_t length) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_icc_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_ICC_V4_SET_ICC_FILE, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_icc_v4),
      0, icc_profile, offset, length);
}

#ifndef XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_ENUM
#  define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_ENUM
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 * protocol errors
 */
enum xx_image_description_creator_params_v4_error {
  /**
   * incomplete parameter set
   */
  XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_INCOMPLETE_SET = 0,
  /**
   * invalid combination of parameters
   */
  XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_INCONSISTENT_SET = 1,
  /**
   * property already set
   */
  XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_ALREADY_SET = 2,
  /**
   * request not supported
   */
  XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_UNSUPPORTED_FEATURE = 3,
  /**
   * invalid transfer characteristic
   */
  XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_INVALID_TF = 4,
  /**
   * invalid primaries or white point
   */
  XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_INVALID_PRIMARIES = 5,
  /**
   * invalid luminance value or range
   */
  XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_INVALID_LUMINANCE = 6,
  /**
   * invalid mastering information
   */
  XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_INVALID_MASTERING = 7,
};
#endif /* XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_ERROR_ENUM */

#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_CREATE 0
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_TF_NAMED 1
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_TF_POWER 2
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_PRIMARIES_NAMED 3
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_PRIMARIES 4
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_LUMINANCES 5
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MASTERING_DISPLAY_PRIMARIES 6
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MASTERING_LUMINANCE 7
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MAX_CLL 8
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MAX_FALL 9

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_CREATE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_TF_NAMED_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_TF_POWER_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_PRIMARIES_NAMED_SINCE_VERSION \
  1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_PRIMARIES_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_LUMINANCES_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MASTERING_DISPLAY_PRIMARIES_SINCE_VERSION \
  1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MASTERING_LUMINANCE_SINCE_VERSION \
  1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MAX_CLL_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_creator_params_v4
 */
#define XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MAX_FALL_SINCE_VERSION 1

/** @ingroup iface_xx_image_description_creator_params_v4 */
static inline void xx_image_description_creator_params_v4_set_user_data(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    void* user_data) {
  wl_proxy_set_user_data(
      (struct wl_proxy*)xx_image_description_creator_params_v4, user_data);
}

/** @ingroup iface_xx_image_description_creator_params_v4 */
static inline void* xx_image_description_creator_params_v4_get_user_data(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4) {
  return wl_proxy_get_user_data(
      (struct wl_proxy*)xx_image_description_creator_params_v4);
}

static inline uint32_t xx_image_description_creator_params_v4_get_version(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4) {
  return wl_proxy_get_version(
      (struct wl_proxy*)xx_image_description_creator_params_v4);
}

/** @ingroup iface_xx_image_description_creator_params_v4 */
static inline void xx_image_description_creator_params_v4_destroy(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4) {
  wl_proxy_destroy((struct wl_proxy*)xx_image_description_creator_params_v4);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Create an image description object based on the parameters previously
 * set on this object.
 *
 * The completeness of the parameter set is verified. If the set is not
 * complete, the protocol error incomplete_set is raised. For the
 * definition of a complete set, see the description of this interface.
 *
 * Also, the combination of the parameter set is verified. If the set is
 * not consistent, the protocol error inconsistent_set is raised.
 *
 * If the particular combination of the parameter set is not supported
 * by the compositor, the resulting image description object shall
 * immediately deliver the xx_image_description_v4.failed event with the
 * 'unsupported' cause. If a valid image description was created from the
 * parameter set, the xx_image_description_v4.ready event will eventually
 * be sent instead.
 *
 * This request destroys the xx_image_description_creator_params_v4
 * object.
 *
 * The resulting image description object does not allow get_information
 * request.
 */
static inline struct xx_image_description_v4*
xx_image_description_creator_params_v4_create(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4) {
  struct wl_proxy* image_description;

  image_description = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_CREATE,
      &xx_image_description_v4_interface,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      WL_MARSHAL_FLAG_DESTROY, NULL);

  return (struct xx_image_description_v4*)image_description;
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Sets the transfer characteristic using explicitly enumerated named
 * functions.
 *
 * When the resulting image description is attached to an image, the
 * content should be encoded and decoded according to the industry standard
 * practices for the transfer characteristic.
 *
 * Only names advertised with xx_color_manager_v4 event supported_tf_named
 * are allowed. Other values shall raise the protocol error invalid_tf.
 *
 * If transfer characteristic has already been set on this object, the
 * protocol error already_set is raised.
 */
static inline void xx_image_description_creator_params_v4_set_tf_named(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    uint32_t tf) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_TF_NAMED, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, tf);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Sets the color component transfer characteristic to a power curve with
 * the given exponent. This curve represents the conversion from electrical
 * to optical pixel or color values.
 *
 * When the resulting image description is attached to an image, the
 * content should be encoded with the inverse of the power curve.
 *
 * The curve exponent shall be multiplied by 10000 to get the argument eexp
 * value to carry the precision of 4 decimals.
 *
 * The curve exponent must be at least 1.0 and at most 10.0. Otherwise the
 * protocol error invalid_tf is raised.
 *
 * If transfer characteristic has already been set on this object, the
 * protocol error already_set is raised.
 *
 * This request can be used when the compositor advertises
 * xx_color_manager_v4.feature.set_tf_power. Otherwise this request raises
 * the protocol error unsupported_feature.
 */
static inline void xx_image_description_creator_params_v4_set_tf_power(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    uint32_t eexp) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_TF_POWER, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, eexp);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Sets the color primaries and white point using explicitly named sets.
 * This describes the primary color volume which is the basis for color
 * value encoding.
 *
 * Only names advertised with xx_color_manager_v4 event
 * supported_primaries_named are allowed. Other values shall raise the
 * protocol error invalid_primaries.
 *
 * If primaries have already been set on this object, the protocol error
 * already_set is raised.
 */
static inline void xx_image_description_creator_params_v4_set_primaries_named(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    uint32_t primaries) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_PRIMARIES_NAMED, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, primaries);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Sets the color primaries and white point using CIE 1931 xy chromaticity
 * coordinates. This describes the primary color volume which is the basis
 * for color value encoding.
 *
 * Each coordinate value is multiplied by 10000 to get the argument value
 * to carry precision of 4 decimals.
 *
 * If primaries have already been set on this object, the protocol error
 * already_set is raised.
 *
 * This request can be used if the compositor advertises
 * xx_color_manager_v4.feature.set_primaries. Otherwise this request raises
 * the protocol error unsupported_feature.
 */
static inline void xx_image_description_creator_params_v4_set_primaries(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    int32_t r_x, int32_t r_y, int32_t g_x, int32_t g_y, int32_t b_x,
    int32_t b_y, int32_t w_x, int32_t w_y) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_PRIMARIES, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, r_x, r_y, g_x, g_y, b_x, b_y, w_x, w_y);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Sets the primary color volume luminance range and the reference white
 * luminance level.
 *
 * The default luminances are
 * - primary color volume minimum: 0.2 cd/m²
 * - primary color volume maximum: 80 cd/m²
 * - reference white: 80 cd/m²
 *
 * Setting a named transfer characteristic can imply other default
 * luminances.
 *
 * The default luminances get overwritten when this request is used.
 *
 * 'min_lum' and 'max_lum' specify the minimum and maximum luminances of
 * the primary color volume as reproduced by the targeted display.
 *
 * 'reference_lum' specifies the luminance of the reference white as
 * reproduced by the targeted display, and reflects the targeted viewing
 * environment.
 *
 * Compositors should make sure that all content is anchored, meaning that
 * an input signal level of 'reference_lum' on one image description and
 * another input signal level of 'reference_lum' on another image
 * description should produce the same output level, even though the
 * 'reference_lum' on both image representations can be different.
 *
 * If 'max_lum' is less than the 'reference_lum', or 'reference_lum' is
 * less than or equal to 'min_lum', the protocol error invalid_luminance is
 * raised.
 *
 * The minimum luminance is multiplied by 10000 to get the argument
 * 'min_lum' value and carries precision of 4 decimals. The maximum
 * luminance and reference white luminance values are unscaled.
 *
 * If the primary color volume luminance range and the reference white
 * luminance level have already been set on this object, the protocol error
 * already_set is raised.
 *
 * This request can be used if the compositor advertises
 * xx_color_manager_v4.feature.set_luminances. Otherwise this request
 * raises the protocol error unsupported_feature.
 */
static inline void xx_image_description_creator_params_v4_set_luminances(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    uint32_t min_lum, uint32_t max_lum, uint32_t reference_lum) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_LUMINANCES, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, min_lum, max_lum, reference_lum);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Provides the color primaries and white point of the mastering display
 * using CIE 1931 xy chromaticity coordinates. This is compatible with the
 * SMPTE ST 2086 definition of HDR static metadata.
 *
 * The mastering display primaries define the target color volume.
 *
 * If mastering display primaries are not explicitly set, the target color
 * volume is assumed to be equal to the primary color volume.
 *
 * The target color volume is defined by all tristimulus values between 0.0
 * and 1.0 (inclusive) of the color space defined by the given mastering
 * display primaries and white point. The colorimetry is identical between
 * the container color space and the mastering display color space,
 * including that no chromatic adaptation is applied even if the white
 * points differ.
 *
 * The target color volume can exceed the primary color volume to allow for
 * a greater color volume with an existing color space definition (for
 * example scRGB). It can be smaller than the primary color volume to
 * minimize gamut and tone mapping distances for big color spaces (HDR
 * metadata).
 *
 * To make use of the entire target color volume a suitable pixel format
 * has to be chosen (e.g. floating point to exceed the primary color
 * volume, or abusing limited quantization range as with xvYCC).
 *
 * Each coordinate value is multiplied by 10000 to get the argument value
 * to carry precision of 4 decimals.
 *
 * If mastering display primaries have already been set on this object, the
 * protocol error already_set is raised.
 *
 * This request can be used if the compositor advertises
 * xx_color_manager_v4.feature.set_mastering_display_primaries. Otherwise
 * this request raises the protocol error unsupported_feature. The
 * advertisement implies support only for target color volumes fully
 * contained within the primary color volume.
 *
 * If a compositor additionally supports target color volume exceeding the
 * primary color volume, it must advertise
 * xx_color_manager_v4.feature.extended_target_volume. If a client uses
 * target color volume exceeding the primary color volume and the
 * compositor does not support it, the result is implementation defined.
 * Compositors are recommended to detect this case and fail the image
 * description gracefully, but it may as well result in color artifacts.
 */
static inline void
xx_image_description_creator_params_v4_set_mastering_display_primaries(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    int32_t r_x, int32_t r_y, int32_t g_x, int32_t g_y, int32_t b_x,
    int32_t b_y, int32_t w_x, int32_t w_y) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MASTERING_DISPLAY_PRIMARIES,
      NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, r_x, r_y, g_x, g_y, b_x, b_y, w_x, w_y);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Sets the luminance range that was used during the content mastering
 * process as the minimum and maximum absolute luminance L. This is
 * compatible with the SMPTE ST 2086 definition of HDR static metadata.
 *
 * The mastering luminance range is undefined by default.
 *
 * If max L is less than or equal to min L, the protocol error
 * invalid_luminance is raised.
 *
 * Min L value is multiplied by 10000 to get the argument min_lum value
 * and carry precision of 4 decimals. Max L value is unscaled for max_lum.
 */
static inline void
xx_image_description_creator_params_v4_set_mastering_luminance(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    uint32_t min_lum, uint32_t max_lum) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MASTERING_LUMINANCE, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, min_lum, max_lum);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Sets the maximum content light level (max_cll) as defined by CTA-861-H.
 *
 * This can only be set when set_tf_cicp is used to set the transfer
 * characteristic to Rec. ITU-R BT.2100-2 perceptual quantization system.
 * Otherwise, 'create' request shall raise inconsistent_set protocol
 * error.
 *
 * max_cll is undefined by default.
 */
static inline void xx_image_description_creator_params_v4_set_max_cll(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    uint32_t max_cll) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MAX_CLL, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, max_cll);
}

/**
 * @ingroup iface_xx_image_description_creator_params_v4
 *
 * Sets the maximum frame-average light level (max_fall) as defined by
 * CTA-861-H.
 *
 * This can only be set when set_tf_cicp is used to set the transfer
 * characteristic to Rec. ITU-R BT.2100-2 perceptual quantization system.
 * Otherwise, 'create' request shall raise inconsistent_set protocol error.
 *
 * max_fall is undefined by default.
 */
static inline void xx_image_description_creator_params_v4_set_max_fall(
    struct xx_image_description_creator_params_v4*
        xx_image_description_creator_params_v4,
    uint32_t max_fall) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_creator_params_v4,
      XX_IMAGE_DESCRIPTION_CREATOR_PARAMS_V4_SET_MAX_FALL, NULL,
      wl_proxy_get_version(
          (struct wl_proxy*)xx_image_description_creator_params_v4),
      0, max_fall);
}

#ifndef XX_IMAGE_DESCRIPTION_V4_ERROR_ENUM
#  define XX_IMAGE_DESCRIPTION_V4_ERROR_ENUM
/**
 * @ingroup iface_xx_image_description_v4
 * protocol errors
 */
enum xx_image_description_v4_error {
  /**
   * attempted to use an object which is not ready
   */
  XX_IMAGE_DESCRIPTION_V4_ERROR_NOT_READY = 0,
  /**
   * get_information not allowed
   */
  XX_IMAGE_DESCRIPTION_V4_ERROR_NO_INFORMATION = 1,
};
#endif /* XX_IMAGE_DESCRIPTION_V4_ERROR_ENUM */

#ifndef XX_IMAGE_DESCRIPTION_V4_CAUSE_ENUM
#  define XX_IMAGE_DESCRIPTION_V4_CAUSE_ENUM
/**
 * @ingroup iface_xx_image_description_v4
 * generic reason for failure
 */
enum xx_image_description_v4_cause {
  /**
   * interface version too low
   */
  XX_IMAGE_DESCRIPTION_V4_CAUSE_LOW_VERSION = 0,
  /**
   * unsupported image description data
   */
  XX_IMAGE_DESCRIPTION_V4_CAUSE_UNSUPPORTED = 1,
  /**
   * error independent of the client
   */
  XX_IMAGE_DESCRIPTION_V4_CAUSE_OPERATING_SYSTEM = 2,
  /**
   * the relevant output no longer exists
   */
  XX_IMAGE_DESCRIPTION_V4_CAUSE_NO_OUTPUT = 3,
};
#endif /* XX_IMAGE_DESCRIPTION_V4_CAUSE_ENUM */

/**
 * @ingroup iface_xx_image_description_v4
 * @struct xx_image_description_v4_listener
 */
struct xx_image_description_v4_listener {
  /**
   * graceful error on creating the image description
   *
   * If creating a xx_image_description_v4 object fails for a
   * reason that is not defined as a protocol error, this event is
   * sent.
   *
   * The requests that create image description objects define
   * whether and when this can occur. Only such creation requests can
   * trigger this event. This event cannot be triggered after the
   * image description was successfully formed.
   *
   * Once this event has been sent, the xx_image_description_v4
   * object will never become ready and it can only be destroyed.
   * @param cause generic reason
   * @param msg ad hoc human-readable explanation
   */
  void (*failed)(void* data,
                 struct xx_image_description_v4* xx_image_description_v4,
                 uint32_t cause, const char* msg);
  /**
   * indication that the object is ready to be used
   *
   * Once this event has been sent, the xx_image_description_v4
   * object is deemed "ready". Ready objects can be used to send
   * requests and can be used through other interfaces.
   *
   * Every ready xx_image_description_v4 protocol object refers to an
   * underlying image description record in the compositor. Multiple
   * protocol objects may end up referring to the same record.
   * Clients may identify these "copies" by comparing their id
   * numbers: if the numbers from two protocol objects are identical,
   * the protocol objects refer to the same image description record.
   * Two different image description records cannot have the same id
   * number simultaneously. The id number does not change during the
   * lifetime of the image description record.
   *
   * The id number is valid only as long as the protocol object is
   * alive. If all protocol objects referring to the same image
   * description record are destroyed, the id number may be recycled
   * for a different image description record.
   *
   * Image description id number is not a protocol object id. Zero is
   * reserved as an invalid id number. It shall not be possible for a
   * client to refer to an image description by its id number in
   * protocol. The id numbers might not be portable between Wayland
   * connections.
   *
   * This identity allows clients to de-duplicate image description
   * records and avoid get_information request if they already have
   * the image description information.
   * @param identity image description id number
   */
  void (*ready)(void* data,
                struct xx_image_description_v4* xx_image_description_v4,
                uint32_t identity);
};

/**
 * @ingroup iface_xx_image_description_v4
 */
static inline int xx_image_description_v4_add_listener(
    struct xx_image_description_v4* xx_image_description_v4,
    const struct xx_image_description_v4_listener* listener, void* data) {
  return wl_proxy_add_listener((struct wl_proxy*)xx_image_description_v4,
                               (void (**)(void))listener, data);
}

#define XX_IMAGE_DESCRIPTION_V4_DESTROY 0
#define XX_IMAGE_DESCRIPTION_V4_GET_INFORMATION 1

/**
 * @ingroup iface_xx_image_description_v4
 */
#define XX_IMAGE_DESCRIPTION_V4_FAILED_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_v4
 */
#define XX_IMAGE_DESCRIPTION_V4_READY_SINCE_VERSION 1

/**
 * @ingroup iface_xx_image_description_v4
 */
#define XX_IMAGE_DESCRIPTION_V4_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_v4
 */
#define XX_IMAGE_DESCRIPTION_V4_GET_INFORMATION_SINCE_VERSION 1

/** @ingroup iface_xx_image_description_v4 */
static inline void xx_image_description_v4_set_user_data(
    struct xx_image_description_v4* xx_image_description_v4, void* user_data) {
  wl_proxy_set_user_data((struct wl_proxy*)xx_image_description_v4, user_data);
}

/** @ingroup iface_xx_image_description_v4 */
static inline void* xx_image_description_v4_get_user_data(
    struct xx_image_description_v4* xx_image_description_v4) {
  return wl_proxy_get_user_data((struct wl_proxy*)xx_image_description_v4);
}

static inline uint32_t xx_image_description_v4_get_version(
    struct xx_image_description_v4* xx_image_description_v4) {
  return wl_proxy_get_version((struct wl_proxy*)xx_image_description_v4);
}

/**
 * @ingroup iface_xx_image_description_v4
 *
 * Destroy this object. It is safe to destroy an object which is not ready.
 *
 * Destroying a xx_image_description_v4 object has no side-effects, not
 * even if a xx_color_management_surface_v4.set_image_description has not
 * yet been followed by a wl_surface.commit.
 */
static inline void xx_image_description_v4_destroy(
    struct xx_image_description_v4* xx_image_description_v4) {
  wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_v4,
      XX_IMAGE_DESCRIPTION_V4_DESTROY, NULL,
      wl_proxy_get_version((struct wl_proxy*)xx_image_description_v4),
      WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_xx_image_description_v4
 *
 * Creates a xx_image_description_info_v4 object which delivers the
 * information that makes up the image description.
 *
 * Not all image description protocol objects allow get_information
 * request. Whether it is allowed or not is defined by the request that
 * created the object. If get_information is not allowed, the protocol
 * error no_information is raised.
 */
static inline struct xx_image_description_info_v4*
xx_image_description_v4_get_information(
    struct xx_image_description_v4* xx_image_description_v4) {
  struct wl_proxy* information;

  information = wl_proxy_marshal_flags(
      (struct wl_proxy*)xx_image_description_v4,
      XX_IMAGE_DESCRIPTION_V4_GET_INFORMATION,
      &xx_image_description_info_v4_interface,
      wl_proxy_get_version((struct wl_proxy*)xx_image_description_v4), 0, NULL);

  return (struct xx_image_description_info_v4*)information;
}

/**
 * @ingroup iface_xx_image_description_info_v4
 * @struct xx_image_description_info_v4_listener
 */
struct xx_image_description_info_v4_listener {
  /**
   * end of information
   *
   * Signals the end of information events and destroys the object.
   */
  void (*done)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4);
  /**
   * ICC profile matching the image description
   *
   * The icc argument provides a file descriptor to the client
   * which may be memory-mapped to provide the ICC profile matching
   * the image description. The fd is read-only, and if mapped then
   * it must be mapped with MAP_PRIVATE by the client.
   *
   * The ICC profile version and other details are determined by the
   * compositor. There is no provision for a client to ask for a
   * specific kind of a profile.
   * @param icc ICC profile file descriptor
   * @param icc_size ICC profile size, in bytes
   */
  void (*icc_file)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      int32_t icc, uint32_t icc_size);
  /**
   * primaries as chromaticity coordinates
   *
   * Delivers the primary color volume primaries and white point
   * using CIE 1931 xy chromaticity coordinates.
   *
   * Each coordinate value is multiplied by 10000 to get the argument
   * value to carry precision of 4 decimals.
   * @param r_x Red x * 10000
   * @param r_y Red y * 10000
   * @param g_x Green x * 10000
   * @param g_y Green y * 10000
   * @param b_x Blue x * 10000
   * @param b_y Blue y * 10000
   * @param w_x White x * 10000
   * @param w_y White y * 10000
   */
  void (*primaries)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      int32_t r_x, int32_t r_y, int32_t g_x, int32_t g_y, int32_t b_x,
      int32_t b_y, int32_t w_x, int32_t w_y);
  /**
   * named primaries
   *
   * Delivers the primary color volume primaries and white point
   * using an explicitly enumerated named set.
   * @param primaries named primaries
   */
  void (*primaries_named)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      uint32_t primaries);
  /**
   * transfer characteristic as a power curve
   *
   * The color component transfer characteristic of this image
   * description is a pure power curve. This event provides the
   * exponent of the power function. This curve represents the
   * conversion from electrical to optical pixel or color values.
   *
   * The curve exponent has been multiplied by 10000 to get the
   * argument eexp value to carry the precision of 4 decimals.
   * @param eexp the exponent * 10000
   */
  void (*tf_power)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      uint32_t eexp);
  /**
   * named transfer characteristic
   *
   * Delivers the transfer characteristic using an explicitly
   * enumerated named function.
   * @param tf named transfer function
   */
  void (*tf_named)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      uint32_t tf);
  /**
   * primary color volume luminance range and reference white
   *
   * Delivers the primary color volume luminance range and the
   * reference white luminance level.
   *
   * The minimum luminance is multiplied by 10000 to get the argument
   * 'min_lum' value and carries precision of 4 decimals. The maximum
   * luminance and reference white luminance values are unscaled.
   * @param min_lum minimum luminance (cd/m²) * 10000
   * @param max_lum maximum luminance (cd/m²)
   * @param reference_lum reference white luminance (cd/m²)
   */
  void (*luminances)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      uint32_t min_lum, uint32_t max_lum, uint32_t reference_lum);
  /**
   * target primaries as chromaticity coordinates
   *
   * Provides the color primaries and white point of the target
   * color volume using CIE 1931 xy chromaticity coordinates. This is
   * compatible with the SMPTE ST 2086 definition of HDR static
   * metadata for mastering displays.
   *
   * While primary color volume is about how color is encoded, the
   * target color volume is the actually displayable color volume. If
   * target color volume is equal to the primary color volume, then
   * this event is not sent.
   *
   * Each coordinate value is multiplied by 10000 to get the argument
   * value to carry precision of 4 decimals.
   * @param r_x Red x * 10000
   * @param r_y Red y * 10000
   * @param g_x Green x * 10000
   * @param g_y Green y * 10000
   * @param b_x Blue x * 10000
   * @param b_y Blue y * 10000
   * @param w_x White x * 10000
   * @param w_y White y * 10000
   */
  void (*target_primaries)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      int32_t r_x, int32_t r_y, int32_t g_x, int32_t g_y, int32_t b_x,
      int32_t b_y, int32_t w_x, int32_t w_y);
  /**
   * target luminance range
   *
   * Provides the luminance range that the image description is
   * targeting as the minimum and maximum absolute luminance L. This
   * is compatible with the SMPTE ST 2086 definition of HDR static
   * metadata.
   *
   * This luminance range is only theoretical and may not correspond
   * to the luminance of light emitted on an actual display.
   *
   * Min L value is multiplied by 10000 to get the argument min_lum
   * value and carry precision of 4 decimals. Max L value is unscaled
   * for max_lum.
   * @param min_lum min L (cd/m²) * 10000
   * @param max_lum max L (cd/m²)
   */
  void (*target_luminance)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      uint32_t min_lum, uint32_t max_lum);
  /**
   * target maximum content light level
   *
   * Provides the targeted max_cll of the image description.
   * max_cll is defined by CTA-861-H.
   *
   * This luminance is only theoretical and may not correspond to the
   * luminance of light emitted on an actual display.
   * @param max_cll Maximum content light-level (cd/m²)
   */
  void (*target_max_cll)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      uint32_t max_cll);
  /**
   * target maximum frame-average light level
   *
   * Provides the targeted max_fall of the image description.
   * max_fall is defined by CTA-861-H.
   *
   * This luminance is only theoretical and may not correspond to the
   * luminance of light emitted on an actual display.
   * @param max_fall Maximum frame-average light level (cd/m²)
   */
  void (*target_max_fall)(
      void* data,
      struct xx_image_description_info_v4* xx_image_description_info_v4,
      uint32_t max_fall);
};

/**
 * @ingroup iface_xx_image_description_info_v4
 */
static inline int xx_image_description_info_v4_add_listener(
    struct xx_image_description_info_v4* xx_image_description_info_v4,
    const struct xx_image_description_info_v4_listener* listener, void* data) {
  return wl_proxy_add_listener((struct wl_proxy*)xx_image_description_info_v4,
                               (void (**)(void))listener, data);
}

/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_DONE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_ICC_FILE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_PRIMARIES_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_PRIMARIES_NAMED_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_TF_POWER_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_TF_NAMED_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_LUMINANCES_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_TARGET_PRIMARIES_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_TARGET_LUMINANCE_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_TARGET_MAX_CLL_SINCE_VERSION 1
/**
 * @ingroup iface_xx_image_description_info_v4
 */
#define XX_IMAGE_DESCRIPTION_INFO_V4_TARGET_MAX_FALL_SINCE_VERSION 1

/** @ingroup iface_xx_image_description_info_v4 */
static inline void xx_image_description_info_v4_set_user_data(
    struct xx_image_description_info_v4* xx_image_description_info_v4,
    void* user_data) {
  wl_proxy_set_user_data((struct wl_proxy*)xx_image_description_info_v4,
                         user_data);
}

/** @ingroup iface_xx_image_description_info_v4 */
static inline void* xx_image_description_info_v4_get_user_data(
    struct xx_image_description_info_v4* xx_image_description_info_v4) {
  return wl_proxy_get_user_data((struct wl_proxy*)xx_image_description_info_v4);
}

static inline uint32_t xx_image_description_info_v4_get_version(
    struct xx_image_description_info_v4* xx_image_description_info_v4) {
  return wl_proxy_get_version((struct wl_proxy*)xx_image_description_info_v4);
}

/** @ingroup iface_xx_image_description_info_v4 */
static inline void xx_image_description_info_v4_destroy(
    struct xx_image_description_info_v4* xx_image_description_info_v4) {
  wl_proxy_destroy((struct wl_proxy*)xx_image_description_info_v4);
}

#ifdef __cplusplus
}
#endif

#endif

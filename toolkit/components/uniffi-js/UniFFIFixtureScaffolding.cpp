// Generated by uniffi-bindgen-gecko-js.  DO NOT EDIT.

#include "nsString.h"
#include "nsPrintfCString.h"
#include "mozilla/Logging.h"
#include "mozilla/Maybe.h"
#include "mozilla/StaticPtr.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/ScaffoldingConverter.h"
#include "mozilla/dom/UniFFICall.h"
#include "mozilla/dom/UniFFICallbacks.h"
#include "mozilla/dom/UniFFIPointerType.h"
#include "mozilla/dom/UniFFIScaffolding.h"
#include "mozilla/dom/UniFFIRust.h"

namespace mozilla::uniffi {

using dom::ArrayBuffer;
using dom::AutoEntryScript;
using dom::GlobalObject;
using dom::RootedDictionary;
using dom::Promise;
using dom::UniFFIScaffoldingValue;
using dom::Sequence;
using dom::UniFFICallbackHandler;
using dom::UniFFIPointer;
using dom::UniFFIScaffoldingCallResult;

// Define scaffolding functions from UniFFI
extern "C" {
  uint64_t uniffi_arithmetical_fn_func_add(uint64_t, uint64_t, RustCallStatus*);
  uint64_t uniffi_arithmetical_fn_func_div(uint64_t, uint64_t, RustCallStatus*);
  int8_t uniffi_arithmetical_fn_func_equal(uint64_t, uint64_t, RustCallStatus*);
  uint64_t uniffi_arithmetical_fn_func_sub(uint64_t, uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_custom_types_fn_func_get_custom_types_demo(RustBuffer, RustCallStatus*);
  double uniffi_uniffi_fixture_external_types_fn_func_gradient(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_fixture_external_types_fn_func_intersection(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_fixture_refcounts_fn_clone_singletonobject(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_refcounts_fn_free_singletonobject(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_refcounts_fn_method_singletonobject_method(void*, RustCallStatus*);
  int32_t uniffi_uniffi_fixture_refcounts_fn_func_get_js_refcount(RustCallStatus*);
  void* uniffi_uniffi_fixture_refcounts_fn_func_get_singleton(RustCallStatus*);
  double uniffi_uniffi_geometry_fn_func_gradient(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_geometry_fn_func_intersection(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_clone_optionneur(void*, RustCallStatus*);
  void uniffi_uniffi_rondpoint_fn_free_optionneur(void*, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_constructor_optionneur_new(RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_boolean(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_enum(void*, RustBuffer, RustCallStatus*);
  float uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_f32(void*, float, RustCallStatus*);
  double uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_f64(void*, double, RustCallStatus*);
  int16_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i16_dec(void*, int16_t, RustCallStatus*);
  int16_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i16_hex(void*, int16_t, RustCallStatus*);
  int32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i32_dec(void*, int32_t, RustCallStatus*);
  int32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i32_hex(void*, int32_t, RustCallStatus*);
  int64_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i64_dec(void*, int64_t, RustCallStatus*);
  int64_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i64_hex(void*, int64_t, RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i8_dec(void*, int8_t, RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i8_hex(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_null(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_sequence(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_string(void*, RustBuffer, RustCallStatus*);
  uint16_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u16_dec(void*, uint16_t, RustCallStatus*);
  uint16_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u16_hex(void*, uint16_t, RustCallStatus*);
  uint32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_dec(void*, uint32_t, RustCallStatus*);
  uint32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_hex(void*, uint32_t, RustCallStatus*);
  uint32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_oct(void*, uint32_t, RustCallStatus*);
  uint64_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u64_dec(void*, uint64_t, RustCallStatus*);
  uint64_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u64_hex(void*, uint64_t, RustCallStatus*);
  uint8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u8_dec(void*, uint8_t, RustCallStatus*);
  uint8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u8_hex(void*, uint8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_zero(void*, RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_clone_retourneur(void*, RustCallStatus*);
  void uniffi_uniffi_rondpoint_fn_free_retourneur(void*, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_constructor_retourneur_new(RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_boolean(void*, int8_t, RustCallStatus*);
  double uniffi_uniffi_rondpoint_fn_method_retourneur_identique_double(void*, double, RustCallStatus*);
  float uniffi_uniffi_rondpoint_fn_method_retourneur_identique_float(void*, float, RustCallStatus*);
  int16_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i16(void*, int16_t, RustCallStatus*);
  int32_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i32(void*, int32_t, RustCallStatus*);
  int64_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i64(void*, int64_t, RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i8(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_retourneur_identique_nombres(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_retourneur_identique_nombres_signes(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_retourneur_identique_optionneur_dictionnaire(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_retourneur_identique_string(void*, RustBuffer, RustCallStatus*);
  uint16_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u16(void*, uint16_t, RustCallStatus*);
  uint32_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u32(void*, uint32_t, RustCallStatus*);
  uint64_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u64(void*, uint64_t, RustCallStatus*);
  uint8_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u8(void*, uint8_t, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_clone_stringifier(void*, RustCallStatus*);
  void uniffi_uniffi_rondpoint_fn_free_stringifier(void*, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_constructor_stringifier_new(RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_boolean(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_double(void*, double, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_float(void*, float, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i16(void*, int16_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i32(void*, int32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i64(void*, int64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i8(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u16(void*, uint16_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u32(void*, uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u64(void*, uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u8(void*, uint8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_well_known_string(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_func_copie_carte(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_func_copie_dictionnaire(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_func_copie_enumeration(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_func_copie_enumerations(RustBuffer, RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_func_switcheroo(int8_t, RustCallStatus*);
  void* uniffi_uniffi_sprites_fn_clone_sprite(void*, RustCallStatus*);
  void uniffi_uniffi_sprites_fn_free_sprite(void*, RustCallStatus*);
  void* uniffi_uniffi_sprites_fn_constructor_sprite_new(RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_sprites_fn_constructor_sprite_new_relative_to(RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_sprites_fn_method_sprite_get_position(void*, RustCallStatus*);
  void uniffi_uniffi_sprites_fn_method_sprite_move_by(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_sprites_fn_method_sprite_move_to(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_sprites_fn_func_translate(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_todolist_fn_clone_todolist(void*, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_free_todolist(void*, RustCallStatus*);
  void* uniffi_uniffi_todolist_fn_constructor_todolist_new(RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_add_entries(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_add_entry(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_add_item(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_add_items(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_clear_item(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_entries(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_first(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_items(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_last(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_last_entry(void*, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_make_default(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_func_create_entry_with(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_func_get_default_list(RustCallStatus*);
  void uniffi_uniffi_todolist_fn_func_set_default_list(void*, RustCallStatus*);
}

// Define pointer types
const static mozilla::uniffi::UniFFIPointerType kRefcountsSingletonObjectPointerType {
  "refcounts::SingletonObject"_ns,
  uniffi_uniffi_fixture_refcounts_fn_clone_singletonobject,
  uniffi_uniffi_fixture_refcounts_fn_free_singletonobject,
};
const static mozilla::uniffi::UniFFIPointerType kRondpointOptionneurPointerType {
  "rondpoint::Optionneur"_ns,
  uniffi_uniffi_rondpoint_fn_clone_optionneur,
  uniffi_uniffi_rondpoint_fn_free_optionneur,
};
const static mozilla::uniffi::UniFFIPointerType kRondpointRetourneurPointerType {
  "rondpoint::Retourneur"_ns,
  uniffi_uniffi_rondpoint_fn_clone_retourneur,
  uniffi_uniffi_rondpoint_fn_free_retourneur,
};
const static mozilla::uniffi::UniFFIPointerType kRondpointStringifierPointerType {
  "rondpoint::Stringifier"_ns,
  uniffi_uniffi_rondpoint_fn_clone_stringifier,
  uniffi_uniffi_rondpoint_fn_free_stringifier,
};
const static mozilla::uniffi::UniFFIPointerType kSpritesSpritePointerType {
  "sprites::Sprite"_ns,
  uniffi_uniffi_sprites_fn_clone_sprite,
  uniffi_uniffi_sprites_fn_free_sprite,
};
const static mozilla::uniffi::UniFFIPointerType kTodolistTodoListPointerType {
  "todolist::TodoList"_ns,
  uniffi_uniffi_todolist_fn_clone_todolist,
  uniffi_uniffi_todolist_fn_free_todolist,
};

// Define the data we need per-callback interface

// Define a lookup function for our callback interface info
Maybe<CallbackInterfaceInfo> UniFFIFixturesGetCallbackInterfaceInfo(uint64_t aInterfaceId) {
    switch(aInterfaceId) {

        default:
            return Nothing();
    }
}

// Define scaffolding call classes for each combination of return/argument types
class ScaffoldingCallHandlerUniFFIFixturesUniffiArithmeticalFnFuncAdd : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mA;
    typename ScaffoldingConverter<uint64_t>::IntermediateType mB;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[0], &mA, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[1], &mB, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint64_t>::FromRust(
            uniffi_arithmetical_fn_func_add(
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mA)),
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mB)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiArithmeticalFnFuncDiv : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mDividend;
    typename ScaffoldingConverter<uint64_t>::IntermediateType mDivisor;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[0], &mDividend, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[1], &mDivisor, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint64_t>::FromRust(
            uniffi_arithmetical_fn_func_div(
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mDividend)),
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mDivisor)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiArithmeticalFnFuncEqual : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mA;
    typename ScaffoldingConverter<uint64_t>::IntermediateType mB;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[0], &mA, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[1], &mB, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int8_t>::FromRust(
            uniffi_arithmetical_fn_func_equal(
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mA)),
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mB)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiArithmeticalFnFuncSub : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mA;
    typename ScaffoldingConverter<uint64_t>::IntermediateType mB;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[0], &mA, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[1], &mB, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint64_t>::FromRust(
            uniffi_arithmetical_fn_func_sub(
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mA)),
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mB)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiCustomTypesFnFuncGetCustomTypesDemo : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mDemo;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mDemo, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_custom_types_fn_func_get_custom_types_demo(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mDemo)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureExternalTypesFnFuncGradient : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<double>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<double>::FromRust(
            uniffi_uniffi_fixture_external_types_fn_func_gradient(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<double>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureExternalTypesFnFuncIntersection : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mLn1;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mLn2;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mLn1, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mLn2, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_fixture_external_types_fn_func_intersection(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mLn1)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mLn2)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureRefcountsFnMethodSingletonobjectMethod : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRefcountsSingletonObjectPointerType>::IntermediateType mPtr;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRefcountsSingletonObjectPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_fixture_refcounts_fn_method_singletonobject_method(
            ScaffoldingObjectConverter<&kRefcountsSingletonObjectPointerType>::IntoRust(std::move(mPtr)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureRefcountsFnFuncGetJsRefcount : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int32_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int32_t>::FromRust(
            uniffi_uniffi_fixture_refcounts_fn_func_get_js_refcount(
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int32_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureRefcountsFnFuncGetSingleton : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingObjectConverter<&kRefcountsSingletonObjectPointerType>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingObjectConverter<&kRefcountsSingletonObjectPointerType>::FromRust(
            uniffi_uniffi_fixture_refcounts_fn_func_get_singleton(
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRefcountsSingletonObjectPointerType>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiGeometryFnFuncGradient : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mLn;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<double>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mLn, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<double>::FromRust(
            uniffi_uniffi_geometry_fn_func_gradient(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mLn)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<double>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiGeometryFnFuncIntersection : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mLn1;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mLn2;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mLn1, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mLn2, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_geometry_fn_func_intersection(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mLn1)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mLn2)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnConstructorOptionneurNew : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromRust(
            uniffi_uniffi_rondpoint_fn_constructor_optionneur_new(
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonBoolean : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_boolean(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonEnum : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_enum(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonF32 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<float>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<float>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<float>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<float>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_f32(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<float>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<float>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonF64 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<double>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<double>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<double>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<double>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_f64(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<double>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<double>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI16Dec : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int16_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int16_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int16_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int16_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i16_dec(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int16_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int16_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI16Hex : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int16_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int16_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int16_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int16_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i16_hex(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int16_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int16_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI32Dec : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int32_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int32_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i32_dec(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int32_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI32Hex : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int32_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int32_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i32_hex(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int32_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI64Dec : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int64_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int64_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int64_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i64_dec(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int64_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI64Hex : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int64_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int64_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int64_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i64_hex(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int64_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI8Dec : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i8_dec(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI8Hex : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i8_hex(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonNull : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_null(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonSequence : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_sequence(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonString : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_string(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU16Dec : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint16_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint16_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint16_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint16_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u16_dec(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint16_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint16_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU16Hex : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint16_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint16_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint16_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint16_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u16_hex(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint16_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint16_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU32Dec : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint32_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint32_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_dec(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint32_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU32Hex : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint32_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint32_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_hex(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint32_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU32Oct : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint32_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint32_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_oct(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint32_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU64Dec : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint64_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint64_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u64_dec(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU64Hex : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint64_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint64_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u64_hex(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU8Dec : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u8_dec(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU8Hex : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u8_hex(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonZero : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_zero(
                ScaffoldingObjectConverter<&kRondpointOptionneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnConstructorRetourneurNew : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromRust(
            uniffi_uniffi_rondpoint_fn_constructor_retourneur_new(
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueBoolean : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_boolean(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueDouble : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<double>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<double>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<double>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<double>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_double(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<double>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<double>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueFloat : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<float>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<float>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<float>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<float>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_float(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<float>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<float>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueI16 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int16_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int16_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int16_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int16_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i16(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int16_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int16_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueI32 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int32_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int32_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i32(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int32_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueI64 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int64_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int64_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int64_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i64(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int64_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueI8 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i8(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueNombres : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_nombres(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueNombresSignes : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_nombres_signes(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueOptionneurDictionnaire : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_optionneur_dictionnaire(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueString : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_string(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueU16 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint16_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint16_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint16_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint16_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u16(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint16_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint16_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueU32 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint32_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint32_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u32(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint32_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueU64 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint64_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint64_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint64_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u64(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint64_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueU8 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<uint8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<uint8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u8(
                ScaffoldingObjectConverter<&kRondpointRetourneurPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<uint8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnConstructorStringifierNew : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromRust(
            uniffi_uniffi_rondpoint_fn_constructor_stringifier_new(
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringBoolean : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_boolean(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringDouble : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<double>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<double>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_double(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<double>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringFloat : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<float>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<float>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_float(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<float>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringI16 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int16_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int16_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i16(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int16_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringI32 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i32(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringI64 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int64_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int64_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i64(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int64_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringI8 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<int8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<int8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i8(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<int8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringU16 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint16_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint16_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u16(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint16_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringU32 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint32_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint32_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u32(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint32_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringU64 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint64_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint64_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u64(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint64_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringU8 : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<uint8_t>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<uint8_t>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u8(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<uint8_t>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierWellKnownString : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mValue;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mValue, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_method_stringifier_well_known_string(
                ScaffoldingObjectConverter<&kRondpointStringifierPointerType>::IntoRust(std::move(mPtr)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mValue)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncCopieCarte : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mC;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mC, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_func_copie_carte(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mC)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncCopieDictionnaire : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mD;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mD, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_func_copie_dictionnaire(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mD)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncCopieEnumeration : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mE;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mE, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_func_copie_enumeration(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mE)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncCopieEnumerations : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mE;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mE, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_rondpoint_fn_func_copie_enumerations(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mE)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncSwitcheroo : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<int8_t>::IntermediateType mB;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<int8_t>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<int8_t>::FromJs(aArgs[0], &mB, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<int8_t>::FromRust(
            uniffi_uniffi_rondpoint_fn_func_switcheroo(
                ScaffoldingConverter<int8_t>::IntoRust(std::move(mB)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<int8_t>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnConstructorSpriteNew : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mInitialPosition;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mInitialPosition, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingObjectConverter<&kSpritesSpritePointerType>::FromRust(
            uniffi_uniffi_sprites_fn_constructor_sprite_new(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mInitialPosition)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnConstructorSpriteNewRelativeTo : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mReference;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mDirection;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mReference, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mDirection, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingObjectConverter<&kSpritesSpritePointerType>::FromRust(
            uniffi_uniffi_sprites_fn_constructor_sprite_new_relative_to(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mReference)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mDirection)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnMethodSpriteGetPosition : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntermediateType mPtr;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kSpritesSpritePointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_sprites_fn_method_sprite_get_position(
                ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntoRust(std::move(mPtr)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnMethodSpriteMoveBy : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mDirection;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kSpritesSpritePointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mDirection, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_sprites_fn_method_sprite_move_by(
            ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntoRust(std::move(mPtr)),
            ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mDirection)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnMethodSpriteMoveTo : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mPosition;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kSpritesSpritePointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mPosition, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_sprites_fn_method_sprite_move_to(
            ScaffoldingObjectConverter<&kSpritesSpritePointerType>::IntoRust(std::move(mPtr)),
            ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mPosition)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnFuncTranslate : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mPosition;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mDirection;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mPosition, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mDirection, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_sprites_fn_func_translate(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mPosition)),
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mDirection)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnConstructorTodolistNew : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromRust(
            uniffi_uniffi_todolist_fn_constructor_todolist_new(
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistAddEntries : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mEntries;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mEntries, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_todolist_fn_method_todolist_add_entries(
            ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
            ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mEntries)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistAddEntry : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mEntry;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mEntry, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_todolist_fn_method_todolist_add_entry(
            ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
            ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mEntry)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistAddItem : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mTodo;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mTodo, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_todolist_fn_method_todolist_add_item(
            ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
            ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mTodo)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistAddItems : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mItems;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mItems, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_todolist_fn_method_todolist_add_items(
            ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
            ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mItems)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistClearItem : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mTodo;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[1], &mTodo, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_todolist_fn_method_todolist_clear_item(
            ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
            ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mTodo)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetEntries : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_todolist_fn_method_todolist_get_entries(
                ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetFirst : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_todolist_fn_method_todolist_get_first(
                ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetItems : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_todolist_fn_method_todolist_get_items(
                ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetLast : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_todolist_fn_method_todolist_get_last(
                ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetLastEntry : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_todolist_fn_method_todolist_get_last_entry(
                ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistMakeDefault : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mPtr;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mPtr, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_todolist_fn_method_todolist_make_default(
            ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mPtr)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnFuncCreateEntryWith : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mTodo;

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::FromJs(aArgs[0], &mTodo, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_todolist_fn_func_create_entry_with(
                ScaffoldingConverter<RustBuffer>::IntoRust(std::move(mTodo)),
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnFuncGetDefaultList : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields

    // MakeRustCall stores the result of the call in these fields
    typename ScaffoldingConverter<RustBuffer>::IntermediateType mUniffiReturnValue;

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        mUniffiReturnValue = ScaffoldingConverter<RustBuffer>::FromRust(
            uniffi_uniffi_todolist_fn_func_get_default_list(
                &callStatus
            )
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
        ScaffoldingConverter<RustBuffer>::IntoJs(
          aCx,
          std::move(mUniffiReturnValue),
          aDest,
          aError
        );
    }
};
class ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnFuncSetDefaultList : public UniffiHandlerBase {
private:
    // PrepareRustArgs stores the resulting arguments in these fields
    typename ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntermediateType mList;

    // MakeRustCall stores the result of the call in these fields

public:
    void PrepareRustArgs(const dom::Sequence<dom::UniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
        ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::FromJs(aArgs[0], &mList, aError);
        if (aError.Failed()) {
            return;
        }
    }

    void MakeRustCall() override {
        RustCallStatus callStatus{};
        uniffi_uniffi_todolist_fn_func_set_default_list(
            ScaffoldingObjectConverter<&kTodolistTodoListPointerType>::IntoRust(std::move(mList)),
            &callStatus
        );

        mUniffiCallStatusCode = callStatus.code;
        if (callStatus.error_buf.data) {
            mUniffiCallStatusErrorBuf = OwnedRustBuffer(callStatus.error_buf);
        }
    }

    virtual void ExtractSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::UniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    }
};

UniquePtr<UniffiHandlerBase> UniFFIFixturesGetHandler(uint64_t aId) {
  switch (aId) {
    case 58: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiArithmeticalFnFuncAdd>();
    }
    case 59: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiArithmeticalFnFuncDiv>();
    }
    case 60: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiArithmeticalFnFuncEqual>();
    }
    case 61: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiArithmeticalFnFuncSub>();
    }
    case 62: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiCustomTypesFnFuncGetCustomTypesDemo>();
    }
    case 63: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureExternalTypesFnFuncGradient>();
    }
    case 64: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureExternalTypesFnFuncIntersection>();
    }
    case 66: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureRefcountsFnMethodSingletonobjectMethod>();
    }
    case 67: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureRefcountsFnFuncGetJsRefcount>();
    }
    case 68: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiFixtureRefcountsFnFuncGetSingleton>();
    }
    case 69: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiGeometryFnFuncGradient>();
    }
    case 70: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiGeometryFnFuncIntersection>();
    }
    case 72: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnConstructorOptionneurNew>();
    }
    case 73: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonBoolean>();
    }
    case 74: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonEnum>();
    }
    case 75: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonF32>();
    }
    case 76: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonF64>();
    }
    case 77: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI16Dec>();
    }
    case 78: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI16Hex>();
    }
    case 79: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI32Dec>();
    }
    case 80: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI32Hex>();
    }
    case 81: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI64Dec>();
    }
    case 82: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI64Hex>();
    }
    case 83: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI8Dec>();
    }
    case 84: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonI8Hex>();
    }
    case 85: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonNull>();
    }
    case 86: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonSequence>();
    }
    case 87: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonString>();
    }
    case 88: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU16Dec>();
    }
    case 89: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU16Hex>();
    }
    case 90: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU32Dec>();
    }
    case 91: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU32Hex>();
    }
    case 92: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU32Oct>();
    }
    case 93: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU64Dec>();
    }
    case 94: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU64Hex>();
    }
    case 95: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU8Dec>();
    }
    case 96: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonU8Hex>();
    }
    case 97: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodOptionneurSinonZero>();
    }
    case 99: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnConstructorRetourneurNew>();
    }
    case 100: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueBoolean>();
    }
    case 101: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueDouble>();
    }
    case 102: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueFloat>();
    }
    case 103: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueI16>();
    }
    case 104: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueI32>();
    }
    case 105: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueI64>();
    }
    case 106: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueI8>();
    }
    case 107: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueNombres>();
    }
    case 108: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueNombresSignes>();
    }
    case 109: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueOptionneurDictionnaire>();
    }
    case 110: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueString>();
    }
    case 111: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueU16>();
    }
    case 112: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueU32>();
    }
    case 113: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueU64>();
    }
    case 114: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodRetourneurIdentiqueU8>();
    }
    case 116: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnConstructorStringifierNew>();
    }
    case 117: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringBoolean>();
    }
    case 118: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringDouble>();
    }
    case 119: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringFloat>();
    }
    case 120: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringI16>();
    }
    case 121: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringI32>();
    }
    case 122: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringI64>();
    }
    case 123: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringI8>();
    }
    case 124: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringU16>();
    }
    case 125: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringU32>();
    }
    case 126: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringU64>();
    }
    case 127: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierToStringU8>();
    }
    case 128: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnMethodStringifierWellKnownString>();
    }
    case 129: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncCopieCarte>();
    }
    case 130: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncCopieDictionnaire>();
    }
    case 131: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncCopieEnumeration>();
    }
    case 132: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncCopieEnumerations>();
    }
    case 133: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiRondpointFnFuncSwitcheroo>();
    }
    case 135: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnConstructorSpriteNew>();
    }
    case 136: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnConstructorSpriteNewRelativeTo>();
    }
    case 137: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnMethodSpriteGetPosition>();
    }
    case 138: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnMethodSpriteMoveBy>();
    }
    case 139: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnMethodSpriteMoveTo>();
    }
    case 140: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiSpritesFnFuncTranslate>();
    }
    case 142: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnConstructorTodolistNew>();
    }
    case 143: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistAddEntries>();
    }
    case 144: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistAddEntry>();
    }
    case 145: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistAddItem>();
    }
    case 146: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistAddItems>();
    }
    case 147: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistClearItem>();
    }
    case 148: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetEntries>();
    }
    case 149: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetFirst>();
    }
    case 150: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetItems>();
    }
    case 151: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetLast>();
    }
    case 152: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistGetLastEntry>();
    }
    case 153: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnMethodTodolistMakeDefault>();
    }
    case 154: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnFuncCreateEntryWith>();
    }
    case 155: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnFuncGetDefaultList>();
    }
    case 156: {
        return MakeUnique<ScaffoldingCallHandlerUniFFIFixturesUniffiUniffiTodolistFnFuncSetDefaultList>();
    }

    default:
      return nullptr;
  }
}

Maybe<already_AddRefed<UniFFIPointer>> UniFFIFixturesReadPointer(const GlobalObject& aGlobal, uint64_t aId, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {
    case 7: { // refcounts:SingletonObject
      type = &kRefcountsSingletonObjectPointerType;
      break;
    }
    case 8: { // rondpoint:Optionneur
      type = &kRondpointOptionneurPointerType;
      break;
    }
    case 9: { // rondpoint:Retourneur
      type = &kRondpointRetourneurPointerType;
      break;
    }
    case 10: { // rondpoint:Stringifier
      type = &kRondpointStringifierPointerType;
      break;
    }
    case 11: { // sprites:Sprite
      type = &kSpritesSpritePointerType;
      break;
    }
    case 12: { // todolist:TodoList
      type = &kTodolistTodoListPointerType;
      break;
    }
    default:
      return Nothing();
  }
  return Some(UniFFIPointer::Read(aArrayBuff, aPosition, type, aError));
}

bool UniFFIFixturesWritePointer(const GlobalObject& aGlobal, uint64_t aId, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {
    case 7: { // refcounts:SingletonObject
      type = &kRefcountsSingletonObjectPointerType;
      break;
    }
    case 8: { // rondpoint:Optionneur
      type = &kRondpointOptionneurPointerType;
      break;
    }
    case 9: { // rondpoint:Retourneur
      type = &kRondpointRetourneurPointerType;
      break;
    }
    case 10: { // rondpoint:Stringifier
      type = &kRondpointStringifierPointerType;
      break;
    }
    case 11: { // sprites:Sprite
      type = &kSpritesSpritePointerType;
      break;
    }
    case 12: { // todolist:TodoList
      type = &kTodolistTodoListPointerType;
      break;
    }
    default:
      return false;
  }
  aPtr.Write(aArrayBuff, aPosition, type, aError);
  return true;
}

}  // namespace mozilla::uniffi

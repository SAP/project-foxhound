// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: content_analysis/sdk/analysis.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_content_5fanalysis_2fsdk_2fanalysis_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_content_5fanalysis_2fsdk_2fanalysis_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_content_5fanalysis_2fsdk_2fanalysis_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto {
  static const uint32_t offsets[];
};
namespace content_analysis {
namespace sdk {
class AgentToChrome;
struct AgentToChromeDefaultTypeInternal;
extern AgentToChromeDefaultTypeInternal _AgentToChrome_default_instance_;
class ChromeToAgent;
struct ChromeToAgentDefaultTypeInternal;
extern ChromeToAgentDefaultTypeInternal _ChromeToAgent_default_instance_;
class ClientDownloadRequest;
struct ClientDownloadRequestDefaultTypeInternal;
extern ClientDownloadRequestDefaultTypeInternal _ClientDownloadRequest_default_instance_;
class ClientDownloadRequest_Resource;
struct ClientDownloadRequest_ResourceDefaultTypeInternal;
extern ClientDownloadRequest_ResourceDefaultTypeInternal _ClientDownloadRequest_Resource_default_instance_;
class ClientMetadata;
struct ClientMetadataDefaultTypeInternal;
extern ClientMetadataDefaultTypeInternal _ClientMetadata_default_instance_;
class ClientMetadata_Browser;
struct ClientMetadata_BrowserDefaultTypeInternal;
extern ClientMetadata_BrowserDefaultTypeInternal _ClientMetadata_Browser_default_instance_;
class ContentAnalysisAcknowledgement;
struct ContentAnalysisAcknowledgementDefaultTypeInternal;
extern ContentAnalysisAcknowledgementDefaultTypeInternal _ContentAnalysisAcknowledgement_default_instance_;
class ContentAnalysisCancelRequests;
struct ContentAnalysisCancelRequestsDefaultTypeInternal;
extern ContentAnalysisCancelRequestsDefaultTypeInternal _ContentAnalysisCancelRequests_default_instance_;
class ContentAnalysisRequest;
struct ContentAnalysisRequestDefaultTypeInternal;
extern ContentAnalysisRequestDefaultTypeInternal _ContentAnalysisRequest_default_instance_;
class ContentAnalysisRequest_PrintData;
struct ContentAnalysisRequest_PrintDataDefaultTypeInternal;
extern ContentAnalysisRequest_PrintDataDefaultTypeInternal _ContentAnalysisRequest_PrintData_default_instance_;
class ContentAnalysisResponse;
struct ContentAnalysisResponseDefaultTypeInternal;
extern ContentAnalysisResponseDefaultTypeInternal _ContentAnalysisResponse_default_instance_;
class ContentAnalysisResponse_Result;
struct ContentAnalysisResponse_ResultDefaultTypeInternal;
extern ContentAnalysisResponse_ResultDefaultTypeInternal _ContentAnalysisResponse_Result_default_instance_;
class ContentAnalysisResponse_Result_TriggeredRule;
struct ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal;
extern ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal _ContentAnalysisResponse_Result_TriggeredRule_default_instance_;
class ContentMetaData;
struct ContentMetaDataDefaultTypeInternal;
extern ContentMetaDataDefaultTypeInternal _ContentMetaData_default_instance_;
class ContentMetaData_PrintMetadata;
struct ContentMetaData_PrintMetadataDefaultTypeInternal;
extern ContentMetaData_PrintMetadataDefaultTypeInternal _ContentMetaData_PrintMetadata_default_instance_;
}  // namespace sdk
}  // namespace content_analysis
PROTOBUF_NAMESPACE_OPEN
template<> ::content_analysis::sdk::AgentToChrome* Arena::CreateMaybeMessage<::content_analysis::sdk::AgentToChrome>(Arena*);
template<> ::content_analysis::sdk::ChromeToAgent* Arena::CreateMaybeMessage<::content_analysis::sdk::ChromeToAgent>(Arena*);
template<> ::content_analysis::sdk::ClientDownloadRequest* Arena::CreateMaybeMessage<::content_analysis::sdk::ClientDownloadRequest>(Arena*);
template<> ::content_analysis::sdk::ClientDownloadRequest_Resource* Arena::CreateMaybeMessage<::content_analysis::sdk::ClientDownloadRequest_Resource>(Arena*);
template<> ::content_analysis::sdk::ClientMetadata* Arena::CreateMaybeMessage<::content_analysis::sdk::ClientMetadata>(Arena*);
template<> ::content_analysis::sdk::ClientMetadata_Browser* Arena::CreateMaybeMessage<::content_analysis::sdk::ClientMetadata_Browser>(Arena*);
template<> ::content_analysis::sdk::ContentAnalysisAcknowledgement* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisAcknowledgement>(Arena*);
template<> ::content_analysis::sdk::ContentAnalysisCancelRequests* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisCancelRequests>(Arena*);
template<> ::content_analysis::sdk::ContentAnalysisRequest* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisRequest>(Arena*);
template<> ::content_analysis::sdk::ContentAnalysisRequest_PrintData* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisRequest_PrintData>(Arena*);
template<> ::content_analysis::sdk::ContentAnalysisResponse* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisResponse>(Arena*);
template<> ::content_analysis::sdk::ContentAnalysisResponse_Result* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisResponse_Result>(Arena*);
template<> ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule>(Arena*);
template<> ::content_analysis::sdk::ContentMetaData* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentMetaData>(Arena*);
template<> ::content_analysis::sdk::ContentMetaData_PrintMetadata* Arena::CreateMaybeMessage<::content_analysis::sdk::ContentMetaData_PrintMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace content_analysis {
namespace sdk {

enum ContentMetaData_PrintMetadata_PrinterType : int {
  ContentMetaData_PrintMetadata_PrinterType_UNKNOWN = 0,
  ContentMetaData_PrintMetadata_PrinterType_CLOUD = 1,
  ContentMetaData_PrintMetadata_PrinterType_LOCAL = 2
};
bool ContentMetaData_PrintMetadata_PrinterType_IsValid(int value);
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata_PrinterType_PrinterType_MIN = ContentMetaData_PrintMetadata_PrinterType_UNKNOWN;
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata_PrinterType_PrinterType_MAX = ContentMetaData_PrintMetadata_PrinterType_LOCAL;
constexpr int ContentMetaData_PrintMetadata_PrinterType_PrinterType_ARRAYSIZE = ContentMetaData_PrintMetadata_PrinterType_PrinterType_MAX + 1;

const std::string& ContentMetaData_PrintMetadata_PrinterType_Name(ContentMetaData_PrintMetadata_PrinterType value);
template<typename T>
inline const std::string& ContentMetaData_PrintMetadata_PrinterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentMetaData_PrintMetadata_PrinterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentMetaData_PrintMetadata_PrinterType_Name.");
  return ContentMetaData_PrintMetadata_PrinterType_Name(static_cast<ContentMetaData_PrintMetadata_PrinterType>(enum_t_value));
}
bool ContentMetaData_PrintMetadata_PrinterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentMetaData_PrintMetadata_PrinterType* value);
enum ClientDownloadRequest_ResourceType : int {
  ClientDownloadRequest_ResourceType_DOWNLOAD_URL = 0,
  ClientDownloadRequest_ResourceType_DOWNLOAD_REDIRECT = 1,
  ClientDownloadRequest_ResourceType_TAB_URL = 2,
  ClientDownloadRequest_ResourceType_TAB_REDIRECT = 3,
  ClientDownloadRequest_ResourceType_PPAPI_DOCUMENT = 4,
  ClientDownloadRequest_ResourceType_PPAPI_PLUGIN = 5
};
bool ClientDownloadRequest_ResourceType_IsValid(int value);
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest_ResourceType_ResourceType_MIN = ClientDownloadRequest_ResourceType_DOWNLOAD_URL;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest_ResourceType_ResourceType_MAX = ClientDownloadRequest_ResourceType_PPAPI_PLUGIN;
constexpr int ClientDownloadRequest_ResourceType_ResourceType_ARRAYSIZE = ClientDownloadRequest_ResourceType_ResourceType_MAX + 1;

const std::string& ClientDownloadRequest_ResourceType_Name(ClientDownloadRequest_ResourceType value);
template<typename T>
inline const std::string& ClientDownloadRequest_ResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientDownloadRequest_ResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientDownloadRequest_ResourceType_Name.");
  return ClientDownloadRequest_ResourceType_Name(static_cast<ClientDownloadRequest_ResourceType>(enum_t_value));
}
bool ClientDownloadRequest_ResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadRequest_ResourceType* value);
enum ContentAnalysisRequest_Reason : int {
  ContentAnalysisRequest_Reason_UNKNOWN = 0,
  ContentAnalysisRequest_Reason_CLIPBOARD_PASTE = 1,
  ContentAnalysisRequest_Reason_DRAG_AND_DROP = 2,
  ContentAnalysisRequest_Reason_FILE_PICKER_DIALOG = 3,
  ContentAnalysisRequest_Reason_PRINT_PREVIEW_PRINT = 4,
  ContentAnalysisRequest_Reason_SYSTEM_DIALOG_PRINT = 5,
  ContentAnalysisRequest_Reason_NORMAL_DOWNLOAD = 6,
  ContentAnalysisRequest_Reason_SAVE_AS_DOWNLOAD = 7
};
bool ContentAnalysisRequest_Reason_IsValid(int value);
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest_Reason_Reason_MIN = ContentAnalysisRequest_Reason_UNKNOWN;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest_Reason_Reason_MAX = ContentAnalysisRequest_Reason_SAVE_AS_DOWNLOAD;
constexpr int ContentAnalysisRequest_Reason_Reason_ARRAYSIZE = ContentAnalysisRequest_Reason_Reason_MAX + 1;

const std::string& ContentAnalysisRequest_Reason_Name(ContentAnalysisRequest_Reason value);
template<typename T>
inline const std::string& ContentAnalysisRequest_Reason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentAnalysisRequest_Reason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentAnalysisRequest_Reason_Name.");
  return ContentAnalysisRequest_Reason_Name(static_cast<ContentAnalysisRequest_Reason>(enum_t_value));
}
bool ContentAnalysisRequest_Reason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisRequest_Reason* value);
enum ContentAnalysisResponse_Result_TriggeredRule_Action : int {
  ContentAnalysisResponse_Result_TriggeredRule_Action_ACTION_UNSPECIFIED = 0,
  ContentAnalysisResponse_Result_TriggeredRule_Action_REPORT_ONLY = 1,
  ContentAnalysisResponse_Result_TriggeredRule_Action_WARN = 2,
  ContentAnalysisResponse_Result_TriggeredRule_Action_BLOCK = 3
};
bool ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(int value);
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MIN = ContentAnalysisResponse_Result_TriggeredRule_Action_ACTION_UNSPECIFIED;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MAX = ContentAnalysisResponse_Result_TriggeredRule_Action_BLOCK;
constexpr int ContentAnalysisResponse_Result_TriggeredRule_Action_Action_ARRAYSIZE = ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MAX + 1;

const std::string& ContentAnalysisResponse_Result_TriggeredRule_Action_Name(ContentAnalysisResponse_Result_TriggeredRule_Action value);
template<typename T>
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentAnalysisResponse_Result_TriggeredRule_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentAnalysisResponse_Result_TriggeredRule_Action_Name.");
  return ContentAnalysisResponse_Result_TriggeredRule_Action_Name(static_cast<ContentAnalysisResponse_Result_TriggeredRule_Action>(enum_t_value));
}
bool ContentAnalysisResponse_Result_TriggeredRule_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_TriggeredRule_Action* value);
enum ContentAnalysisResponse_Result_Status : int {
  ContentAnalysisResponse_Result_Status_STATUS_UNKNOWN = 0,
  ContentAnalysisResponse_Result_Status_SUCCESS = 1,
  ContentAnalysisResponse_Result_Status_FAILURE = 2
};
bool ContentAnalysisResponse_Result_Status_IsValid(int value);
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result_Status_Status_MIN = ContentAnalysisResponse_Result_Status_STATUS_UNKNOWN;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result_Status_Status_MAX = ContentAnalysisResponse_Result_Status_FAILURE;
constexpr int ContentAnalysisResponse_Result_Status_Status_ARRAYSIZE = ContentAnalysisResponse_Result_Status_Status_MAX + 1;

const std::string& ContentAnalysisResponse_Result_Status_Name(ContentAnalysisResponse_Result_Status value);
template<typename T>
inline const std::string& ContentAnalysisResponse_Result_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentAnalysisResponse_Result_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentAnalysisResponse_Result_Status_Name.");
  return ContentAnalysisResponse_Result_Status_Name(static_cast<ContentAnalysisResponse_Result_Status>(enum_t_value));
}
bool ContentAnalysisResponse_Result_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_Status* value);
enum ContentAnalysisAcknowledgement_Status : int {
  ContentAnalysisAcknowledgement_Status_SUCCESS = 1,
  ContentAnalysisAcknowledgement_Status_INVALID_RESPONSE = 2,
  ContentAnalysisAcknowledgement_Status_TOO_LATE = 3
};
bool ContentAnalysisAcknowledgement_Status_IsValid(int value);
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement_Status_Status_MIN = ContentAnalysisAcknowledgement_Status_SUCCESS;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement_Status_Status_MAX = ContentAnalysisAcknowledgement_Status_TOO_LATE;
constexpr int ContentAnalysisAcknowledgement_Status_Status_ARRAYSIZE = ContentAnalysisAcknowledgement_Status_Status_MAX + 1;

const std::string& ContentAnalysisAcknowledgement_Status_Name(ContentAnalysisAcknowledgement_Status value);
template<typename T>
inline const std::string& ContentAnalysisAcknowledgement_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentAnalysisAcknowledgement_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentAnalysisAcknowledgement_Status_Name.");
  return ContentAnalysisAcknowledgement_Status_Name(static_cast<ContentAnalysisAcknowledgement_Status>(enum_t_value));
}
bool ContentAnalysisAcknowledgement_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisAcknowledgement_Status* value);
enum ContentAnalysisAcknowledgement_FinalAction : int {
  ContentAnalysisAcknowledgement_FinalAction_ACTION_UNSPECIFIED = 0,
  ContentAnalysisAcknowledgement_FinalAction_ALLOW = 1,
  ContentAnalysisAcknowledgement_FinalAction_REPORT_ONLY = 2,
  ContentAnalysisAcknowledgement_FinalAction_WARN = 3,
  ContentAnalysisAcknowledgement_FinalAction_BLOCK = 4
};
bool ContentAnalysisAcknowledgement_FinalAction_IsValid(int value);
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement_FinalAction_FinalAction_MIN = ContentAnalysisAcknowledgement_FinalAction_ACTION_UNSPECIFIED;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement_FinalAction_FinalAction_MAX = ContentAnalysisAcknowledgement_FinalAction_BLOCK;
constexpr int ContentAnalysisAcknowledgement_FinalAction_FinalAction_ARRAYSIZE = ContentAnalysisAcknowledgement_FinalAction_FinalAction_MAX + 1;

const std::string& ContentAnalysisAcknowledgement_FinalAction_Name(ContentAnalysisAcknowledgement_FinalAction value);
template<typename T>
inline const std::string& ContentAnalysisAcknowledgement_FinalAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentAnalysisAcknowledgement_FinalAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentAnalysisAcknowledgement_FinalAction_Name.");
  return ContentAnalysisAcknowledgement_FinalAction_Name(static_cast<ContentAnalysisAcknowledgement_FinalAction>(enum_t_value));
}
bool ContentAnalysisAcknowledgement_FinalAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisAcknowledgement_FinalAction* value);
enum AnalysisConnector : int {
  ANALYSIS_CONNECTOR_UNSPECIFIED = 0,
  FILE_DOWNLOADED = 1,
  FILE_ATTACHED = 2,
  BULK_DATA_ENTRY = 3,
  PRINT = 4,
  FILE_TRANSFER = 5
};
bool AnalysisConnector_IsValid(int value);
constexpr AnalysisConnector AnalysisConnector_MIN = ANALYSIS_CONNECTOR_UNSPECIFIED;
constexpr AnalysisConnector AnalysisConnector_MAX = FILE_TRANSFER;
constexpr int AnalysisConnector_ARRAYSIZE = AnalysisConnector_MAX + 1;

const std::string& AnalysisConnector_Name(AnalysisConnector value);
template<typename T>
inline const std::string& AnalysisConnector_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AnalysisConnector>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AnalysisConnector_Name.");
  return AnalysisConnector_Name(static_cast<AnalysisConnector>(enum_t_value));
}
bool AnalysisConnector_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnalysisConnector* value);
// ===================================================================

class ContentMetaData_PrintMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentMetaData.PrintMetadata) */ {
 public:
  inline ContentMetaData_PrintMetadata() : ContentMetaData_PrintMetadata(nullptr) {}
  ~ContentMetaData_PrintMetadata() override;
  explicit PROTOBUF_CONSTEXPR ContentMetaData_PrintMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentMetaData_PrintMetadata(const ContentMetaData_PrintMetadata& from);
  ContentMetaData_PrintMetadata(ContentMetaData_PrintMetadata&& from) noexcept
    : ContentMetaData_PrintMetadata() {
    *this = ::std::move(from);
  }

  inline ContentMetaData_PrintMetadata& operator=(const ContentMetaData_PrintMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentMetaData_PrintMetadata& operator=(ContentMetaData_PrintMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentMetaData_PrintMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentMetaData_PrintMetadata* internal_default_instance() {
    return reinterpret_cast<const ContentMetaData_PrintMetadata*>(
               &_ContentMetaData_PrintMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ContentMetaData_PrintMetadata& a, ContentMetaData_PrintMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentMetaData_PrintMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentMetaData_PrintMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentMetaData_PrintMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentMetaData_PrintMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentMetaData_PrintMetadata& from);
  void MergeFrom(const ContentMetaData_PrintMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentMetaData_PrintMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentMetaData.PrintMetadata";
  }
  protected:
  explicit ContentMetaData_PrintMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ContentMetaData_PrintMetadata_PrinterType PrinterType;
  static constexpr PrinterType UNKNOWN =
    ContentMetaData_PrintMetadata_PrinterType_UNKNOWN;
  static constexpr PrinterType CLOUD =
    ContentMetaData_PrintMetadata_PrinterType_CLOUD;
  static constexpr PrinterType LOCAL =
    ContentMetaData_PrintMetadata_PrinterType_LOCAL;
  static inline bool PrinterType_IsValid(int value) {
    return ContentMetaData_PrintMetadata_PrinterType_IsValid(value);
  }
  static constexpr PrinterType PrinterType_MIN =
    ContentMetaData_PrintMetadata_PrinterType_PrinterType_MIN;
  static constexpr PrinterType PrinterType_MAX =
    ContentMetaData_PrintMetadata_PrinterType_PrinterType_MAX;
  static constexpr int PrinterType_ARRAYSIZE =
    ContentMetaData_PrintMetadata_PrinterType_PrinterType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PrinterType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PrinterType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PrinterType_Name.");
    return ContentMetaData_PrintMetadata_PrinterType_Name(enum_t_value);
  }
  static inline bool PrinterType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PrinterType* value) {
    return ContentMetaData_PrintMetadata_PrinterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPrinterNameFieldNumber = 1,
    kPrinterTypeFieldNumber = 2,
  };
  // optional string printer_name = 1;
  bool has_printer_name() const;
  private:
  bool _internal_has_printer_name() const;
  public:
  void clear_printer_name();
  const std::string& printer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_printer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_printer_name();
  PROTOBUF_NODISCARD std::string* release_printer_name();
  void set_allocated_printer_name(std::string* printer_name);
  private:
  const std::string& _internal_printer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_printer_name(const std::string& value);
  std::string* _internal_mutable_printer_name();
  public:

  // optional .content_analysis.sdk.ContentMetaData.PrintMetadata.PrinterType printer_type = 2;
  bool has_printer_type() const;
  private:
  bool _internal_has_printer_type() const;
  public:
  void clear_printer_type();
  ::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType printer_type() const;
  void set_printer_type(::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType value);
  private:
  ::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType _internal_printer_type() const;
  void _internal_set_printer_type(::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType value);
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentMetaData.PrintMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr printer_name_;
    int printer_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ContentMetaData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentMetaData) */ {
 public:
  inline ContentMetaData() : ContentMetaData(nullptr) {}
  ~ContentMetaData() override;
  explicit PROTOBUF_CONSTEXPR ContentMetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentMetaData(const ContentMetaData& from);
  ContentMetaData(ContentMetaData&& from) noexcept
    : ContentMetaData() {
    *this = ::std::move(from);
  }

  inline ContentMetaData& operator=(const ContentMetaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentMetaData& operator=(ContentMetaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentMetaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentMetaData* internal_default_instance() {
    return reinterpret_cast<const ContentMetaData*>(
               &_ContentMetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ContentMetaData& a, ContentMetaData& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentMetaData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentMetaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentMetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentMetaData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentMetaData& from);
  void MergeFrom(const ContentMetaData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentMetaData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentMetaData";
  }
  protected:
  explicit ContentMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ContentMetaData_PrintMetadata PrintMetadata;

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kFilenameFieldNumber = 2,
    kDigestFieldNumber = 3,
    kEmailFieldNumber = 5,
    kTabTitleFieldNumber = 9,
    kCsdFieldNumber = 4,
    kPrintMetadataFieldNumber = 11,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string filename = 2;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string digest = 3;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_NODISCARD std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // optional string email = 5;
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // optional string tab_title = 9;
  bool has_tab_title() const;
  private:
  bool _internal_has_tab_title() const;
  public:
  void clear_tab_title();
  const std::string& tab_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tab_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tab_title();
  PROTOBUF_NODISCARD std::string* release_tab_title();
  void set_allocated_tab_title(std::string* tab_title);
  private:
  const std::string& _internal_tab_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tab_title(const std::string& value);
  std::string* _internal_mutable_tab_title();
  public:

  // optional .content_analysis.sdk.ClientDownloadRequest csd = 4;
  bool has_csd() const;
  private:
  bool _internal_has_csd() const;
  public:
  void clear_csd();
  const ::content_analysis::sdk::ClientDownloadRequest& csd() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ClientDownloadRequest* release_csd();
  ::content_analysis::sdk::ClientDownloadRequest* mutable_csd();
  void set_allocated_csd(::content_analysis::sdk::ClientDownloadRequest* csd);
  private:
  const ::content_analysis::sdk::ClientDownloadRequest& _internal_csd() const;
  ::content_analysis::sdk::ClientDownloadRequest* _internal_mutable_csd();
  public:
  void unsafe_arena_set_allocated_csd(
      ::content_analysis::sdk::ClientDownloadRequest* csd);
  ::content_analysis::sdk::ClientDownloadRequest* unsafe_arena_release_csd();

  // optional .content_analysis.sdk.ContentMetaData.PrintMetadata print_metadata = 11;
  bool has_print_metadata() const;
  private:
  bool _internal_has_print_metadata() const;
  public:
  void clear_print_metadata();
  const ::content_analysis::sdk::ContentMetaData_PrintMetadata& print_metadata() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ContentMetaData_PrintMetadata* release_print_metadata();
  ::content_analysis::sdk::ContentMetaData_PrintMetadata* mutable_print_metadata();
  void set_allocated_print_metadata(::content_analysis::sdk::ContentMetaData_PrintMetadata* print_metadata);
  private:
  const ::content_analysis::sdk::ContentMetaData_PrintMetadata& _internal_print_metadata() const;
  ::content_analysis::sdk::ContentMetaData_PrintMetadata* _internal_mutable_print_metadata();
  public:
  void unsafe_arena_set_allocated_print_metadata(
      ::content_analysis::sdk::ContentMetaData_PrintMetadata* print_metadata);
  ::content_analysis::sdk::ContentMetaData_PrintMetadata* unsafe_arena_release_print_metadata();

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentMetaData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_title_;
    ::content_analysis::sdk::ClientDownloadRequest* csd_;
    ::content_analysis::sdk::ContentMetaData_PrintMetadata* print_metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ClientMetadata_Browser final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ClientMetadata.Browser) */ {
 public:
  inline ClientMetadata_Browser() : ClientMetadata_Browser(nullptr) {}
  ~ClientMetadata_Browser() override;
  explicit PROTOBUF_CONSTEXPR ClientMetadata_Browser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientMetadata_Browser(const ClientMetadata_Browser& from);
  ClientMetadata_Browser(ClientMetadata_Browser&& from) noexcept
    : ClientMetadata_Browser() {
    *this = ::std::move(from);
  }

  inline ClientMetadata_Browser& operator=(const ClientMetadata_Browser& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMetadata_Browser& operator=(ClientMetadata_Browser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientMetadata_Browser& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientMetadata_Browser* internal_default_instance() {
    return reinterpret_cast<const ClientMetadata_Browser*>(
               &_ClientMetadata_Browser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientMetadata_Browser& a, ClientMetadata_Browser& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMetadata_Browser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMetadata_Browser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMetadata_Browser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientMetadata_Browser>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientMetadata_Browser& from);
  void MergeFrom(const ClientMetadata_Browser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientMetadata_Browser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ClientMetadata.Browser";
  }
  protected:
  explicit ClientMetadata_Browser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachineUserFieldNumber = 4,
  };
  // optional string machine_user = 4;
  bool has_machine_user() const;
  private:
  bool _internal_has_machine_user() const;
  public:
  void clear_machine_user();
  const std::string& machine_user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_user();
  PROTOBUF_NODISCARD std::string* release_machine_user();
  void set_allocated_machine_user(std::string* machine_user);
  private:
  const std::string& _internal_machine_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_user(const std::string& value);
  std::string* _internal_mutable_machine_user();
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ClientMetadata.Browser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_user_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ClientMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ClientMetadata) */ {
 public:
  inline ClientMetadata() : ClientMetadata(nullptr) {}
  ~ClientMetadata() override;
  explicit PROTOBUF_CONSTEXPR ClientMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientMetadata(const ClientMetadata& from);
  ClientMetadata(ClientMetadata&& from) noexcept
    : ClientMetadata() {
    *this = ::std::move(from);
  }

  inline ClientMetadata& operator=(const ClientMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMetadata& operator=(ClientMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientMetadata* internal_default_instance() {
    return reinterpret_cast<const ClientMetadata*>(
               &_ClientMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientMetadata& a, ClientMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientMetadata& from);
  void MergeFrom(const ClientMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ClientMetadata";
  }
  protected:
  explicit ClientMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientMetadata_Browser Browser;

  // accessors -------------------------------------------------------

  enum : int {
    kBrowserFieldNumber = 1,
  };
  // optional .content_analysis.sdk.ClientMetadata.Browser browser = 1;
  bool has_browser() const;
  private:
  bool _internal_has_browser() const;
  public:
  void clear_browser();
  const ::content_analysis::sdk::ClientMetadata_Browser& browser() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ClientMetadata_Browser* release_browser();
  ::content_analysis::sdk::ClientMetadata_Browser* mutable_browser();
  void set_allocated_browser(::content_analysis::sdk::ClientMetadata_Browser* browser);
  private:
  const ::content_analysis::sdk::ClientMetadata_Browser& _internal_browser() const;
  ::content_analysis::sdk::ClientMetadata_Browser* _internal_mutable_browser();
  public:
  void unsafe_arena_set_allocated_browser(
      ::content_analysis::sdk::ClientMetadata_Browser* browser);
  ::content_analysis::sdk::ClientMetadata_Browser* unsafe_arena_release_browser();

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ClientMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::content_analysis::sdk::ClientMetadata_Browser* browser_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_Resource final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ClientDownloadRequest.Resource) */ {
 public:
  inline ClientDownloadRequest_Resource() : ClientDownloadRequest_Resource(nullptr) {}
  ~ClientDownloadRequest_Resource() override;
  explicit PROTOBUF_CONSTEXPR ClientDownloadRequest_Resource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientDownloadRequest_Resource(const ClientDownloadRequest_Resource& from);
  ClientDownloadRequest_Resource(ClientDownloadRequest_Resource&& from) noexcept
    : ClientDownloadRequest_Resource() {
    *this = ::std::move(from);
  }

  inline ClientDownloadRequest_Resource& operator=(const ClientDownloadRequest_Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientDownloadRequest_Resource& operator=(ClientDownloadRequest_Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientDownloadRequest_Resource& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientDownloadRequest_Resource* internal_default_instance() {
    return reinterpret_cast<const ClientDownloadRequest_Resource*>(
               &_ClientDownloadRequest_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClientDownloadRequest_Resource& a, ClientDownloadRequest_Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientDownloadRequest_Resource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientDownloadRequest_Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientDownloadRequest_Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientDownloadRequest_Resource>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientDownloadRequest_Resource& from);
  void MergeFrom(const ClientDownloadRequest_Resource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientDownloadRequest_Resource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ClientDownloadRequest.Resource";
  }
  protected:
  explicit ClientDownloadRequest_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // required string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // required .content_analysis.sdk.ClientDownloadRequest.ResourceType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::content_analysis::sdk::ClientDownloadRequest_ResourceType type() const;
  void set_type(::content_analysis::sdk::ClientDownloadRequest_ResourceType value);
  private:
  ::content_analysis::sdk::ClientDownloadRequest_ResourceType _internal_type() const;
  void _internal_set_type(::content_analysis::sdk::ClientDownloadRequest_ResourceType value);
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ClientDownloadRequest.Resource)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ClientDownloadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ClientDownloadRequest) */ {
 public:
  inline ClientDownloadRequest() : ClientDownloadRequest(nullptr) {}
  ~ClientDownloadRequest() override;
  explicit PROTOBUF_CONSTEXPR ClientDownloadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientDownloadRequest(const ClientDownloadRequest& from);
  ClientDownloadRequest(ClientDownloadRequest&& from) noexcept
    : ClientDownloadRequest() {
    *this = ::std::move(from);
  }

  inline ClientDownloadRequest& operator=(const ClientDownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientDownloadRequest& operator=(ClientDownloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientDownloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientDownloadRequest* internal_default_instance() {
    return reinterpret_cast<const ClientDownloadRequest*>(
               &_ClientDownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientDownloadRequest& a, ClientDownloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientDownloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientDownloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientDownloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientDownloadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientDownloadRequest& from);
  void MergeFrom(const ClientDownloadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientDownloadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ClientDownloadRequest";
  }
  protected:
  explicit ClientDownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientDownloadRequest_Resource Resource;

  typedef ClientDownloadRequest_ResourceType ResourceType;
  static constexpr ResourceType DOWNLOAD_URL =
    ClientDownloadRequest_ResourceType_DOWNLOAD_URL;
  static constexpr ResourceType DOWNLOAD_REDIRECT =
    ClientDownloadRequest_ResourceType_DOWNLOAD_REDIRECT;
  static constexpr ResourceType TAB_URL =
    ClientDownloadRequest_ResourceType_TAB_URL;
  static constexpr ResourceType TAB_REDIRECT =
    ClientDownloadRequest_ResourceType_TAB_REDIRECT;
  static constexpr ResourceType PPAPI_DOCUMENT =
    ClientDownloadRequest_ResourceType_PPAPI_DOCUMENT;
  static constexpr ResourceType PPAPI_PLUGIN =
    ClientDownloadRequest_ResourceType_PPAPI_PLUGIN;
  static inline bool ResourceType_IsValid(int value) {
    return ClientDownloadRequest_ResourceType_IsValid(value);
  }
  static constexpr ResourceType ResourceType_MIN =
    ClientDownloadRequest_ResourceType_ResourceType_MIN;
  static constexpr ResourceType ResourceType_MAX =
    ClientDownloadRequest_ResourceType_ResourceType_MAX;
  static constexpr int ResourceType_ARRAYSIZE =
    ClientDownloadRequest_ResourceType_ResourceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResourceType_Name.");
    return ClientDownloadRequest_ResourceType_Name(enum_t_value);
  }
  static inline bool ResourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResourceType* value) {
    return ClientDownloadRequest_ResourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 4,
  };
  // repeated .content_analysis.sdk.ClientDownloadRequest.Resource resources = 4;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::content_analysis::sdk::ClientDownloadRequest_Resource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ClientDownloadRequest_Resource >*
      mutable_resources();
  private:
  const ::content_analysis::sdk::ClientDownloadRequest_Resource& _internal_resources(int index) const;
  ::content_analysis::sdk::ClientDownloadRequest_Resource* _internal_add_resources();
  public:
  const ::content_analysis::sdk::ClientDownloadRequest_Resource& resources(int index) const;
  ::content_analysis::sdk::ClientDownloadRequest_Resource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ClientDownloadRequest_Resource >&
      resources() const;

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ClientDownloadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ClientDownloadRequest_Resource > resources_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisRequest_PrintData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentAnalysisRequest.PrintData) */ {
 public:
  inline ContentAnalysisRequest_PrintData() : ContentAnalysisRequest_PrintData(nullptr) {}
  ~ContentAnalysisRequest_PrintData() override;
  explicit PROTOBUF_CONSTEXPR ContentAnalysisRequest_PrintData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentAnalysisRequest_PrintData(const ContentAnalysisRequest_PrintData& from);
  ContentAnalysisRequest_PrintData(ContentAnalysisRequest_PrintData&& from) noexcept
    : ContentAnalysisRequest_PrintData() {
    *this = ::std::move(from);
  }

  inline ContentAnalysisRequest_PrintData& operator=(const ContentAnalysisRequest_PrintData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentAnalysisRequest_PrintData& operator=(ContentAnalysisRequest_PrintData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentAnalysisRequest_PrintData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentAnalysisRequest_PrintData* internal_default_instance() {
    return reinterpret_cast<const ContentAnalysisRequest_PrintData*>(
               &_ContentAnalysisRequest_PrintData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ContentAnalysisRequest_PrintData& a, ContentAnalysisRequest_PrintData& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentAnalysisRequest_PrintData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentAnalysisRequest_PrintData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentAnalysisRequest_PrintData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentAnalysisRequest_PrintData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentAnalysisRequest_PrintData& from);
  void MergeFrom(const ContentAnalysisRequest_PrintData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentAnalysisRequest_PrintData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentAnalysisRequest.PrintData";
  }
  protected:
  explicit ContentAnalysisRequest_PrintData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // optional int64 handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  int64_t handle() const;
  void set_handle(int64_t value);
  private:
  int64_t _internal_handle() const;
  void _internal_set_handle(int64_t value);
  public:

  // optional int64 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentAnalysisRequest.PrintData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t handle_;
    int64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentAnalysisRequest) */ {
 public:
  inline ContentAnalysisRequest() : ContentAnalysisRequest(nullptr) {}
  ~ContentAnalysisRequest() override;
  explicit PROTOBUF_CONSTEXPR ContentAnalysisRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentAnalysisRequest(const ContentAnalysisRequest& from);
  ContentAnalysisRequest(ContentAnalysisRequest&& from) noexcept
    : ContentAnalysisRequest() {
    *this = ::std::move(from);
  }

  inline ContentAnalysisRequest& operator=(const ContentAnalysisRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentAnalysisRequest& operator=(ContentAnalysisRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentAnalysisRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ContentDataCase {
    kTextContent = 13,
    kFilePath = 14,
    kPrintData = 18,
    CONTENT_DATA_NOT_SET = 0,
  };

  static inline const ContentAnalysisRequest* internal_default_instance() {
    return reinterpret_cast<const ContentAnalysisRequest*>(
               &_ContentAnalysisRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ContentAnalysisRequest& a, ContentAnalysisRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentAnalysisRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentAnalysisRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentAnalysisRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentAnalysisRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentAnalysisRequest& from);
  void MergeFrom(const ContentAnalysisRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentAnalysisRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentAnalysisRequest";
  }
  protected:
  explicit ContentAnalysisRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ContentAnalysisRequest_PrintData PrintData;

  typedef ContentAnalysisRequest_Reason Reason;
  static constexpr Reason UNKNOWN =
    ContentAnalysisRequest_Reason_UNKNOWN;
  static constexpr Reason CLIPBOARD_PASTE =
    ContentAnalysisRequest_Reason_CLIPBOARD_PASTE;
  static constexpr Reason DRAG_AND_DROP =
    ContentAnalysisRequest_Reason_DRAG_AND_DROP;
  static constexpr Reason FILE_PICKER_DIALOG =
    ContentAnalysisRequest_Reason_FILE_PICKER_DIALOG;
  static constexpr Reason PRINT_PREVIEW_PRINT =
    ContentAnalysisRequest_Reason_PRINT_PREVIEW_PRINT;
  static constexpr Reason SYSTEM_DIALOG_PRINT =
    ContentAnalysisRequest_Reason_SYSTEM_DIALOG_PRINT;
  static constexpr Reason NORMAL_DOWNLOAD =
    ContentAnalysisRequest_Reason_NORMAL_DOWNLOAD;
  static constexpr Reason SAVE_AS_DOWNLOAD =
    ContentAnalysisRequest_Reason_SAVE_AS_DOWNLOAD;
  static inline bool Reason_IsValid(int value) {
    return ContentAnalysisRequest_Reason_IsValid(value);
  }
  static constexpr Reason Reason_MIN =
    ContentAnalysisRequest_Reason_Reason_MIN;
  static constexpr Reason Reason_MAX =
    ContentAnalysisRequest_Reason_Reason_MAX;
  static constexpr int Reason_ARRAYSIZE =
    ContentAnalysisRequest_Reason_Reason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Reason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Reason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Reason_Name.");
    return ContentAnalysisRequest_Reason_Name(enum_t_value);
  }
  static inline bool Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Reason* value) {
    return ContentAnalysisRequest_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 11,
    kRequestTokenFieldNumber = 5,
    kUserActionIdFieldNumber = 16,
    kRequestDataFieldNumber = 10,
    kClientMetadataFieldNumber = 12,
    kAnalysisConnectorFieldNumber = 9,
    kReasonFieldNumber = 19,
    kExpiresAtFieldNumber = 15,
    kUserActionRequestsCountFieldNumber = 17,
    kTextContentFieldNumber = 13,
    kFilePathFieldNumber = 14,
    kPrintDataFieldNumber = 18,
  };
  // repeated string tags = 11;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // optional string request_token = 5;
  bool has_request_token() const;
  private:
  bool _internal_has_request_token() const;
  public:
  void clear_request_token();
  const std::string& request_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_token();
  PROTOBUF_NODISCARD std::string* release_request_token();
  void set_allocated_request_token(std::string* request_token);
  private:
  const std::string& _internal_request_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_token(const std::string& value);
  std::string* _internal_mutable_request_token();
  public:

  // optional string user_action_id = 16;
  bool has_user_action_id() const;
  private:
  bool _internal_has_user_action_id() const;
  public:
  void clear_user_action_id();
  const std::string& user_action_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_action_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_action_id();
  PROTOBUF_NODISCARD std::string* release_user_action_id();
  void set_allocated_user_action_id(std::string* user_action_id);
  private:
  const std::string& _internal_user_action_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_action_id(const std::string& value);
  std::string* _internal_mutable_user_action_id();
  public:

  // optional .content_analysis.sdk.ContentMetaData request_data = 10;
  bool has_request_data() const;
  private:
  bool _internal_has_request_data() const;
  public:
  void clear_request_data();
  const ::content_analysis::sdk::ContentMetaData& request_data() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ContentMetaData* release_request_data();
  ::content_analysis::sdk::ContentMetaData* mutable_request_data();
  void set_allocated_request_data(::content_analysis::sdk::ContentMetaData* request_data);
  private:
  const ::content_analysis::sdk::ContentMetaData& _internal_request_data() const;
  ::content_analysis::sdk::ContentMetaData* _internal_mutable_request_data();
  public:
  void unsafe_arena_set_allocated_request_data(
      ::content_analysis::sdk::ContentMetaData* request_data);
  ::content_analysis::sdk::ContentMetaData* unsafe_arena_release_request_data();

  // optional .content_analysis.sdk.ClientMetadata client_metadata = 12;
  bool has_client_metadata() const;
  private:
  bool _internal_has_client_metadata() const;
  public:
  void clear_client_metadata();
  const ::content_analysis::sdk::ClientMetadata& client_metadata() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ClientMetadata* release_client_metadata();
  ::content_analysis::sdk::ClientMetadata* mutable_client_metadata();
  void set_allocated_client_metadata(::content_analysis::sdk::ClientMetadata* client_metadata);
  private:
  const ::content_analysis::sdk::ClientMetadata& _internal_client_metadata() const;
  ::content_analysis::sdk::ClientMetadata* _internal_mutable_client_metadata();
  public:
  void unsafe_arena_set_allocated_client_metadata(
      ::content_analysis::sdk::ClientMetadata* client_metadata);
  ::content_analysis::sdk::ClientMetadata* unsafe_arena_release_client_metadata();

  // optional .content_analysis.sdk.AnalysisConnector analysis_connector = 9;
  bool has_analysis_connector() const;
  private:
  bool _internal_has_analysis_connector() const;
  public:
  void clear_analysis_connector();
  ::content_analysis::sdk::AnalysisConnector analysis_connector() const;
  void set_analysis_connector(::content_analysis::sdk::AnalysisConnector value);
  private:
  ::content_analysis::sdk::AnalysisConnector _internal_analysis_connector() const;
  void _internal_set_analysis_connector(::content_analysis::sdk::AnalysisConnector value);
  public:

  // optional .content_analysis.sdk.ContentAnalysisRequest.Reason reason = 19;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  ::content_analysis::sdk::ContentAnalysisRequest_Reason reason() const;
  void set_reason(::content_analysis::sdk::ContentAnalysisRequest_Reason value);
  private:
  ::content_analysis::sdk::ContentAnalysisRequest_Reason _internal_reason() const;
  void _internal_set_reason(::content_analysis::sdk::ContentAnalysisRequest_Reason value);
  public:

  // optional int64 expires_at = 15;
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  int64_t expires_at() const;
  void set_expires_at(int64_t value);
  private:
  int64_t _internal_expires_at() const;
  void _internal_set_expires_at(int64_t value);
  public:

  // optional int64 user_action_requests_count = 17;
  bool has_user_action_requests_count() const;
  private:
  bool _internal_has_user_action_requests_count() const;
  public:
  void clear_user_action_requests_count();
  int64_t user_action_requests_count() const;
  void set_user_action_requests_count(int64_t value);
  private:
  int64_t _internal_user_action_requests_count() const;
  void _internal_set_user_action_requests_count(int64_t value);
  public:

  // string text_content = 13;
  bool has_text_content() const;
  private:
  bool _internal_has_text_content() const;
  public:
  void clear_text_content();
  const std::string& text_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_content();
  PROTOBUF_NODISCARD std::string* release_text_content();
  void set_allocated_text_content(std::string* text_content);
  private:
  const std::string& _internal_text_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_content(const std::string& value);
  std::string* _internal_mutable_text_content();
  public:

  // string file_path = 14;
  bool has_file_path() const;
  private:
  bool _internal_has_file_path() const;
  public:
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // .content_analysis.sdk.ContentAnalysisRequest.PrintData print_data = 18;
  bool has_print_data() const;
  private:
  bool _internal_has_print_data() const;
  public:
  void clear_print_data();
  const ::content_analysis::sdk::ContentAnalysisRequest_PrintData& print_data() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ContentAnalysisRequest_PrintData* release_print_data();
  ::content_analysis::sdk::ContentAnalysisRequest_PrintData* mutable_print_data();
  void set_allocated_print_data(::content_analysis::sdk::ContentAnalysisRequest_PrintData* print_data);
  private:
  const ::content_analysis::sdk::ContentAnalysisRequest_PrintData& _internal_print_data() const;
  ::content_analysis::sdk::ContentAnalysisRequest_PrintData* _internal_mutable_print_data();
  public:
  void unsafe_arena_set_allocated_print_data(
      ::content_analysis::sdk::ContentAnalysisRequest_PrintData* print_data);
  ::content_analysis::sdk::ContentAnalysisRequest_PrintData* unsafe_arena_release_print_data();

  void clear_content_data();
  ContentDataCase content_data_case() const;
  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentAnalysisRequest)
 private:
  class _Internal;
  void set_has_text_content();
  void set_has_file_path();
  void set_has_print_data();

  inline bool has_content_data() const;
  inline void clear_has_content_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_action_id_;
    ::content_analysis::sdk::ContentMetaData* request_data_;
    ::content_analysis::sdk::ClientMetadata* client_metadata_;
    int analysis_connector_;
    int reason_;
    int64_t expires_at_;
    int64_t user_action_requests_count_;
    union ContentDataUnion {
      constexpr ContentDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_content_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
      ::content_analysis::sdk::ContentAnalysisRequest_PrintData* print_data_;
    } content_data_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse_Result_TriggeredRule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule) */ {
 public:
  inline ContentAnalysisResponse_Result_TriggeredRule() : ContentAnalysisResponse_Result_TriggeredRule(nullptr) {}
  ~ContentAnalysisResponse_Result_TriggeredRule() override;
  explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentAnalysisResponse_Result_TriggeredRule(const ContentAnalysisResponse_Result_TriggeredRule& from);
  ContentAnalysisResponse_Result_TriggeredRule(ContentAnalysisResponse_Result_TriggeredRule&& from) noexcept
    : ContentAnalysisResponse_Result_TriggeredRule() {
    *this = ::std::move(from);
  }

  inline ContentAnalysisResponse_Result_TriggeredRule& operator=(const ContentAnalysisResponse_Result_TriggeredRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentAnalysisResponse_Result_TriggeredRule& operator=(ContentAnalysisResponse_Result_TriggeredRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentAnalysisResponse_Result_TriggeredRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentAnalysisResponse_Result_TriggeredRule* internal_default_instance() {
    return reinterpret_cast<const ContentAnalysisResponse_Result_TriggeredRule*>(
               &_ContentAnalysisResponse_Result_TriggeredRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ContentAnalysisResponse_Result_TriggeredRule& a, ContentAnalysisResponse_Result_TriggeredRule& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentAnalysisResponse_Result_TriggeredRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentAnalysisResponse_Result_TriggeredRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentAnalysisResponse_Result_TriggeredRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentAnalysisResponse_Result_TriggeredRule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentAnalysisResponse_Result_TriggeredRule& from);
  void MergeFrom(const ContentAnalysisResponse_Result_TriggeredRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentAnalysisResponse_Result_TriggeredRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule";
  }
  protected:
  explicit ContentAnalysisResponse_Result_TriggeredRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ContentAnalysisResponse_Result_TriggeredRule_Action Action;
  static constexpr Action ACTION_UNSPECIFIED =
    ContentAnalysisResponse_Result_TriggeredRule_Action_ACTION_UNSPECIFIED;
  static constexpr Action REPORT_ONLY =
    ContentAnalysisResponse_Result_TriggeredRule_Action_REPORT_ONLY;
  static constexpr Action WARN =
    ContentAnalysisResponse_Result_TriggeredRule_Action_WARN;
  static constexpr Action BLOCK =
    ContentAnalysisResponse_Result_TriggeredRule_Action_BLOCK;
  static inline bool Action_IsValid(int value) {
    return ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MIN;
  static constexpr Action Action_MAX =
    ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    ContentAnalysisResponse_Result_TriggeredRule_Action_Action_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return ContentAnalysisResponse_Result_TriggeredRule_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return ContentAnalysisResponse_Result_TriggeredRule_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRuleNameFieldNumber = 2,
    kRuleIdFieldNumber = 3,
    kActionFieldNumber = 1,
  };
  // optional string rule_name = 2;
  bool has_rule_name() const;
  private:
  bool _internal_has_rule_name() const;
  public:
  void clear_rule_name();
  const std::string& rule_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rule_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rule_name();
  PROTOBUF_NODISCARD std::string* release_rule_name();
  void set_allocated_rule_name(std::string* rule_name);
  private:
  const std::string& _internal_rule_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_name(const std::string& value);
  std::string* _internal_mutable_rule_name();
  public:

  // optional string rule_id = 3;
  bool has_rule_id() const;
  private:
  bool _internal_has_rule_id() const;
  public:
  void clear_rule_id();
  const std::string& rule_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rule_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rule_id();
  PROTOBUF_NODISCARD std::string* release_rule_id();
  void set_allocated_rule_id(std::string* rule_id);
  private:
  const std::string& _internal_rule_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_id(const std::string& value);
  std::string* _internal_mutable_rule_id();
  public:

  // optional .content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action action() const;
  void set_action(::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action value);
  private:
  ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action _internal_action() const;
  void _internal_set_action(::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action value);
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rule_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rule_id_;
    int action_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentAnalysisResponse.Result) */ {
 public:
  inline ContentAnalysisResponse_Result() : ContentAnalysisResponse_Result(nullptr) {}
  ~ContentAnalysisResponse_Result() override;
  explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentAnalysisResponse_Result(const ContentAnalysisResponse_Result& from);
  ContentAnalysisResponse_Result(ContentAnalysisResponse_Result&& from) noexcept
    : ContentAnalysisResponse_Result() {
    *this = ::std::move(from);
  }

  inline ContentAnalysisResponse_Result& operator=(const ContentAnalysisResponse_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentAnalysisResponse_Result& operator=(ContentAnalysisResponse_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentAnalysisResponse_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentAnalysisResponse_Result* internal_default_instance() {
    return reinterpret_cast<const ContentAnalysisResponse_Result*>(
               &_ContentAnalysisResponse_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ContentAnalysisResponse_Result& a, ContentAnalysisResponse_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentAnalysisResponse_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentAnalysisResponse_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentAnalysisResponse_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentAnalysisResponse_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentAnalysisResponse_Result& from);
  void MergeFrom(const ContentAnalysisResponse_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentAnalysisResponse_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentAnalysisResponse.Result";
  }
  protected:
  explicit ContentAnalysisResponse_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ContentAnalysisResponse_Result_TriggeredRule TriggeredRule;

  typedef ContentAnalysisResponse_Result_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ContentAnalysisResponse_Result_Status_STATUS_UNKNOWN;
  static constexpr Status SUCCESS =
    ContentAnalysisResponse_Result_Status_SUCCESS;
  static constexpr Status FAILURE =
    ContentAnalysisResponse_Result_Status_FAILURE;
  static inline bool Status_IsValid(int value) {
    return ContentAnalysisResponse_Result_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ContentAnalysisResponse_Result_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ContentAnalysisResponse_Result_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ContentAnalysisResponse_Result_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ContentAnalysisResponse_Result_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ContentAnalysisResponse_Result_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTriggeredRulesFieldNumber = 3,
    kTagFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
  int triggered_rules_size() const;
  private:
  int _internal_triggered_rules_size() const;
  public:
  void clear_triggered_rules();
  ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule* mutable_triggered_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule >*
      mutable_triggered_rules();
  private:
  const ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule& _internal_triggered_rules(int index) const;
  ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule* _internal_add_triggered_rules();
  public:
  const ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule& triggered_rules(int index) const;
  ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule* add_triggered_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule >&
      triggered_rules() const;

  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .content_analysis.sdk.ContentAnalysisResponse.Result.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::content_analysis::sdk::ContentAnalysisResponse_Result_Status status() const;
  void set_status(::content_analysis::sdk::ContentAnalysisResponse_Result_Status value);
  private:
  ::content_analysis::sdk::ContentAnalysisResponse_Result_Status _internal_status() const;
  void _internal_set_status(::content_analysis::sdk::ContentAnalysisResponse_Result_Status value);
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentAnalysisResponse.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule > triggered_rules_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentAnalysisResponse) */ {
 public:
  inline ContentAnalysisResponse() : ContentAnalysisResponse(nullptr) {}
  ~ContentAnalysisResponse() override;
  explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentAnalysisResponse(const ContentAnalysisResponse& from);
  ContentAnalysisResponse(ContentAnalysisResponse&& from) noexcept
    : ContentAnalysisResponse() {
    *this = ::std::move(from);
  }

  inline ContentAnalysisResponse& operator=(const ContentAnalysisResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentAnalysisResponse& operator=(ContentAnalysisResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentAnalysisResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentAnalysisResponse* internal_default_instance() {
    return reinterpret_cast<const ContentAnalysisResponse*>(
               &_ContentAnalysisResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ContentAnalysisResponse& a, ContentAnalysisResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentAnalysisResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentAnalysisResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentAnalysisResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentAnalysisResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentAnalysisResponse& from);
  void MergeFrom(const ContentAnalysisResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentAnalysisResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentAnalysisResponse";
  }
  protected:
  explicit ContentAnalysisResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ContentAnalysisResponse_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 4,
    kRequestTokenFieldNumber = 1,
  };
  // repeated .content_analysis.sdk.ContentAnalysisResponse.Result results = 4;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::content_analysis::sdk::ContentAnalysisResponse_Result* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result >*
      mutable_results();
  private:
  const ::content_analysis::sdk::ContentAnalysisResponse_Result& _internal_results(int index) const;
  ::content_analysis::sdk::ContentAnalysisResponse_Result* _internal_add_results();
  public:
  const ::content_analysis::sdk::ContentAnalysisResponse_Result& results(int index) const;
  ::content_analysis::sdk::ContentAnalysisResponse_Result* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result >&
      results() const;

  // optional string request_token = 1;
  bool has_request_token() const;
  private:
  bool _internal_has_request_token() const;
  public:
  void clear_request_token();
  const std::string& request_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_token();
  PROTOBUF_NODISCARD std::string* release_request_token();
  void set_allocated_request_token(std::string* request_token);
  private:
  const std::string& _internal_request_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_token(const std::string& value);
  std::string* _internal_mutable_request_token();
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentAnalysisResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_token_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisAcknowledgement final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentAnalysisAcknowledgement) */ {
 public:
  inline ContentAnalysisAcknowledgement() : ContentAnalysisAcknowledgement(nullptr) {}
  ~ContentAnalysisAcknowledgement() override;
  explicit PROTOBUF_CONSTEXPR ContentAnalysisAcknowledgement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentAnalysisAcknowledgement(const ContentAnalysisAcknowledgement& from);
  ContentAnalysisAcknowledgement(ContentAnalysisAcknowledgement&& from) noexcept
    : ContentAnalysisAcknowledgement() {
    *this = ::std::move(from);
  }

  inline ContentAnalysisAcknowledgement& operator=(const ContentAnalysisAcknowledgement& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentAnalysisAcknowledgement& operator=(ContentAnalysisAcknowledgement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentAnalysisAcknowledgement& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentAnalysisAcknowledgement* internal_default_instance() {
    return reinterpret_cast<const ContentAnalysisAcknowledgement*>(
               &_ContentAnalysisAcknowledgement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ContentAnalysisAcknowledgement& a, ContentAnalysisAcknowledgement& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentAnalysisAcknowledgement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentAnalysisAcknowledgement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentAnalysisAcknowledgement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentAnalysisAcknowledgement>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentAnalysisAcknowledgement& from);
  void MergeFrom(const ContentAnalysisAcknowledgement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentAnalysisAcknowledgement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentAnalysisAcknowledgement";
  }
  protected:
  explicit ContentAnalysisAcknowledgement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ContentAnalysisAcknowledgement_Status Status;
  static constexpr Status SUCCESS =
    ContentAnalysisAcknowledgement_Status_SUCCESS;
  static constexpr Status INVALID_RESPONSE =
    ContentAnalysisAcknowledgement_Status_INVALID_RESPONSE;
  static constexpr Status TOO_LATE =
    ContentAnalysisAcknowledgement_Status_TOO_LATE;
  static inline bool Status_IsValid(int value) {
    return ContentAnalysisAcknowledgement_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ContentAnalysisAcknowledgement_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ContentAnalysisAcknowledgement_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ContentAnalysisAcknowledgement_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ContentAnalysisAcknowledgement_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ContentAnalysisAcknowledgement_Status_Parse(name, value);
  }

  typedef ContentAnalysisAcknowledgement_FinalAction FinalAction;
  static constexpr FinalAction ACTION_UNSPECIFIED =
    ContentAnalysisAcknowledgement_FinalAction_ACTION_UNSPECIFIED;
  static constexpr FinalAction ALLOW =
    ContentAnalysisAcknowledgement_FinalAction_ALLOW;
  static constexpr FinalAction REPORT_ONLY =
    ContentAnalysisAcknowledgement_FinalAction_REPORT_ONLY;
  static constexpr FinalAction WARN =
    ContentAnalysisAcknowledgement_FinalAction_WARN;
  static constexpr FinalAction BLOCK =
    ContentAnalysisAcknowledgement_FinalAction_BLOCK;
  static inline bool FinalAction_IsValid(int value) {
    return ContentAnalysisAcknowledgement_FinalAction_IsValid(value);
  }
  static constexpr FinalAction FinalAction_MIN =
    ContentAnalysisAcknowledgement_FinalAction_FinalAction_MIN;
  static constexpr FinalAction FinalAction_MAX =
    ContentAnalysisAcknowledgement_FinalAction_FinalAction_MAX;
  static constexpr int FinalAction_ARRAYSIZE =
    ContentAnalysisAcknowledgement_FinalAction_FinalAction_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FinalAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FinalAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FinalAction_Name.");
    return ContentAnalysisAcknowledgement_FinalAction_Name(enum_t_value);
  }
  static inline bool FinalAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FinalAction* value) {
    return ContentAnalysisAcknowledgement_FinalAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequestTokenFieldNumber = 1,
    kFinalActionFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // optional string request_token = 1;
  bool has_request_token() const;
  private:
  bool _internal_has_request_token() const;
  public:
  void clear_request_token();
  const std::string& request_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_token();
  PROTOBUF_NODISCARD std::string* release_request_token();
  void set_allocated_request_token(std::string* request_token);
  private:
  const std::string& _internal_request_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_token(const std::string& value);
  std::string* _internal_mutable_request_token();
  public:

  // optional .content_analysis.sdk.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
  bool has_final_action() const;
  private:
  bool _internal_has_final_action() const;
  public:
  void clear_final_action();
  ::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction final_action() const;
  void set_final_action(::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction value);
  private:
  ::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction _internal_final_action() const;
  void _internal_set_final_action(::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction value);
  public:

  // optional .content_analysis.sdk.ContentAnalysisAcknowledgement.Status status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::content_analysis::sdk::ContentAnalysisAcknowledgement_Status status() const;
  void set_status(::content_analysis::sdk::ContentAnalysisAcknowledgement_Status value);
  private:
  ::content_analysis::sdk::ContentAnalysisAcknowledgement_Status _internal_status() const;
  void _internal_set_status(::content_analysis::sdk::ContentAnalysisAcknowledgement_Status value);
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentAnalysisAcknowledgement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_token_;
    int final_action_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisCancelRequests final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ContentAnalysisCancelRequests) */ {
 public:
  inline ContentAnalysisCancelRequests() : ContentAnalysisCancelRequests(nullptr) {}
  ~ContentAnalysisCancelRequests() override;
  explicit PROTOBUF_CONSTEXPR ContentAnalysisCancelRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentAnalysisCancelRequests(const ContentAnalysisCancelRequests& from);
  ContentAnalysisCancelRequests(ContentAnalysisCancelRequests&& from) noexcept
    : ContentAnalysisCancelRequests() {
    *this = ::std::move(from);
  }

  inline ContentAnalysisCancelRequests& operator=(const ContentAnalysisCancelRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentAnalysisCancelRequests& operator=(ContentAnalysisCancelRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContentAnalysisCancelRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentAnalysisCancelRequests* internal_default_instance() {
    return reinterpret_cast<const ContentAnalysisCancelRequests*>(
               &_ContentAnalysisCancelRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ContentAnalysisCancelRequests& a, ContentAnalysisCancelRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(ContentAnalysisCancelRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentAnalysisCancelRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentAnalysisCancelRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentAnalysisCancelRequests>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentAnalysisCancelRequests& from);
  void MergeFrom(const ContentAnalysisCancelRequests& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentAnalysisCancelRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ContentAnalysisCancelRequests";
  }
  protected:
  explicit ContentAnalysisCancelRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserActionIdFieldNumber = 1,
  };
  // optional string user_action_id = 1;
  bool has_user_action_id() const;
  private:
  bool _internal_has_user_action_id() const;
  public:
  void clear_user_action_id();
  const std::string& user_action_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_action_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_action_id();
  PROTOBUF_NODISCARD std::string* release_user_action_id();
  void set_allocated_user_action_id(std::string* user_action_id);
  private:
  const std::string& _internal_user_action_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_action_id(const std::string& value);
  std::string* _internal_mutable_user_action_id();
  public:

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ContentAnalysisCancelRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_action_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class ChromeToAgent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.ChromeToAgent) */ {
 public:
  inline ChromeToAgent() : ChromeToAgent(nullptr) {}
  ~ChromeToAgent() override;
  explicit PROTOBUF_CONSTEXPR ChromeToAgent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeToAgent(const ChromeToAgent& from);
  ChromeToAgent(ChromeToAgent&& from) noexcept
    : ChromeToAgent() {
    *this = ::std::move(from);
  }

  inline ChromeToAgent& operator=(const ChromeToAgent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeToAgent& operator=(ChromeToAgent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeToAgent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeToAgent* internal_default_instance() {
    return reinterpret_cast<const ChromeToAgent*>(
               &_ChromeToAgent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChromeToAgent& a, ChromeToAgent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChromeToAgent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeToAgent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeToAgent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeToAgent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeToAgent& from);
  void MergeFrom(const ChromeToAgent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeToAgent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.ChromeToAgent";
  }
  protected:
  explicit ChromeToAgent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
    kAckFieldNumber = 2,
    kCancelFieldNumber = 3,
  };
  // optional .content_analysis.sdk.ContentAnalysisRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::content_analysis::sdk::ContentAnalysisRequest& request() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ContentAnalysisRequest* release_request();
  ::content_analysis::sdk::ContentAnalysisRequest* mutable_request();
  void set_allocated_request(::content_analysis::sdk::ContentAnalysisRequest* request);
  private:
  const ::content_analysis::sdk::ContentAnalysisRequest& _internal_request() const;
  ::content_analysis::sdk::ContentAnalysisRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::content_analysis::sdk::ContentAnalysisRequest* request);
  ::content_analysis::sdk::ContentAnalysisRequest* unsafe_arena_release_request();

  // optional .content_analysis.sdk.ContentAnalysisAcknowledgement ack = 2;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::content_analysis::sdk::ContentAnalysisAcknowledgement& ack() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ContentAnalysisAcknowledgement* release_ack();
  ::content_analysis::sdk::ContentAnalysisAcknowledgement* mutable_ack();
  void set_allocated_ack(::content_analysis::sdk::ContentAnalysisAcknowledgement* ack);
  private:
  const ::content_analysis::sdk::ContentAnalysisAcknowledgement& _internal_ack() const;
  ::content_analysis::sdk::ContentAnalysisAcknowledgement* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::content_analysis::sdk::ContentAnalysisAcknowledgement* ack);
  ::content_analysis::sdk::ContentAnalysisAcknowledgement* unsafe_arena_release_ack();

  // optional .content_analysis.sdk.ContentAnalysisCancelRequests cancel = 3;
  bool has_cancel() const;
  private:
  bool _internal_has_cancel() const;
  public:
  void clear_cancel();
  const ::content_analysis::sdk::ContentAnalysisCancelRequests& cancel() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ContentAnalysisCancelRequests* release_cancel();
  ::content_analysis::sdk::ContentAnalysisCancelRequests* mutable_cancel();
  void set_allocated_cancel(::content_analysis::sdk::ContentAnalysisCancelRequests* cancel);
  private:
  const ::content_analysis::sdk::ContentAnalysisCancelRequests& _internal_cancel() const;
  ::content_analysis::sdk::ContentAnalysisCancelRequests* _internal_mutable_cancel();
  public:
  void unsafe_arena_set_allocated_cancel(
      ::content_analysis::sdk::ContentAnalysisCancelRequests* cancel);
  ::content_analysis::sdk::ContentAnalysisCancelRequests* unsafe_arena_release_cancel();

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.ChromeToAgent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::content_analysis::sdk::ContentAnalysisRequest* request_;
    ::content_analysis::sdk::ContentAnalysisAcknowledgement* ack_;
    ::content_analysis::sdk::ContentAnalysisCancelRequests* cancel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// -------------------------------------------------------------------

class AgentToChrome final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content_analysis.sdk.AgentToChrome) */ {
 public:
  inline AgentToChrome() : AgentToChrome(nullptr) {}
  ~AgentToChrome() override;
  explicit PROTOBUF_CONSTEXPR AgentToChrome(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentToChrome(const AgentToChrome& from);
  AgentToChrome(AgentToChrome&& from) noexcept
    : AgentToChrome() {
    *this = ::std::move(from);
  }

  inline AgentToChrome& operator=(const AgentToChrome& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentToChrome& operator=(AgentToChrome&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AgentToChrome& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentToChrome* internal_default_instance() {
    return reinterpret_cast<const AgentToChrome*>(
               &_AgentToChrome_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AgentToChrome& a, AgentToChrome& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentToChrome* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentToChrome* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentToChrome* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentToChrome>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AgentToChrome& from);
  void MergeFrom(const AgentToChrome& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AgentToChrome* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content_analysis.sdk.AgentToChrome";
  }
  protected:
  explicit AgentToChrome(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .content_analysis.sdk.ContentAnalysisResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::content_analysis::sdk::ContentAnalysisResponse& response() const;
  PROTOBUF_NODISCARD ::content_analysis::sdk::ContentAnalysisResponse* release_response();
  ::content_analysis::sdk::ContentAnalysisResponse* mutable_response();
  void set_allocated_response(::content_analysis::sdk::ContentAnalysisResponse* response);
  private:
  const ::content_analysis::sdk::ContentAnalysisResponse& _internal_response() const;
  ::content_analysis::sdk::ContentAnalysisResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::content_analysis::sdk::ContentAnalysisResponse* response);
  ::content_analysis::sdk::ContentAnalysisResponse* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:content_analysis.sdk.AgentToChrome)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::content_analysis::sdk::ContentAnalysisResponse* response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_content_5fanalysis_2fsdk_2fanalysis_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ContentMetaData_PrintMetadata

// optional string printer_name = 1;
inline bool ContentMetaData_PrintMetadata::_internal_has_printer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentMetaData_PrintMetadata::has_printer_name() const {
  return _internal_has_printer_name();
}
inline void ContentMetaData_PrintMetadata::clear_printer_name() {
  _impl_.printer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentMetaData_PrintMetadata::printer_name() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.PrintMetadata.printer_name)
  return _internal_printer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentMetaData_PrintMetadata::set_printer_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.printer_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentMetaData.PrintMetadata.printer_name)
}
inline std::string* ContentMetaData_PrintMetadata::mutable_printer_name() {
  std::string* _s = _internal_mutable_printer_name();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentMetaData.PrintMetadata.printer_name)
  return _s;
}
inline const std::string& ContentMetaData_PrintMetadata::_internal_printer_name() const {
  return _impl_.printer_name_.Get();
}
inline void ContentMetaData_PrintMetadata::_internal_set_printer_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.printer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData_PrintMetadata::_internal_mutable_printer_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.printer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData_PrintMetadata::release_printer_name() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentMetaData.PrintMetadata.printer_name)
  if (!_internal_has_printer_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.printer_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.printer_name_.IsDefault()) {
    _impl_.printer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentMetaData_PrintMetadata::set_allocated_printer_name(std::string* printer_name) {
  if (printer_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.printer_name_.SetAllocated(printer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.printer_name_.IsDefault()) {
    _impl_.printer_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentMetaData.PrintMetadata.printer_name)
}

// optional .content_analysis.sdk.ContentMetaData.PrintMetadata.PrinterType printer_type = 2;
inline bool ContentMetaData_PrintMetadata::_internal_has_printer_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentMetaData_PrintMetadata::has_printer_type() const {
  return _internal_has_printer_type();
}
inline void ContentMetaData_PrintMetadata::clear_printer_type() {
  _impl_.printer_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::_internal_printer_type() const {
  return static_cast< ::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType >(_impl_.printer_type_);
}
inline ::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::printer_type() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.PrintMetadata.printer_type)
  return _internal_printer_type();
}
inline void ContentMetaData_PrintMetadata::_internal_set_printer_type(::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType value) {
  assert(::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.printer_type_ = value;
}
inline void ContentMetaData_PrintMetadata::set_printer_type(::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType value) {
  _internal_set_printer_type(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentMetaData.PrintMetadata.printer_type)
}

// -------------------------------------------------------------------

// ContentMetaData

// optional string url = 1;
inline bool ContentMetaData::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentMetaData::has_url() const {
  return _internal_has_url();
}
inline void ContentMetaData::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentMetaData::url() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentMetaData::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentMetaData.url)
}
inline std::string* ContentMetaData::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentMetaData.url)
  return _s;
}
inline const std::string& ContentMetaData::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ContentMetaData::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_url() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentMetaData.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentMetaData::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentMetaData.url)
}

// optional string filename = 2;
inline bool ContentMetaData::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentMetaData::has_filename() const {
  return _internal_has_filename();
}
inline void ContentMetaData::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContentMetaData::filename() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentMetaData::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentMetaData.filename)
}
inline std::string* ContentMetaData::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentMetaData.filename)
  return _s;
}
inline const std::string& ContentMetaData::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void ContentMetaData::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_filename() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentMetaData.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentMetaData::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentMetaData.filename)
}

// optional string digest = 3;
inline bool ContentMetaData::_internal_has_digest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContentMetaData::has_digest() const {
  return _internal_has_digest();
}
inline void ContentMetaData::clear_digest() {
  _impl_.digest_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContentMetaData::digest() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentMetaData::set_digest(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.digest_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentMetaData.digest)
}
inline std::string* ContentMetaData::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentMetaData.digest)
  return _s;
}
inline const std::string& ContentMetaData::_internal_digest() const {
  return _impl_.digest_.Get();
}
inline void ContentMetaData::_internal_set_digest(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.digest_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_digest() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.digest_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_digest() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentMetaData.digest)
  if (!_internal_has_digest()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.digest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digest_.IsDefault()) {
    _impl_.digest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentMetaData::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.digest_.SetAllocated(digest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digest_.IsDefault()) {
    _impl_.digest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentMetaData.digest)
}

// optional .content_analysis.sdk.ClientDownloadRequest csd = 4;
inline bool ContentMetaData::_internal_has_csd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.csd_ != nullptr);
  return value;
}
inline bool ContentMetaData::has_csd() const {
  return _internal_has_csd();
}
inline void ContentMetaData::clear_csd() {
  if (_impl_.csd_ != nullptr) _impl_.csd_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::content_analysis::sdk::ClientDownloadRequest& ContentMetaData::_internal_csd() const {
  const ::content_analysis::sdk::ClientDownloadRequest* p = _impl_.csd_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ClientDownloadRequest&>(
      ::content_analysis::sdk::_ClientDownloadRequest_default_instance_);
}
inline const ::content_analysis::sdk::ClientDownloadRequest& ContentMetaData::csd() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.csd)
  return _internal_csd();
}
inline void ContentMetaData::unsafe_arena_set_allocated_csd(
    ::content_analysis::sdk::ClientDownloadRequest* csd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.csd_);
  }
  _impl_.csd_ = csd;
  if (csd) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ContentMetaData.csd)
}
inline ::content_analysis::sdk::ClientDownloadRequest* ContentMetaData::release_csd() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::content_analysis::sdk::ClientDownloadRequest* temp = _impl_.csd_;
  _impl_.csd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ClientDownloadRequest* ContentMetaData::unsafe_arena_release_csd() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentMetaData.csd)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::content_analysis::sdk::ClientDownloadRequest* temp = _impl_.csd_;
  _impl_.csd_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ClientDownloadRequest* ContentMetaData::_internal_mutable_csd() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.csd_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ClientDownloadRequest>(GetArenaForAllocation());
    _impl_.csd_ = p;
  }
  return _impl_.csd_;
}
inline ::content_analysis::sdk::ClientDownloadRequest* ContentMetaData::mutable_csd() {
  ::content_analysis::sdk::ClientDownloadRequest* _msg = _internal_mutable_csd();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentMetaData.csd)
  return _msg;
}
inline void ContentMetaData::set_allocated_csd(::content_analysis::sdk::ClientDownloadRequest* csd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.csd_;
  }
  if (csd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(csd);
    if (message_arena != submessage_arena) {
      csd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, csd, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.csd_ = csd;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentMetaData.csd)
}

// optional string email = 5;
inline bool ContentMetaData::_internal_has_email() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContentMetaData::has_email() const {
  return _internal_has_email();
}
inline void ContentMetaData::clear_email() {
  _impl_.email_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContentMetaData::email() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentMetaData::set_email(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentMetaData.email)
}
inline std::string* ContentMetaData::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentMetaData.email)
  return _s;
}
inline const std::string& ContentMetaData::_internal_email() const {
  return _impl_.email_.Get();
}
inline void ContentMetaData::_internal_set_email(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_email() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_email() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentMetaData.email)
  if (!_internal_has_email()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentMetaData::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentMetaData.email)
}

// optional string tab_title = 9;
inline bool ContentMetaData::_internal_has_tab_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContentMetaData::has_tab_title() const {
  return _internal_has_tab_title();
}
inline void ContentMetaData::clear_tab_title() {
  _impl_.tab_title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ContentMetaData::tab_title() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.tab_title)
  return _internal_tab_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentMetaData::set_tab_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.tab_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentMetaData.tab_title)
}
inline std::string* ContentMetaData::mutable_tab_title() {
  std::string* _s = _internal_mutable_tab_title();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentMetaData.tab_title)
  return _s;
}
inline const std::string& ContentMetaData::_internal_tab_title() const {
  return _impl_.tab_title_.Get();
}
inline void ContentMetaData::_internal_set_tab_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.tab_title_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_tab_title() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.tab_title_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_tab_title() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentMetaData.tab_title)
  if (!_internal_has_tab_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.tab_title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tab_title_.IsDefault()) {
    _impl_.tab_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentMetaData::set_allocated_tab_title(std::string* tab_title) {
  if (tab_title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.tab_title_.SetAllocated(tab_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tab_title_.IsDefault()) {
    _impl_.tab_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentMetaData.tab_title)
}

// optional .content_analysis.sdk.ContentMetaData.PrintMetadata print_metadata = 11;
inline bool ContentMetaData::_internal_has_print_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.print_metadata_ != nullptr);
  return value;
}
inline bool ContentMetaData::has_print_metadata() const {
  return _internal_has_print_metadata();
}
inline void ContentMetaData::clear_print_metadata() {
  if (_impl_.print_metadata_ != nullptr) _impl_.print_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::content_analysis::sdk::ContentMetaData_PrintMetadata& ContentMetaData::_internal_print_metadata() const {
  const ::content_analysis::sdk::ContentMetaData_PrintMetadata* p = _impl_.print_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ContentMetaData_PrintMetadata&>(
      ::content_analysis::sdk::_ContentMetaData_PrintMetadata_default_instance_);
}
inline const ::content_analysis::sdk::ContentMetaData_PrintMetadata& ContentMetaData::print_metadata() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentMetaData.print_metadata)
  return _internal_print_metadata();
}
inline void ContentMetaData::unsafe_arena_set_allocated_print_metadata(
    ::content_analysis::sdk::ContentMetaData_PrintMetadata* print_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.print_metadata_);
  }
  _impl_.print_metadata_ = print_metadata;
  if (print_metadata) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ContentMetaData.print_metadata)
}
inline ::content_analysis::sdk::ContentMetaData_PrintMetadata* ContentMetaData::release_print_metadata() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::content_analysis::sdk::ContentMetaData_PrintMetadata* temp = _impl_.print_metadata_;
  _impl_.print_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ContentMetaData_PrintMetadata* ContentMetaData::unsafe_arena_release_print_metadata() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentMetaData.print_metadata)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::content_analysis::sdk::ContentMetaData_PrintMetadata* temp = _impl_.print_metadata_;
  _impl_.print_metadata_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ContentMetaData_PrintMetadata* ContentMetaData::_internal_mutable_print_metadata() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.print_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ContentMetaData_PrintMetadata>(GetArenaForAllocation());
    _impl_.print_metadata_ = p;
  }
  return _impl_.print_metadata_;
}
inline ::content_analysis::sdk::ContentMetaData_PrintMetadata* ContentMetaData::mutable_print_metadata() {
  ::content_analysis::sdk::ContentMetaData_PrintMetadata* _msg = _internal_mutable_print_metadata();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentMetaData.print_metadata)
  return _msg;
}
inline void ContentMetaData::set_allocated_print_metadata(::content_analysis::sdk::ContentMetaData_PrintMetadata* print_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.print_metadata_;
  }
  if (print_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(print_metadata);
    if (message_arena != submessage_arena) {
      print_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, print_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.print_metadata_ = print_metadata;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentMetaData.print_metadata)
}

// -------------------------------------------------------------------

// ClientMetadata_Browser

// optional string machine_user = 4;
inline bool ClientMetadata_Browser::_internal_has_machine_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientMetadata_Browser::has_machine_user() const {
  return _internal_has_machine_user();
}
inline void ClientMetadata_Browser::clear_machine_user() {
  _impl_.machine_user_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientMetadata_Browser::machine_user() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ClientMetadata.Browser.machine_user)
  return _internal_machine_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientMetadata_Browser::set_machine_user(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.machine_user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ClientMetadata.Browser.machine_user)
}
inline std::string* ClientMetadata_Browser::mutable_machine_user() {
  std::string* _s = _internal_mutable_machine_user();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ClientMetadata.Browser.machine_user)
  return _s;
}
inline const std::string& ClientMetadata_Browser::_internal_machine_user() const {
  return _impl_.machine_user_.Get();
}
inline void ClientMetadata_Browser::_internal_set_machine_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.machine_user_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::_internal_mutable_machine_user() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.machine_user_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::release_machine_user() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ClientMetadata.Browser.machine_user)
  if (!_internal_has_machine_user()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.machine_user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_user_.IsDefault()) {
    _impl_.machine_user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientMetadata_Browser::set_allocated_machine_user(std::string* machine_user) {
  if (machine_user != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.machine_user_.SetAllocated(machine_user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_user_.IsDefault()) {
    _impl_.machine_user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ClientMetadata.Browser.machine_user)
}

// -------------------------------------------------------------------

// ClientMetadata

// optional .content_analysis.sdk.ClientMetadata.Browser browser = 1;
inline bool ClientMetadata::_internal_has_browser() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browser_ != nullptr);
  return value;
}
inline bool ClientMetadata::has_browser() const {
  return _internal_has_browser();
}
inline void ClientMetadata::clear_browser() {
  if (_impl_.browser_ != nullptr) _impl_.browser_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::content_analysis::sdk::ClientMetadata_Browser& ClientMetadata::_internal_browser() const {
  const ::content_analysis::sdk::ClientMetadata_Browser* p = _impl_.browser_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ClientMetadata_Browser&>(
      ::content_analysis::sdk::_ClientMetadata_Browser_default_instance_);
}
inline const ::content_analysis::sdk::ClientMetadata_Browser& ClientMetadata::browser() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ClientMetadata.browser)
  return _internal_browser();
}
inline void ClientMetadata::unsafe_arena_set_allocated_browser(
    ::content_analysis::sdk::ClientMetadata_Browser* browser) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_);
  }
  _impl_.browser_ = browser;
  if (browser) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ClientMetadata.browser)
}
inline ::content_analysis::sdk::ClientMetadata_Browser* ClientMetadata::release_browser() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::content_analysis::sdk::ClientMetadata_Browser* temp = _impl_.browser_;
  _impl_.browser_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ClientMetadata_Browser* ClientMetadata::unsafe_arena_release_browser() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ClientMetadata.browser)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::content_analysis::sdk::ClientMetadata_Browser* temp = _impl_.browser_;
  _impl_.browser_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ClientMetadata_Browser* ClientMetadata::_internal_mutable_browser() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.browser_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ClientMetadata_Browser>(GetArenaForAllocation());
    _impl_.browser_ = p;
  }
  return _impl_.browser_;
}
inline ::content_analysis::sdk::ClientMetadata_Browser* ClientMetadata::mutable_browser() {
  ::content_analysis::sdk::ClientMetadata_Browser* _msg = _internal_mutable_browser();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ClientMetadata.browser)
  return _msg;
}
inline void ClientMetadata::set_allocated_browser(::content_analysis::sdk::ClientMetadata_Browser* browser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.browser_;
  }
  if (browser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser);
    if (message_arena != submessage_arena) {
      browser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browser, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.browser_ = browser;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ClientMetadata.browser)
}

// -------------------------------------------------------------------

// ClientDownloadRequest_Resource

// required string url = 1;
inline bool ClientDownloadRequest_Resource::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientDownloadRequest_Resource::has_url() const {
  return _internal_has_url();
}
inline void ClientDownloadRequest_Resource::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientDownloadRequest_Resource::url() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ClientDownloadRequest.Resource.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientDownloadRequest_Resource::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ClientDownloadRequest.Resource.url)
}
inline std::string* ClientDownloadRequest_Resource::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ClientDownloadRequest.Resource.url)
  return _s;
}
inline const std::string& ClientDownloadRequest_Resource::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ClientDownloadRequest_Resource::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientDownloadRequest_Resource::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientDownloadRequest_Resource::release_url() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ClientDownloadRequest.Resource.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientDownloadRequest_Resource::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ClientDownloadRequest.Resource.url)
}

// required .content_analysis.sdk.ClientDownloadRequest.ResourceType type = 2;
inline bool ClientDownloadRequest_Resource::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientDownloadRequest_Resource::has_type() const {
  return _internal_has_type();
}
inline void ClientDownloadRequest_Resource::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::content_analysis::sdk::ClientDownloadRequest_ResourceType ClientDownloadRequest_Resource::_internal_type() const {
  return static_cast< ::content_analysis::sdk::ClientDownloadRequest_ResourceType >(_impl_.type_);
}
inline ::content_analysis::sdk::ClientDownloadRequest_ResourceType ClientDownloadRequest_Resource::type() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ClientDownloadRequest.Resource.type)
  return _internal_type();
}
inline void ClientDownloadRequest_Resource::_internal_set_type(::content_analysis::sdk::ClientDownloadRequest_ResourceType value) {
  assert(::content_analysis::sdk::ClientDownloadRequest_ResourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void ClientDownloadRequest_Resource::set_type(::content_analysis::sdk::ClientDownloadRequest_ResourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ClientDownloadRequest.Resource.type)
}

// -------------------------------------------------------------------

// ClientDownloadRequest

// repeated .content_analysis.sdk.ClientDownloadRequest.Resource resources = 4;
inline int ClientDownloadRequest::_internal_resources_size() const {
  return _impl_.resources_.size();
}
inline int ClientDownloadRequest::resources_size() const {
  return _internal_resources_size();
}
inline void ClientDownloadRequest::clear_resources() {
  _impl_.resources_.Clear();
}
inline ::content_analysis::sdk::ClientDownloadRequest_Resource* ClientDownloadRequest::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ClientDownloadRequest.resources)
  return _impl_.resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ClientDownloadRequest_Resource >*
ClientDownloadRequest::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:content_analysis.sdk.ClientDownloadRequest.resources)
  return &_impl_.resources_;
}
inline const ::content_analysis::sdk::ClientDownloadRequest_Resource& ClientDownloadRequest::_internal_resources(int index) const {
  return _impl_.resources_.Get(index);
}
inline const ::content_analysis::sdk::ClientDownloadRequest_Resource& ClientDownloadRequest::resources(int index) const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ClientDownloadRequest.resources)
  return _internal_resources(index);
}
inline ::content_analysis::sdk::ClientDownloadRequest_Resource* ClientDownloadRequest::_internal_add_resources() {
  return _impl_.resources_.Add();
}
inline ::content_analysis::sdk::ClientDownloadRequest_Resource* ClientDownloadRequest::add_resources() {
  ::content_analysis::sdk::ClientDownloadRequest_Resource* _add = _internal_add_resources();
  // @@protoc_insertion_point(field_add:content_analysis.sdk.ClientDownloadRequest.resources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ClientDownloadRequest_Resource >&
ClientDownloadRequest::resources() const {
  // @@protoc_insertion_point(field_list:content_analysis.sdk.ClientDownloadRequest.resources)
  return _impl_.resources_;
}

// -------------------------------------------------------------------

// ContentAnalysisRequest_PrintData

// optional int64 handle = 1;
inline bool ContentAnalysisRequest_PrintData::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentAnalysisRequest_PrintData::has_handle() const {
  return _internal_has_handle();
}
inline void ContentAnalysisRequest_PrintData::clear_handle() {
  _impl_.handle_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ContentAnalysisRequest_PrintData::_internal_handle() const {
  return _impl_.handle_;
}
inline int64_t ContentAnalysisRequest_PrintData::handle() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.PrintData.handle)
  return _internal_handle();
}
inline void ContentAnalysisRequest_PrintData::_internal_set_handle(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_ = value;
}
inline void ContentAnalysisRequest_PrintData::set_handle(int64_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.PrintData.handle)
}

// optional int64 size = 2;
inline bool ContentAnalysisRequest_PrintData::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentAnalysisRequest_PrintData::has_size() const {
  return _internal_has_size();
}
inline void ContentAnalysisRequest_PrintData::clear_size() {
  _impl_.size_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t ContentAnalysisRequest_PrintData::_internal_size() const {
  return _impl_.size_;
}
inline int64_t ContentAnalysisRequest_PrintData::size() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.PrintData.size)
  return _internal_size();
}
inline void ContentAnalysisRequest_PrintData::_internal_set_size(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void ContentAnalysisRequest_PrintData::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.PrintData.size)
}

// -------------------------------------------------------------------

// ContentAnalysisRequest

// optional string request_token = 5;
inline bool ContentAnalysisRequest::_internal_has_request_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentAnalysisRequest::has_request_token() const {
  return _internal_has_request_token();
}
inline void ContentAnalysisRequest::clear_request_token() {
  _impl_.request_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisRequest::request_token() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.request_token)
  return _internal_request_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentAnalysisRequest::set_request_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.request_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.request_token)
}
inline std::string* ContentAnalysisRequest::mutable_request_token() {
  std::string* _s = _internal_mutable_request_token();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisRequest.request_token)
  return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_request_token() const {
  return _impl_.request_token_.Get();
}
inline void ContentAnalysisRequest::_internal_set_request_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_request_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.request_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_request_token() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisRequest.request_token)
  if (!_internal_has_request_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.request_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_token_.IsDefault()) {
    _impl_.request_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentAnalysisRequest::set_allocated_request_token(std::string* request_token) {
  if (request_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.request_token_.SetAllocated(request_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_token_.IsDefault()) {
    _impl_.request_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisRequest.request_token)
}

// optional .content_analysis.sdk.AnalysisConnector analysis_connector = 9;
inline bool ContentAnalysisRequest::_internal_has_analysis_connector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContentAnalysisRequest::has_analysis_connector() const {
  return _internal_has_analysis_connector();
}
inline void ContentAnalysisRequest::clear_analysis_connector() {
  _impl_.analysis_connector_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::content_analysis::sdk::AnalysisConnector ContentAnalysisRequest::_internal_analysis_connector() const {
  return static_cast< ::content_analysis::sdk::AnalysisConnector >(_impl_.analysis_connector_);
}
inline ::content_analysis::sdk::AnalysisConnector ContentAnalysisRequest::analysis_connector() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.analysis_connector)
  return _internal_analysis_connector();
}
inline void ContentAnalysisRequest::_internal_set_analysis_connector(::content_analysis::sdk::AnalysisConnector value) {
  assert(::content_analysis::sdk::AnalysisConnector_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.analysis_connector_ = value;
}
inline void ContentAnalysisRequest::set_analysis_connector(::content_analysis::sdk::AnalysisConnector value) {
  _internal_set_analysis_connector(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.analysis_connector)
}

// optional .content_analysis.sdk.ContentMetaData request_data = 10;
inline bool ContentAnalysisRequest::_internal_has_request_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_data_ != nullptr);
  return value;
}
inline bool ContentAnalysisRequest::has_request_data() const {
  return _internal_has_request_data();
}
inline void ContentAnalysisRequest::clear_request_data() {
  if (_impl_.request_data_ != nullptr) _impl_.request_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::content_analysis::sdk::ContentMetaData& ContentAnalysisRequest::_internal_request_data() const {
  const ::content_analysis::sdk::ContentMetaData* p = _impl_.request_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ContentMetaData&>(
      ::content_analysis::sdk::_ContentMetaData_default_instance_);
}
inline const ::content_analysis::sdk::ContentMetaData& ContentAnalysisRequest::request_data() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.request_data)
  return _internal_request_data();
}
inline void ContentAnalysisRequest::unsafe_arena_set_allocated_request_data(
    ::content_analysis::sdk::ContentMetaData* request_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_data_);
  }
  _impl_.request_data_ = request_data;
  if (request_data) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ContentAnalysisRequest.request_data)
}
inline ::content_analysis::sdk::ContentMetaData* ContentAnalysisRequest::release_request_data() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::content_analysis::sdk::ContentMetaData* temp = _impl_.request_data_;
  _impl_.request_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ContentMetaData* ContentAnalysisRequest::unsafe_arena_release_request_data() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisRequest.request_data)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::content_analysis::sdk::ContentMetaData* temp = _impl_.request_data_;
  _impl_.request_data_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ContentMetaData* ContentAnalysisRequest::_internal_mutable_request_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.request_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ContentMetaData>(GetArenaForAllocation());
    _impl_.request_data_ = p;
  }
  return _impl_.request_data_;
}
inline ::content_analysis::sdk::ContentMetaData* ContentAnalysisRequest::mutable_request_data() {
  ::content_analysis::sdk::ContentMetaData* _msg = _internal_mutable_request_data();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisRequest.request_data)
  return _msg;
}
inline void ContentAnalysisRequest::set_allocated_request_data(::content_analysis::sdk::ContentMetaData* request_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_data_;
  }
  if (request_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_data);
    if (message_arena != submessage_arena) {
      request_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.request_data_ = request_data;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisRequest.request_data)
}

// repeated string tags = 11;
inline int ContentAnalysisRequest::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int ContentAnalysisRequest::tags_size() const {
  return _internal_tags_size();
}
inline void ContentAnalysisRequest::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* ContentAnalysisRequest::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:content_analysis.sdk.ContentAnalysisRequest.tags)
  return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& ContentAnalysisRequest::tags(int index) const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.tags)
  return _internal_tags(index);
}
inline std::string* ContentAnalysisRequest::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisRequest.tags)
  return _impl_.tags_.Mutable(index);
}
inline void ContentAnalysisRequest::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:content_analysis.sdk.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:content_analysis.sdk.ContentAnalysisRequest.tags)
}
inline std::string* ContentAnalysisRequest::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void ContentAnalysisRequest::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:content_analysis.sdk.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:content_analysis.sdk.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:content_analysis.sdk.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:content_analysis.sdk.ContentAnalysisRequest.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContentAnalysisRequest::tags() const {
  // @@protoc_insertion_point(field_list:content_analysis.sdk.ContentAnalysisRequest.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContentAnalysisRequest::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:content_analysis.sdk.ContentAnalysisRequest.tags)
  return &_impl_.tags_;
}

// optional .content_analysis.sdk.ClientMetadata client_metadata = 12;
inline bool ContentAnalysisRequest::_internal_has_client_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_metadata_ != nullptr);
  return value;
}
inline bool ContentAnalysisRequest::has_client_metadata() const {
  return _internal_has_client_metadata();
}
inline void ContentAnalysisRequest::clear_client_metadata() {
  if (_impl_.client_metadata_ != nullptr) _impl_.client_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::content_analysis::sdk::ClientMetadata& ContentAnalysisRequest::_internal_client_metadata() const {
  const ::content_analysis::sdk::ClientMetadata* p = _impl_.client_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ClientMetadata&>(
      ::content_analysis::sdk::_ClientMetadata_default_instance_);
}
inline const ::content_analysis::sdk::ClientMetadata& ContentAnalysisRequest::client_metadata() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.client_metadata)
  return _internal_client_metadata();
}
inline void ContentAnalysisRequest::unsafe_arena_set_allocated_client_metadata(
    ::content_analysis::sdk::ClientMetadata* client_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_metadata_);
  }
  _impl_.client_metadata_ = client_metadata;
  if (client_metadata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ContentAnalysisRequest.client_metadata)
}
inline ::content_analysis::sdk::ClientMetadata* ContentAnalysisRequest::release_client_metadata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::content_analysis::sdk::ClientMetadata* temp = _impl_.client_metadata_;
  _impl_.client_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ClientMetadata* ContentAnalysisRequest::unsafe_arena_release_client_metadata() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisRequest.client_metadata)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::content_analysis::sdk::ClientMetadata* temp = _impl_.client_metadata_;
  _impl_.client_metadata_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ClientMetadata* ContentAnalysisRequest::_internal_mutable_client_metadata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.client_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ClientMetadata>(GetArenaForAllocation());
    _impl_.client_metadata_ = p;
  }
  return _impl_.client_metadata_;
}
inline ::content_analysis::sdk::ClientMetadata* ContentAnalysisRequest::mutable_client_metadata() {
  ::content_analysis::sdk::ClientMetadata* _msg = _internal_mutable_client_metadata();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisRequest.client_metadata)
  return _msg;
}
inline void ContentAnalysisRequest::set_allocated_client_metadata(::content_analysis::sdk::ClientMetadata* client_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_metadata_;
  }
  if (client_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_metadata);
    if (message_arena != submessage_arena) {
      client_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.client_metadata_ = client_metadata;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisRequest.client_metadata)
}

// string text_content = 13;
inline bool ContentAnalysisRequest::_internal_has_text_content() const {
  return content_data_case() == kTextContent;
}
inline bool ContentAnalysisRequest::has_text_content() const {
  return _internal_has_text_content();
}
inline void ContentAnalysisRequest::set_has_text_content() {
  _impl_._oneof_case_[0] = kTextContent;
}
inline void ContentAnalysisRequest::clear_text_content() {
  if (_internal_has_text_content()) {
    _impl_.content_data_.text_content_.Destroy();
    clear_has_content_data();
  }
}
inline const std::string& ContentAnalysisRequest::text_content() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.text_content)
  return _internal_text_content();
}
template <typename ArgT0, typename... ArgT>
inline void ContentAnalysisRequest::set_text_content(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text_content()) {
    clear_content_data();
    set_has_text_content();
    _impl_.content_data_.text_content_.InitDefault();
  }
  _impl_.content_data_.text_content_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.text_content)
}
inline std::string* ContentAnalysisRequest::mutable_text_content() {
  std::string* _s = _internal_mutable_text_content();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisRequest.text_content)
  return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_text_content() const {
  if (_internal_has_text_content()) {
    return _impl_.content_data_.text_content_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ContentAnalysisRequest::_internal_set_text_content(const std::string& value) {
  if (!_internal_has_text_content()) {
    clear_content_data();
    set_has_text_content();
    _impl_.content_data_.text_content_.InitDefault();
  }
  _impl_.content_data_.text_content_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_text_content() {
  if (!_internal_has_text_content()) {
    clear_content_data();
    set_has_text_content();
    _impl_.content_data_.text_content_.InitDefault();
  }
  return _impl_.content_data_.text_content_.Mutable(      GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_text_content() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisRequest.text_content)
  if (_internal_has_text_content()) {
    clear_has_content_data();
    return _impl_.content_data_.text_content_.Release();
  } else {
    return nullptr;
  }
}
inline void ContentAnalysisRequest::set_allocated_text_content(std::string* text_content) {
  if (has_content_data()) {
    clear_content_data();
  }
  if (text_content != nullptr) {
    set_has_text_content();
    _impl_.content_data_.text_content_.InitAllocated(text_content, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisRequest.text_content)
}

// string file_path = 14;
inline bool ContentAnalysisRequest::_internal_has_file_path() const {
  return content_data_case() == kFilePath;
}
inline bool ContentAnalysisRequest::has_file_path() const {
  return _internal_has_file_path();
}
inline void ContentAnalysisRequest::set_has_file_path() {
  _impl_._oneof_case_[0] = kFilePath;
}
inline void ContentAnalysisRequest::clear_file_path() {
  if (_internal_has_file_path()) {
    _impl_.content_data_.file_path_.Destroy();
    clear_has_content_data();
  }
}
inline const std::string& ContentAnalysisRequest::file_path() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline void ContentAnalysisRequest::set_file_path(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_file_path()) {
    clear_content_data();
    set_has_file_path();
    _impl_.content_data_.file_path_.InitDefault();
  }
  _impl_.content_data_.file_path_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.file_path)
}
inline std::string* ContentAnalysisRequest::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisRequest.file_path)
  return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_file_path() const {
  if (_internal_has_file_path()) {
    return _impl_.content_data_.file_path_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ContentAnalysisRequest::_internal_set_file_path(const std::string& value) {
  if (!_internal_has_file_path()) {
    clear_content_data();
    set_has_file_path();
    _impl_.content_data_.file_path_.InitDefault();
  }
  _impl_.content_data_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_file_path() {
  if (!_internal_has_file_path()) {
    clear_content_data();
    set_has_file_path();
    _impl_.content_data_.file_path_.InitDefault();
  }
  return _impl_.content_data_.file_path_.Mutable(      GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisRequest.file_path)
  if (_internal_has_file_path()) {
    clear_has_content_data();
    return _impl_.content_data_.file_path_.Release();
  } else {
    return nullptr;
  }
}
inline void ContentAnalysisRequest::set_allocated_file_path(std::string* file_path) {
  if (has_content_data()) {
    clear_content_data();
  }
  if (file_path != nullptr) {
    set_has_file_path();
    _impl_.content_data_.file_path_.InitAllocated(file_path, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisRequest.file_path)
}

// .content_analysis.sdk.ContentAnalysisRequest.PrintData print_data = 18;
inline bool ContentAnalysisRequest::_internal_has_print_data() const {
  return content_data_case() == kPrintData;
}
inline bool ContentAnalysisRequest::has_print_data() const {
  return _internal_has_print_data();
}
inline void ContentAnalysisRequest::set_has_print_data() {
  _impl_._oneof_case_[0] = kPrintData;
}
inline void ContentAnalysisRequest::clear_print_data() {
  if (_internal_has_print_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_data_.print_data_;
    }
    clear_has_content_data();
  }
}
inline ::content_analysis::sdk::ContentAnalysisRequest_PrintData* ContentAnalysisRequest::release_print_data() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisRequest.print_data)
  if (_internal_has_print_data()) {
    clear_has_content_data();
    ::content_analysis::sdk::ContentAnalysisRequest_PrintData* temp = _impl_.content_data_.print_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_data_.print_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::content_analysis::sdk::ContentAnalysisRequest_PrintData& ContentAnalysisRequest::_internal_print_data() const {
  return _internal_has_print_data()
      ? *_impl_.content_data_.print_data_
      : reinterpret_cast< ::content_analysis::sdk::ContentAnalysisRequest_PrintData&>(::content_analysis::sdk::_ContentAnalysisRequest_PrintData_default_instance_);
}
inline const ::content_analysis::sdk::ContentAnalysisRequest_PrintData& ContentAnalysisRequest::print_data() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.print_data)
  return _internal_print_data();
}
inline ::content_analysis::sdk::ContentAnalysisRequest_PrintData* ContentAnalysisRequest::unsafe_arena_release_print_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:content_analysis.sdk.ContentAnalysisRequest.print_data)
  if (_internal_has_print_data()) {
    clear_has_content_data();
    ::content_analysis::sdk::ContentAnalysisRequest_PrintData* temp = _impl_.content_data_.print_data_;
    _impl_.content_data_.print_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ContentAnalysisRequest::unsafe_arena_set_allocated_print_data(::content_analysis::sdk::ContentAnalysisRequest_PrintData* print_data) {
  clear_content_data();
  if (print_data) {
    set_has_print_data();
    _impl_.content_data_.print_data_ = print_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ContentAnalysisRequest.print_data)
}
inline ::content_analysis::sdk::ContentAnalysisRequest_PrintData* ContentAnalysisRequest::_internal_mutable_print_data() {
  if (!_internal_has_print_data()) {
    clear_content_data();
    set_has_print_data();
    _impl_.content_data_.print_data_ = CreateMaybeMessage< ::content_analysis::sdk::ContentAnalysisRequest_PrintData >(GetArenaForAllocation());
  }
  return _impl_.content_data_.print_data_;
}
inline ::content_analysis::sdk::ContentAnalysisRequest_PrintData* ContentAnalysisRequest::mutable_print_data() {
  ::content_analysis::sdk::ContentAnalysisRequest_PrintData* _msg = _internal_mutable_print_data();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisRequest.print_data)
  return _msg;
}

// optional int64 expires_at = 15;
inline bool ContentAnalysisRequest::_internal_has_expires_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ContentAnalysisRequest::has_expires_at() const {
  return _internal_has_expires_at();
}
inline void ContentAnalysisRequest::clear_expires_at() {
  _impl_.expires_at_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t ContentAnalysisRequest::_internal_expires_at() const {
  return _impl_.expires_at_;
}
inline int64_t ContentAnalysisRequest::expires_at() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.expires_at)
  return _internal_expires_at();
}
inline void ContentAnalysisRequest::_internal_set_expires_at(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.expires_at_ = value;
}
inline void ContentAnalysisRequest::set_expires_at(int64_t value) {
  _internal_set_expires_at(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.expires_at)
}

// optional string user_action_id = 16;
inline bool ContentAnalysisRequest::_internal_has_user_action_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentAnalysisRequest::has_user_action_id() const {
  return _internal_has_user_action_id();
}
inline void ContentAnalysisRequest::clear_user_action_id() {
  _impl_.user_action_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContentAnalysisRequest::user_action_id() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.user_action_id)
  return _internal_user_action_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentAnalysisRequest::set_user_action_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.user_action_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.user_action_id)
}
inline std::string* ContentAnalysisRequest::mutable_user_action_id() {
  std::string* _s = _internal_mutable_user_action_id();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisRequest.user_action_id)
  return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_user_action_id() const {
  return _impl_.user_action_id_.Get();
}
inline void ContentAnalysisRequest::_internal_set_user_action_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_action_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_user_action_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.user_action_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_user_action_id() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisRequest.user_action_id)
  if (!_internal_has_user_action_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.user_action_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_action_id_.IsDefault()) {
    _impl_.user_action_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentAnalysisRequest::set_allocated_user_action_id(std::string* user_action_id) {
  if (user_action_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.user_action_id_.SetAllocated(user_action_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_action_id_.IsDefault()) {
    _impl_.user_action_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisRequest.user_action_id)
}

// optional int64 user_action_requests_count = 17;
inline bool ContentAnalysisRequest::_internal_has_user_action_requests_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ContentAnalysisRequest::has_user_action_requests_count() const {
  return _internal_has_user_action_requests_count();
}
inline void ContentAnalysisRequest::clear_user_action_requests_count() {
  _impl_.user_action_requests_count_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t ContentAnalysisRequest::_internal_user_action_requests_count() const {
  return _impl_.user_action_requests_count_;
}
inline int64_t ContentAnalysisRequest::user_action_requests_count() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.user_action_requests_count)
  return _internal_user_action_requests_count();
}
inline void ContentAnalysisRequest::_internal_set_user_action_requests_count(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.user_action_requests_count_ = value;
}
inline void ContentAnalysisRequest::set_user_action_requests_count(int64_t value) {
  _internal_set_user_action_requests_count(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.user_action_requests_count)
}

// optional .content_analysis.sdk.ContentAnalysisRequest.Reason reason = 19;
inline bool ContentAnalysisRequest::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContentAnalysisRequest::has_reason() const {
  return _internal_has_reason();
}
inline void ContentAnalysisRequest::clear_reason() {
  _impl_.reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::content_analysis::sdk::ContentAnalysisRequest_Reason ContentAnalysisRequest::_internal_reason() const {
  return static_cast< ::content_analysis::sdk::ContentAnalysisRequest_Reason >(_impl_.reason_);
}
inline ::content_analysis::sdk::ContentAnalysisRequest_Reason ContentAnalysisRequest::reason() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisRequest.reason)
  return _internal_reason();
}
inline void ContentAnalysisRequest::_internal_set_reason(::content_analysis::sdk::ContentAnalysisRequest_Reason value) {
  assert(::content_analysis::sdk::ContentAnalysisRequest_Reason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.reason_ = value;
}
inline void ContentAnalysisRequest::set_reason(::content_analysis::sdk::ContentAnalysisRequest_Reason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisRequest.reason)
}

inline bool ContentAnalysisRequest::has_content_data() const {
  return content_data_case() != CONTENT_DATA_NOT_SET;
}
inline void ContentAnalysisRequest::clear_has_content_data() {
  _impl_._oneof_case_[0] = CONTENT_DATA_NOT_SET;
}
inline ContentAnalysisRequest::ContentDataCase ContentAnalysisRequest::content_data_case() const {
  return ContentAnalysisRequest::ContentDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ContentAnalysisResponse_Result_TriggeredRule

// optional .content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_action() const {
  return _internal_has_action();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_action() {
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::_internal_action() const {
  return static_cast< ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action >(_impl_.action_);
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::action() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.action)
  return _internal_action();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::_internal_set_action(::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action value) {
  assert(::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.action_ = value;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_action(::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.action)
}

// optional string rule_name = 2;
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_rule_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_rule_name() const {
  return _internal_has_rule_name();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_rule_name() {
  _impl_.rule_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::rule_name() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
  return _internal_rule_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentAnalysisResponse_Result_TriggeredRule::set_rule_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.rule_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::mutable_rule_name() {
  std::string* _s = _internal_mutable_rule_name();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
  return _s;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::_internal_rule_name() const {
  return _impl_.rule_name_.Get();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::_internal_set_rule_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rule_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::_internal_mutable_rule_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.rule_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::release_rule_name() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
  if (!_internal_has_rule_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.rule_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rule_name_.IsDefault()) {
    _impl_.rule_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_allocated_rule_name(std::string* rule_name) {
  if (rule_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rule_name_.SetAllocated(rule_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rule_name_.IsDefault()) {
    _impl_.rule_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
}

// optional string rule_id = 3;
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_rule_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_rule_id() const {
  return _internal_has_rule_id();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_rule_id() {
  _impl_.rule_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::rule_id() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
  return _internal_rule_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentAnalysisResponse_Result_TriggeredRule::set_rule_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.rule_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::mutable_rule_id() {
  std::string* _s = _internal_mutable_rule_id();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
  return _s;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::_internal_rule_id() const {
  return _impl_.rule_id_.Get();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::_internal_set_rule_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rule_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::_internal_mutable_rule_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.rule_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::release_rule_id() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
  if (!_internal_has_rule_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.rule_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rule_id_.IsDefault()) {
    _impl_.rule_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_allocated_rule_id(std::string* rule_id) {
  if (rule_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rule_id_.SetAllocated(rule_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rule_id_.IsDefault()) {
    _impl_.rule_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
}

// -------------------------------------------------------------------

// ContentAnalysisResponse_Result

// optional string tag = 1;
inline bool ContentAnalysisResponse_Result::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentAnalysisResponse_Result::has_tag() const {
  return _internal_has_tag();
}
inline void ContentAnalysisResponse_Result::clear_tag() {
  _impl_.tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisResponse_Result::tag() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisResponse.Result.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentAnalysisResponse_Result::set_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisResponse.Result.tag)
}
inline std::string* ContentAnalysisResponse_Result::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisResponse.Result.tag)
  return _s;
}
inline const std::string& ContentAnalysisResponse_Result::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void ContentAnalysisResponse_Result::_internal_set_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result::release_tag() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisResponse.Result.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentAnalysisResponse_Result::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisResponse.Result.tag)
}

// optional .content_analysis.sdk.ContentAnalysisResponse.Result.Status status = 2;
inline bool ContentAnalysisResponse_Result::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentAnalysisResponse_Result::has_status() const {
  return _internal_has_status();
}
inline void ContentAnalysisResponse_Result::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::_internal_status() const {
  return static_cast< ::content_analysis::sdk::ContentAnalysisResponse_Result_Status >(_impl_.status_);
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::status() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisResponse.Result.status)
  return _internal_status();
}
inline void ContentAnalysisResponse_Result::_internal_set_status(::content_analysis::sdk::ContentAnalysisResponse_Result_Status value) {
  assert(::content_analysis::sdk::ContentAnalysisResponse_Result_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void ContentAnalysisResponse_Result::set_status(::content_analysis::sdk::ContentAnalysisResponse_Result_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisResponse.Result.status)
}

// repeated .content_analysis.sdk.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
inline int ContentAnalysisResponse_Result::_internal_triggered_rules_size() const {
  return _impl_.triggered_rules_.size();
}
inline int ContentAnalysisResponse_Result::triggered_rules_size() const {
  return _internal_triggered_rules_size();
}
inline void ContentAnalysisResponse_Result::clear_triggered_rules() {
  _impl_.triggered_rules_.Clear();
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule* ContentAnalysisResponse_Result::mutable_triggered_rules(int index) {
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisResponse.Result.triggered_rules)
  return _impl_.triggered_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule >*
ContentAnalysisResponse_Result::mutable_triggered_rules() {
  // @@protoc_insertion_point(field_mutable_list:content_analysis.sdk.ContentAnalysisResponse.Result.triggered_rules)
  return &_impl_.triggered_rules_;
}
inline const ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule& ContentAnalysisResponse_Result::_internal_triggered_rules(int index) const {
  return _impl_.triggered_rules_.Get(index);
}
inline const ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule& ContentAnalysisResponse_Result::triggered_rules(int index) const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisResponse.Result.triggered_rules)
  return _internal_triggered_rules(index);
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule* ContentAnalysisResponse_Result::_internal_add_triggered_rules() {
  return _impl_.triggered_rules_.Add();
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule* ContentAnalysisResponse_Result::add_triggered_rules() {
  ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule* _add = _internal_add_triggered_rules();
  // @@protoc_insertion_point(field_add:content_analysis.sdk.ContentAnalysisResponse.Result.triggered_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule >&
ContentAnalysisResponse_Result::triggered_rules() const {
  // @@protoc_insertion_point(field_list:content_analysis.sdk.ContentAnalysisResponse.Result.triggered_rules)
  return _impl_.triggered_rules_;
}

// -------------------------------------------------------------------

// ContentAnalysisResponse

// optional string request_token = 1;
inline bool ContentAnalysisResponse::_internal_has_request_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentAnalysisResponse::has_request_token() const {
  return _internal_has_request_token();
}
inline void ContentAnalysisResponse::clear_request_token() {
  _impl_.request_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisResponse::request_token() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisResponse.request_token)
  return _internal_request_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentAnalysisResponse::set_request_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.request_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisResponse.request_token)
}
inline std::string* ContentAnalysisResponse::mutable_request_token() {
  std::string* _s = _internal_mutable_request_token();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisResponse.request_token)
  return _s;
}
inline const std::string& ContentAnalysisResponse::_internal_request_token() const {
  return _impl_.request_token_.Get();
}
inline void ContentAnalysisResponse::_internal_set_request_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse::_internal_mutable_request_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.request_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse::release_request_token() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisResponse.request_token)
  if (!_internal_has_request_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.request_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_token_.IsDefault()) {
    _impl_.request_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentAnalysisResponse::set_allocated_request_token(std::string* request_token) {
  if (request_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.request_token_.SetAllocated(request_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_token_.IsDefault()) {
    _impl_.request_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisResponse.request_token)
}

// repeated .content_analysis.sdk.ContentAnalysisResponse.Result results = 4;
inline int ContentAnalysisResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int ContentAnalysisResponse::results_size() const {
  return _internal_results_size();
}
inline void ContentAnalysisResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result* ContentAnalysisResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result >*
ContentAnalysisResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:content_analysis.sdk.ContentAnalysisResponse.results)
  return &_impl_.results_;
}
inline const ::content_analysis::sdk::ContentAnalysisResponse_Result& ContentAnalysisResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::content_analysis::sdk::ContentAnalysisResponse_Result& ContentAnalysisResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisResponse.results)
  return _internal_results(index);
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result* ContentAnalysisResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::content_analysis::sdk::ContentAnalysisResponse_Result* ContentAnalysisResponse::add_results() {
  ::content_analysis::sdk::ContentAnalysisResponse_Result* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:content_analysis.sdk.ContentAnalysisResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content_analysis::sdk::ContentAnalysisResponse_Result >&
ContentAnalysisResponse::results() const {
  // @@protoc_insertion_point(field_list:content_analysis.sdk.ContentAnalysisResponse.results)
  return _impl_.results_;
}

// -------------------------------------------------------------------

// ContentAnalysisAcknowledgement

// optional string request_token = 1;
inline bool ContentAnalysisAcknowledgement::_internal_has_request_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentAnalysisAcknowledgement::has_request_token() const {
  return _internal_has_request_token();
}
inline void ContentAnalysisAcknowledgement::clear_request_token() {
  _impl_.request_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisAcknowledgement::request_token() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisAcknowledgement.request_token)
  return _internal_request_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentAnalysisAcknowledgement::set_request_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.request_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisAcknowledgement.request_token)
}
inline std::string* ContentAnalysisAcknowledgement::mutable_request_token() {
  std::string* _s = _internal_mutable_request_token();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisAcknowledgement.request_token)
  return _s;
}
inline const std::string& ContentAnalysisAcknowledgement::_internal_request_token() const {
  return _impl_.request_token_.Get();
}
inline void ContentAnalysisAcknowledgement::_internal_set_request_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisAcknowledgement::_internal_mutable_request_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.request_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisAcknowledgement::release_request_token() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisAcknowledgement.request_token)
  if (!_internal_has_request_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.request_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_token_.IsDefault()) {
    _impl_.request_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentAnalysisAcknowledgement::set_allocated_request_token(std::string* request_token) {
  if (request_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.request_token_.SetAllocated(request_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_token_.IsDefault()) {
    _impl_.request_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisAcknowledgement.request_token)
}

// optional .content_analysis.sdk.ContentAnalysisAcknowledgement.Status status = 2;
inline bool ContentAnalysisAcknowledgement::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContentAnalysisAcknowledgement::has_status() const {
  return _internal_has_status();
}
inline void ContentAnalysisAcknowledgement::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::content_analysis::sdk::ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::_internal_status() const {
  return static_cast< ::content_analysis::sdk::ContentAnalysisAcknowledgement_Status >(_impl_.status_);
}
inline ::content_analysis::sdk::ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::status() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisAcknowledgement.status)
  return _internal_status();
}
inline void ContentAnalysisAcknowledgement::_internal_set_status(::content_analysis::sdk::ContentAnalysisAcknowledgement_Status value) {
  assert(::content_analysis::sdk::ContentAnalysisAcknowledgement_Status_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}
inline void ContentAnalysisAcknowledgement::set_status(::content_analysis::sdk::ContentAnalysisAcknowledgement_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisAcknowledgement.status)
}

// optional .content_analysis.sdk.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
inline bool ContentAnalysisAcknowledgement::_internal_has_final_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContentAnalysisAcknowledgement::has_final_action() const {
  return _internal_has_final_action();
}
inline void ContentAnalysisAcknowledgement::clear_final_action() {
  _impl_.final_action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::_internal_final_action() const {
  return static_cast< ::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction >(_impl_.final_action_);
}
inline ::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::final_action() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisAcknowledgement.final_action)
  return _internal_final_action();
}
inline void ContentAnalysisAcknowledgement::_internal_set_final_action(::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction value) {
  assert(::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.final_action_ = value;
}
inline void ContentAnalysisAcknowledgement::set_final_action(::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction value) {
  _internal_set_final_action(value);
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisAcknowledgement.final_action)
}

// -------------------------------------------------------------------

// ContentAnalysisCancelRequests

// optional string user_action_id = 1;
inline bool ContentAnalysisCancelRequests::_internal_has_user_action_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContentAnalysisCancelRequests::has_user_action_id() const {
  return _internal_has_user_action_id();
}
inline void ContentAnalysisCancelRequests::clear_user_action_id() {
  _impl_.user_action_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisCancelRequests::user_action_id() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ContentAnalysisCancelRequests.user_action_id)
  return _internal_user_action_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContentAnalysisCancelRequests::set_user_action_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.user_action_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content_analysis.sdk.ContentAnalysisCancelRequests.user_action_id)
}
inline std::string* ContentAnalysisCancelRequests::mutable_user_action_id() {
  std::string* _s = _internal_mutable_user_action_id();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ContentAnalysisCancelRequests.user_action_id)
  return _s;
}
inline const std::string& ContentAnalysisCancelRequests::_internal_user_action_id() const {
  return _impl_.user_action_id_.Get();
}
inline void ContentAnalysisCancelRequests::_internal_set_user_action_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_action_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisCancelRequests::_internal_mutable_user_action_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_action_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisCancelRequests::release_user_action_id() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ContentAnalysisCancelRequests.user_action_id)
  if (!_internal_has_user_action_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.user_action_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_action_id_.IsDefault()) {
    _impl_.user_action_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContentAnalysisCancelRequests::set_allocated_user_action_id(std::string* user_action_id) {
  if (user_action_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_action_id_.SetAllocated(user_action_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_action_id_.IsDefault()) {
    _impl_.user_action_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ContentAnalysisCancelRequests.user_action_id)
}

// -------------------------------------------------------------------

// ChromeToAgent

// optional .content_analysis.sdk.ContentAnalysisRequest request = 1;
inline bool ChromeToAgent::_internal_has_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_ != nullptr);
  return value;
}
inline bool ChromeToAgent::has_request() const {
  return _internal_has_request();
}
inline void ChromeToAgent::clear_request() {
  if (_impl_.request_ != nullptr) _impl_.request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::content_analysis::sdk::ContentAnalysisRequest& ChromeToAgent::_internal_request() const {
  const ::content_analysis::sdk::ContentAnalysisRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ContentAnalysisRequest&>(
      ::content_analysis::sdk::_ContentAnalysisRequest_default_instance_);
}
inline const ::content_analysis::sdk::ContentAnalysisRequest& ChromeToAgent::request() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ChromeToAgent.request)
  return _internal_request();
}
inline void ChromeToAgent::unsafe_arena_set_allocated_request(
    ::content_analysis::sdk::ContentAnalysisRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ChromeToAgent.request)
}
inline ::content_analysis::sdk::ContentAnalysisRequest* ChromeToAgent::release_request() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::content_analysis::sdk::ContentAnalysisRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ContentAnalysisRequest* ChromeToAgent::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ChromeToAgent.request)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::content_analysis::sdk::ContentAnalysisRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ContentAnalysisRequest* ChromeToAgent::_internal_mutable_request() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::content_analysis::sdk::ContentAnalysisRequest* ChromeToAgent::mutable_request() {
  ::content_analysis::sdk::ContentAnalysisRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ChromeToAgent.request)
  return _msg;
}
inline void ChromeToAgent::set_allocated_request(::content_analysis::sdk::ContentAnalysisRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ChromeToAgent.request)
}

// optional .content_analysis.sdk.ContentAnalysisAcknowledgement ack = 2;
inline bool ChromeToAgent::_internal_has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ack_ != nullptr);
  return value;
}
inline bool ChromeToAgent::has_ack() const {
  return _internal_has_ack();
}
inline void ChromeToAgent::clear_ack() {
  if (_impl_.ack_ != nullptr) _impl_.ack_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::content_analysis::sdk::ContentAnalysisAcknowledgement& ChromeToAgent::_internal_ack() const {
  const ::content_analysis::sdk::ContentAnalysisAcknowledgement* p = _impl_.ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ContentAnalysisAcknowledgement&>(
      ::content_analysis::sdk::_ContentAnalysisAcknowledgement_default_instance_);
}
inline const ::content_analysis::sdk::ContentAnalysisAcknowledgement& ChromeToAgent::ack() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ChromeToAgent.ack)
  return _internal_ack();
}
inline void ChromeToAgent::unsafe_arena_set_allocated_ack(
    ::content_analysis::sdk::ContentAnalysisAcknowledgement* ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ack_);
  }
  _impl_.ack_ = ack;
  if (ack) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ChromeToAgent.ack)
}
inline ::content_analysis::sdk::ContentAnalysisAcknowledgement* ChromeToAgent::release_ack() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::content_analysis::sdk::ContentAnalysisAcknowledgement* temp = _impl_.ack_;
  _impl_.ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ContentAnalysisAcknowledgement* ChromeToAgent::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ChromeToAgent.ack)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::content_analysis::sdk::ContentAnalysisAcknowledgement* temp = _impl_.ack_;
  _impl_.ack_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ContentAnalysisAcknowledgement* ChromeToAgent::_internal_mutable_ack() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisAcknowledgement>(GetArenaForAllocation());
    _impl_.ack_ = p;
  }
  return _impl_.ack_;
}
inline ::content_analysis::sdk::ContentAnalysisAcknowledgement* ChromeToAgent::mutable_ack() {
  ::content_analysis::sdk::ContentAnalysisAcknowledgement* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ChromeToAgent.ack)
  return _msg;
}
inline void ChromeToAgent::set_allocated_ack(::content_analysis::sdk::ContentAnalysisAcknowledgement* ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ack_;
  }
  if (ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ack);
    if (message_arena != submessage_arena) {
      ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ack_ = ack;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ChromeToAgent.ack)
}

// optional .content_analysis.sdk.ContentAnalysisCancelRequests cancel = 3;
inline bool ChromeToAgent::_internal_has_cancel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cancel_ != nullptr);
  return value;
}
inline bool ChromeToAgent::has_cancel() const {
  return _internal_has_cancel();
}
inline void ChromeToAgent::clear_cancel() {
  if (_impl_.cancel_ != nullptr) _impl_.cancel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::content_analysis::sdk::ContentAnalysisCancelRequests& ChromeToAgent::_internal_cancel() const {
  const ::content_analysis::sdk::ContentAnalysisCancelRequests* p = _impl_.cancel_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ContentAnalysisCancelRequests&>(
      ::content_analysis::sdk::_ContentAnalysisCancelRequests_default_instance_);
}
inline const ::content_analysis::sdk::ContentAnalysisCancelRequests& ChromeToAgent::cancel() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.ChromeToAgent.cancel)
  return _internal_cancel();
}
inline void ChromeToAgent::unsafe_arena_set_allocated_cancel(
    ::content_analysis::sdk::ContentAnalysisCancelRequests* cancel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cancel_);
  }
  _impl_.cancel_ = cancel;
  if (cancel) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.ChromeToAgent.cancel)
}
inline ::content_analysis::sdk::ContentAnalysisCancelRequests* ChromeToAgent::release_cancel() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::content_analysis::sdk::ContentAnalysisCancelRequests* temp = _impl_.cancel_;
  _impl_.cancel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ContentAnalysisCancelRequests* ChromeToAgent::unsafe_arena_release_cancel() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.ChromeToAgent.cancel)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::content_analysis::sdk::ContentAnalysisCancelRequests* temp = _impl_.cancel_;
  _impl_.cancel_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ContentAnalysisCancelRequests* ChromeToAgent::_internal_mutable_cancel() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.cancel_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisCancelRequests>(GetArenaForAllocation());
    _impl_.cancel_ = p;
  }
  return _impl_.cancel_;
}
inline ::content_analysis::sdk::ContentAnalysisCancelRequests* ChromeToAgent::mutable_cancel() {
  ::content_analysis::sdk::ContentAnalysisCancelRequests* _msg = _internal_mutable_cancel();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.ChromeToAgent.cancel)
  return _msg;
}
inline void ChromeToAgent::set_allocated_cancel(::content_analysis::sdk::ContentAnalysisCancelRequests* cancel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cancel_;
  }
  if (cancel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cancel);
    if (message_arena != submessage_arena) {
      cancel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cancel_ = cancel;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.ChromeToAgent.cancel)
}

// -------------------------------------------------------------------

// AgentToChrome

// optional .content_analysis.sdk.ContentAnalysisResponse response = 1;
inline bool AgentToChrome::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline bool AgentToChrome::has_response() const {
  return _internal_has_response();
}
inline void AgentToChrome::clear_response() {
  if (_impl_.response_ != nullptr) _impl_.response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::content_analysis::sdk::ContentAnalysisResponse& AgentToChrome::_internal_response() const {
  const ::content_analysis::sdk::ContentAnalysisResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::content_analysis::sdk::ContentAnalysisResponse&>(
      ::content_analysis::sdk::_ContentAnalysisResponse_default_instance_);
}
inline const ::content_analysis::sdk::ContentAnalysisResponse& AgentToChrome::response() const {
  // @@protoc_insertion_point(field_get:content_analysis.sdk.AgentToChrome.response)
  return _internal_response();
}
inline void AgentToChrome::unsafe_arena_set_allocated_response(
    ::content_analysis::sdk::ContentAnalysisResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content_analysis.sdk.AgentToChrome.response)
}
inline ::content_analysis::sdk::ContentAnalysisResponse* AgentToChrome::release_response() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::content_analysis::sdk::ContentAnalysisResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content_analysis::sdk::ContentAnalysisResponse* AgentToChrome::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:content_analysis.sdk.AgentToChrome.response)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::content_analysis::sdk::ContentAnalysisResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::content_analysis::sdk::ContentAnalysisResponse* AgentToChrome::_internal_mutable_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::content_analysis::sdk::ContentAnalysisResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::content_analysis::sdk::ContentAnalysisResponse* AgentToChrome::mutable_response() {
  ::content_analysis::sdk::ContentAnalysisResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:content_analysis.sdk.AgentToChrome.response)
  return _msg;
}
inline void AgentToChrome::set_allocated_response(::content_analysis::sdk::ContentAnalysisResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:content_analysis.sdk.AgentToChrome.response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdk
}  // namespace content_analysis

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::content_analysis::sdk::ContentMetaData_PrintMetadata_PrinterType> : ::std::true_type {};
template <> struct is_proto_enum< ::content_analysis::sdk::ClientDownloadRequest_ResourceType> : ::std::true_type {};
template <> struct is_proto_enum< ::content_analysis::sdk::ContentAnalysisRequest_Reason> : ::std::true_type {};
template <> struct is_proto_enum< ::content_analysis::sdk::ContentAnalysisResponse_Result_TriggeredRule_Action> : ::std::true_type {};
template <> struct is_proto_enum< ::content_analysis::sdk::ContentAnalysisResponse_Result_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::content_analysis::sdk::ContentAnalysisAcknowledgement_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::content_analysis::sdk::ContentAnalysisAcknowledgement_FinalAction> : ::std::true_type {};
template <> struct is_proto_enum< ::content_analysis::sdk::AnalysisConnector> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_content_5fanalysis_2fsdk_2fanalysis_2eproto

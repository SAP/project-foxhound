// -*- mode: C++ -*-

/* This file is auto-generated by run_glean_parser.py.
   It is only for internal use by types in
   toolkit/components/glean/bindings/private */
{# The rendered source is autogenerated, but this
Jinja2 template is not. Please file bugs! #}

#include "mozilla/AppShutdown.h"
#include "mozilla/ClearOnShutdown.h"
#include "mozilla/glean/bindings/GleanJSMetricsLookup.h"
#include "mozilla/glean/bindings/jog/JOG.h"
#include "mozilla/Maybe.h"
#include "mozilla/Telemetry.h"
#include "nsIThread.h"
#include "nsThreadUtils.h"

#ifndef mozilla_glean_{{ probe_type }}GifftMap_h
#define mozilla_glean_{{ probe_type }}GifftMap_h

#define DYNAMIC_METRIC_BIT ({{runtime_metric_bit}})
#define GLEAN_METRIC_ID(id) ((id) & ((1ULL << {{id_bits}}) - 1))

namespace mozilla::glean {

using Telemetry::{{ probe_type }}ID;

{% if probe_type == "Scalar" %}
static inline bool IsSubmetricId(uint32_t aId) {
  // Submetrics have the 2^{{id_bits - id_signal_bits}} bit set.
  // (ID_BITS - ID_SIGNAL_BITS, keep it in sync with js.py).
  return (aId & (1 << {{id_bits - id_signal_bits}})) > 0;
}
{% endif %}

static{% if probe_type == "Event" or probe_type == "Scalar" %} inline{% endif %} Maybe<{{ probe_type }}ID> {{ probe_type }}IdForMetric(uint32_t aId) {
  switch(aId) {
{% for id, (mirror, metric_name) in ids_to_probes.items() %}
    case {{ id }}: { // {{ metric_name }}
      return Some({{ probe_type }}ID::{{ mirror }});
    }
{% endfor %}
    default: {
      if (MOZ_UNLIKELY(aId & (1 << DYNAMIC_METRIC_BIT))) {
        // Dynamic (runtime-registered) metric. Use its static (compiletime-
        // registered) metric's telemetry_mirror mapping.
        // ...if applicable.

        // Only JS can use dynamic (runtime-registered) metric ids.
        MOZ_ASSERT(NS_IsMainThread());

        auto metricName = JOG::GetMetricName(aId);
        // All of these should have names, but the storage only lasts until
        // XPCOMWillShutdown, so it might return `Nothing()`.
        if (metricName.isSome()) {
          auto maybeMetric = MetricByNameLookup(metricName.ref());
          if (maybeMetric.isSome()) {
            uint32_t staticId = GLEAN_METRIC_ID(maybeMetric.value());
            // Let's ensure we don't infinite loop, huh.
            MOZ_ASSERT(!(staticId & (1 << DYNAMIC_METRIC_BIT)));
            return {{ probe_type }}IdForMetric(staticId);
          }
        }
      }
      return Nothing();
    }
  }
}

}  // namespace mozilla::glean

#undef GLEAN_METRIC_ID
#undef DYNAMIC_METRIC_BIT

#endif  // mozilla_glean_{{ probe_type }}GifftMaps_h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#include "safebrowsing.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace mozilla {
namespace safebrowsing {
PROTOBUF_CONSTEXPR ThreatInfo::ThreatInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.threat_types_)*/{}
  , /*decltype(_impl_.platform_types_)*/{}
  , /*decltype(_impl_.threat_entries_)*/{}
  , /*decltype(_impl_.threat_entry_types_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThreatInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatInfoDefaultTypeInternal() {}
  union {
    ThreatInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatInfoDefaultTypeInternal _ThreatInfo_default_instance_;
PROTOBUF_CONSTEXPR ThreatMatch::ThreatMatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.threat_)*/nullptr
  , /*decltype(_impl_.threat_entry_metadata_)*/nullptr
  , /*decltype(_impl_.cache_duration_)*/nullptr
  , /*decltype(_impl_.threat_type_)*/0
  , /*decltype(_impl_.platform_type_)*/0
  , /*decltype(_impl_.threat_entry_type_)*/0} {}
struct ThreatMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatMatchDefaultTypeInternal() {}
  union {
    ThreatMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatMatchDefaultTypeInternal _ThreatMatch_default_instance_;
PROTOBUF_CONSTEXPR FindThreatMatchesRequest::FindThreatMatchesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_)*/nullptr
  , /*decltype(_impl_.threat_info_)*/nullptr} {}
struct FindThreatMatchesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindThreatMatchesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindThreatMatchesRequestDefaultTypeInternal() {}
  union {
    FindThreatMatchesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindThreatMatchesRequestDefaultTypeInternal _FindThreatMatchesRequest_default_instance_;
PROTOBUF_CONSTEXPR FindThreatMatchesResponse::FindThreatMatchesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.matches_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FindThreatMatchesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindThreatMatchesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindThreatMatchesResponseDefaultTypeInternal() {}
  union {
    FindThreatMatchesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindThreatMatchesResponseDefaultTypeInternal _FindThreatMatchesResponse_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.supported_compressions_)*/{}
  , /*decltype(_impl_.region_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_update_entries_)*/0
  , /*decltype(_impl_.max_database_entries_)*/0} {}
struct FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.state_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.constraints_)*/nullptr
  , /*decltype(_impl_.threat_type_)*/0
  , /*decltype(_impl_.platform_type_)*/0
  , /*decltype(_impl_.threat_entry_type_)*/0} {}
struct FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesRequest_ListUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.list_update_requests_)*/{}
  , /*decltype(_impl_.client_)*/nullptr
  , /*decltype(_impl_.chrome_client_info_)*/nullptr} {}
struct FetchThreatListUpdatesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesRequestDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.additions_)*/{}
  , /*decltype(_impl_.removals_)*/{}
  , /*decltype(_impl_.new_client_state_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.checksum_)*/nullptr
  , /*decltype(_impl_.threat_type_)*/0
  , /*decltype(_impl_.threat_entry_type_)*/0
  , /*decltype(_impl_.platform_type_)*/0
  , /*decltype(_impl_.response_type_)*/0} {}
struct FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesResponse_ListUpdateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.list_update_responses_)*/{}
  , /*decltype(_impl_.minimum_wait_duration_)*/nullptr} {}
struct FetchThreatListUpdatesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesResponseDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_default_instance_;
PROTOBUF_CONSTEXPR FindFullHashesRequest::FindFullHashesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_states_)*/{}
  , /*decltype(_impl_.client_)*/nullptr
  , /*decltype(_impl_.threat_info_)*/nullptr} {}
struct FindFullHashesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindFullHashesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindFullHashesRequestDefaultTypeInternal() {}
  union {
    FindFullHashesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindFullHashesRequestDefaultTypeInternal _FindFullHashesRequest_default_instance_;
PROTOBUF_CONSTEXPR FindFullHashesResponse::FindFullHashesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.matches_)*/{}
  , /*decltype(_impl_.minimum_wait_duration_)*/nullptr
  , /*decltype(_impl_.negative_cache_duration_)*/nullptr} {}
struct FindFullHashesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindFullHashesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindFullHashesResponseDefaultTypeInternal() {}
  union {
    FindFullHashesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindFullHashesResponseDefaultTypeInternal _FindFullHashesResponse_default_instance_;
PROTOBUF_CONSTEXPR ThreatHit_ThreatSource::ThreatHit_ThreatSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.remote_ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.referrer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct ThreatHit_ThreatSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatHit_ThreatSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatHit_ThreatSourceDefaultTypeInternal() {}
  union {
    ThreatHit_ThreatSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatHit_ThreatSourceDefaultTypeInternal _ThreatHit_ThreatSource_default_instance_;
PROTOBUF_CONSTEXPR ThreatHit_UserInfo::ThreatHit_UserInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.region_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ThreatHit_UserInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatHit_UserInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatHit_UserInfoDefaultTypeInternal() {}
  union {
    ThreatHit_UserInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatHit_UserInfoDefaultTypeInternal _ThreatHit_UserInfo_default_instance_;
PROTOBUF_CONSTEXPR ThreatHit::ThreatHit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resources_)*/{}
  , /*decltype(_impl_.entry_)*/nullptr
  , /*decltype(_impl_.client_info_)*/nullptr
  , /*decltype(_impl_.user_info_)*/nullptr
  , /*decltype(_impl_.threat_type_)*/0
  , /*decltype(_impl_.platform_type_)*/0} {}
struct ThreatHitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatHitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatHitDefaultTypeInternal() {}
  union {
    ThreatHit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatHitDefaultTypeInternal _ThreatHit_default_instance_;
PROTOBUF_CONSTEXPR ClientInfo::ClientInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ClientInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientInfoDefaultTypeInternal() {}
  union {
    ClientInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
PROTOBUF_CONSTEXPR ChromeClientInfo::ChromeClientInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reporting_population_)*/0} {}
struct ChromeClientInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeClientInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeClientInfoDefaultTypeInternal() {}
  union {
    ChromeClientInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeClientInfoDefaultTypeInternal _ChromeClientInfo_default_instance_;
PROTOBUF_CONSTEXPR Checksum::Checksum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sha256_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ChecksumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChecksumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChecksumDefaultTypeInternal() {}
  union {
    Checksum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChecksumDefaultTypeInternal _Checksum_default_instance_;
PROTOBUF_CONSTEXPR ThreatEntry::ThreatEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ThreatEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatEntryDefaultTypeInternal() {}
  union {
    ThreatEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatEntryDefaultTypeInternal _ThreatEntry_default_instance_;
PROTOBUF_CONSTEXPR ThreatEntrySet::ThreatEntrySet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.raw_hashes_)*/nullptr
  , /*decltype(_impl_.raw_indices_)*/nullptr
  , /*decltype(_impl_.rice_hashes_)*/nullptr
  , /*decltype(_impl_.rice_indices_)*/nullptr
  , /*decltype(_impl_.compression_type_)*/0} {}
struct ThreatEntrySetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatEntrySetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatEntrySetDefaultTypeInternal() {}
  union {
    ThreatEntrySet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatEntrySetDefaultTypeInternal _ThreatEntrySet_default_instance_;
PROTOBUF_CONSTEXPR RawIndices::RawIndices(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.indices_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RawIndicesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RawIndicesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RawIndicesDefaultTypeInternal() {}
  union {
    RawIndices _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RawIndicesDefaultTypeInternal _RawIndices_default_instance_;
PROTOBUF_CONSTEXPR RawHashes::RawHashes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.raw_hashes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.prefix_size_)*/0} {}
struct RawHashesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RawHashesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RawHashesDefaultTypeInternal() {}
  union {
    RawHashes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RawHashesDefaultTypeInternal _RawHashes_default_instance_;
PROTOBUF_CONSTEXPR RiceDeltaEncoding::RiceDeltaEncoding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.encoded_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_value_)*/int64_t{0}
  , /*decltype(_impl_.rice_parameter_)*/0
  , /*decltype(_impl_.num_entries_)*/0} {}
struct RiceDeltaEncodingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RiceDeltaEncodingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RiceDeltaEncodingDefaultTypeInternal() {}
  union {
    RiceDeltaEncoding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RiceDeltaEncodingDefaultTypeInternal _RiceDeltaEncoding_default_instance_;
PROTOBUF_CONSTEXPR ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ThreatEntryMetadata_MetadataEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatEntryMetadata_MetadataEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatEntryMetadata_MetadataEntryDefaultTypeInternal() {}
  union {
    ThreatEntryMetadata_MetadataEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatEntryMetadata_MetadataEntryDefaultTypeInternal _ThreatEntryMetadata_MetadataEntry_default_instance_;
PROTOBUF_CONSTEXPR ThreatEntryMetadata::ThreatEntryMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThreatEntryMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatEntryMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatEntryMetadataDefaultTypeInternal() {}
  union {
    ThreatEntryMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatEntryMetadataDefaultTypeInternal _ThreatEntryMetadata_default_instance_;
PROTOBUF_CONSTEXPR ThreatListDescriptor::ThreatListDescriptor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.threat_type_)*/0
  , /*decltype(_impl_.platform_type_)*/0
  , /*decltype(_impl_.threat_entry_type_)*/0} {}
struct ThreatListDescriptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatListDescriptorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatListDescriptorDefaultTypeInternal() {}
  union {
    ThreatListDescriptor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatListDescriptorDefaultTypeInternal _ThreatListDescriptor_default_instance_;
PROTOBUF_CONSTEXPR ListThreatListsResponse::ListThreatListsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.threat_lists_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListThreatListsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListThreatListsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListThreatListsResponseDefaultTypeInternal() {}
  union {
    ListThreatListsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListThreatListsResponseDefaultTypeInternal _ListThreatListsResponse_default_instance_;
PROTOBUF_CONSTEXPR Duration::Duration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seconds_)*/int64_t{0}
  , /*decltype(_impl_.nanos_)*/0} {}
struct DurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationDefaultTypeInternal() {}
  union {
    Duration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationDefaultTypeInternal _Duration_default_instance_;
}  // namespace safebrowsing
}  // namespace mozilla
namespace mozilla {
namespace safebrowsing {
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings[3] = {};

static const char FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names[] =
  "FULL_UPDATE"
  "PARTIAL_UPDATE"
  "RESPONSE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries[] = {
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 0, 11}, 2 },
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 11, 14}, 1 },
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 25, 25}, 0 },
};

static const int FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number[] = {
  2, // 0 -> RESPONSE_TYPE_UNSPECIFIED
  1, // 1 -> PARTIAL_UPDATE
  0, // 2 -> FULL_UPDATE
};

const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries,
          FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number,
          3, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries,
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings[idx].get();
}
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::RESPONSE_TYPE_UNSPECIFIED;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::PARTIAL_UPDATE;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::FULL_UPDATE;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MIN;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MAX;
constexpr int FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ThreatHit_ThreatSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatHit_ThreatSourceType_strings[5] = {};

static const char ThreatHit_ThreatSourceType_names[] =
  "MATCHING_URL"
  "TAB_REDIRECT"
  "TAB_RESOURCE"
  "TAB_URL"
  "THREAT_SOURCE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatHit_ThreatSourceType_entries[] = {
  { {ThreatHit_ThreatSourceType_names + 0, 12}, 1 },
  { {ThreatHit_ThreatSourceType_names + 12, 12}, 3 },
  { {ThreatHit_ThreatSourceType_names + 24, 12}, 4 },
  { {ThreatHit_ThreatSourceType_names + 36, 7}, 2 },
  { {ThreatHit_ThreatSourceType_names + 43, 30}, 0 },
};

static const int ThreatHit_ThreatSourceType_entries_by_number[] = {
  4, // 0 -> THREAT_SOURCE_TYPE_UNSPECIFIED
  0, // 1 -> MATCHING_URL
  3, // 2 -> TAB_URL
  1, // 3 -> TAB_REDIRECT
  2, // 4 -> TAB_RESOURCE
};

const std::string& ThreatHit_ThreatSourceType_Name(
    ThreatHit_ThreatSourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatHit_ThreatSourceType_entries,
          ThreatHit_ThreatSourceType_entries_by_number,
          5, ThreatHit_ThreatSourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatHit_ThreatSourceType_entries,
      ThreatHit_ThreatSourceType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatHit_ThreatSourceType_strings[idx].get();
}
bool ThreatHit_ThreatSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatHit_ThreatSourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatHit_ThreatSourceType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ThreatHit_ThreatSourceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ThreatHit_ThreatSourceType ThreatHit::THREAT_SOURCE_TYPE_UNSPECIFIED;
constexpr ThreatHit_ThreatSourceType ThreatHit::MATCHING_URL;
constexpr ThreatHit_ThreatSourceType ThreatHit::TAB_URL;
constexpr ThreatHit_ThreatSourceType ThreatHit::TAB_REDIRECT;
constexpr ThreatHit_ThreatSourceType ThreatHit::TAB_RESOURCE;
constexpr ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MIN;
constexpr ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MAX;
constexpr int ThreatHit::ThreatSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChromeClientInfo_SafeBrowsingReportingPopulation_strings[4] = {};

static const char ChromeClientInfo_SafeBrowsingReportingPopulation_names[] =
  "EXTENDED"
  "OPT_OUT"
  "SCOUT"
  "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChromeClientInfo_SafeBrowsingReportingPopulation_entries[] = {
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 0, 8}, 2 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 8, 7}, 1 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 15, 5}, 3 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 20, 11}, 0 },
};

static const int ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number[] = {
  3, // 0 -> UNSPECIFIED
  1, // 1 -> OPT_OUT
  0, // 2 -> EXTENDED
  2, // 3 -> SCOUT
};

const std::string& ChromeClientInfo_SafeBrowsingReportingPopulation_Name(
    ChromeClientInfo_SafeBrowsingReportingPopulation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ChromeClientInfo_SafeBrowsingReportingPopulation_entries,
          ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number,
          4, ChromeClientInfo_SafeBrowsingReportingPopulation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries,
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ChromeClientInfo_SafeBrowsingReportingPopulation_strings[idx].get();
}
bool ChromeClientInfo_SafeBrowsingReportingPopulation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChromeClientInfo_SafeBrowsingReportingPopulation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ChromeClientInfo_SafeBrowsingReportingPopulation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::UNSPECIFIED;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::OPT_OUT;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::EXTENDED;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SCOUT;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MIN;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MAX;
constexpr int ChromeClientInfo::SafeBrowsingReportingPopulation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ThreatType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatType_strings[12] = {};

static const char ThreatType_names[] =
  "API_ABUSE"
  "CLIENT_INCIDENT"
  "CSD_DOWNLOAD_WHITELIST"
  "CSD_WHITELIST"
  "MALICIOUS_BINARY"
  "MALWARE_THREAT"
  "POTENTIALLY_HARMFUL_APPLICATION"
  "SOCIAL_ENGINEERING"
  "SOCIAL_ENGINEERING_PUBLIC"
  "SUBRESOURCE_FILTER"
  "THREAT_TYPE_UNSPECIFIED"
  "UNWANTED_SOFTWARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatType_entries[] = {
  { {ThreatType_names + 0, 9}, 6 },
  { {ThreatType_names + 9, 15}, 10 },
  { {ThreatType_names + 24, 22}, 9 },
  { {ThreatType_names + 46, 13}, 8 },
  { {ThreatType_names + 59, 16}, 7 },
  { {ThreatType_names + 75, 14}, 1 },
  { {ThreatType_names + 89, 31}, 4 },
  { {ThreatType_names + 120, 18}, 5 },
  { {ThreatType_names + 138, 25}, 2 },
  { {ThreatType_names + 163, 18}, 13 },
  { {ThreatType_names + 181, 23}, 0 },
  { {ThreatType_names + 204, 17}, 3 },
};

static const int ThreatType_entries_by_number[] = {
  10, // 0 -> THREAT_TYPE_UNSPECIFIED
  5, // 1 -> MALWARE_THREAT
  8, // 2 -> SOCIAL_ENGINEERING_PUBLIC
  11, // 3 -> UNWANTED_SOFTWARE
  6, // 4 -> POTENTIALLY_HARMFUL_APPLICATION
  7, // 5 -> SOCIAL_ENGINEERING
  0, // 6 -> API_ABUSE
  4, // 7 -> MALICIOUS_BINARY
  3, // 8 -> CSD_WHITELIST
  2, // 9 -> CSD_DOWNLOAD_WHITELIST
  1, // 10 -> CLIENT_INCIDENT
  9, // 13 -> SUBRESOURCE_FILTER
};

const std::string& ThreatType_Name(
    ThreatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatType_entries,
          ThreatType_entries_by_number,
          12, ThreatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatType_entries,
      ThreatType_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatType_strings[idx].get();
}
bool ThreatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatType_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<ThreatType>(int_value);
  }
  return success;
}
bool PlatformType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlatformType_strings[9] = {};

static const char PlatformType_names[] =
  "ALL_PLATFORMS"
  "ANDROID_PLATFORM"
  "ANY_PLATFORM"
  "CHROME_PLATFORM"
  "IOS_PLATFORM"
  "LINUX_PLATFORM"
  "OSX_PLATFORM"
  "PLATFORM_TYPE_UNSPECIFIED"
  "WINDOWS_PLATFORM";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlatformType_entries[] = {
  { {PlatformType_names + 0, 13}, 7 },
  { {PlatformType_names + 13, 16}, 3 },
  { {PlatformType_names + 29, 12}, 6 },
  { {PlatformType_names + 41, 15}, 8 },
  { {PlatformType_names + 56, 12}, 5 },
  { {PlatformType_names + 68, 14}, 2 },
  { {PlatformType_names + 82, 12}, 4 },
  { {PlatformType_names + 94, 25}, 0 },
  { {PlatformType_names + 119, 16}, 1 },
};

static const int PlatformType_entries_by_number[] = {
  7, // 0 -> PLATFORM_TYPE_UNSPECIFIED
  8, // 1 -> WINDOWS_PLATFORM
  5, // 2 -> LINUX_PLATFORM
  1, // 3 -> ANDROID_PLATFORM
  6, // 4 -> OSX_PLATFORM
  4, // 5 -> IOS_PLATFORM
  2, // 6 -> ANY_PLATFORM
  0, // 7 -> ALL_PLATFORMS
  3, // 8 -> CHROME_PLATFORM
};

const std::string& PlatformType_Name(
    PlatformType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlatformType_entries,
          PlatformType_entries_by_number,
          9, PlatformType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlatformType_entries,
      PlatformType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlatformType_strings[idx].get();
}
bool PlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlatformType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlatformType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<PlatformType>(int_value);
  }
  return success;
}
bool CompressionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CompressionType_strings[3] = {};

static const char CompressionType_names[] =
  "COMPRESSION_TYPE_UNSPECIFIED"
  "RAW"
  "RICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CompressionType_entries[] = {
  { {CompressionType_names + 0, 28}, 0 },
  { {CompressionType_names + 28, 3}, 1 },
  { {CompressionType_names + 31, 4}, 2 },
};

static const int CompressionType_entries_by_number[] = {
  0, // 0 -> COMPRESSION_TYPE_UNSPECIFIED
  1, // 1 -> RAW
  2, // 2 -> RICE
};

const std::string& CompressionType_Name(
    CompressionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CompressionType_entries,
          CompressionType_entries_by_number,
          3, CompressionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CompressionType_entries,
      CompressionType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CompressionType_strings[idx].get();
}
bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CompressionType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CompressionType>(int_value);
  }
  return success;
}
bool ThreatEntryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatEntryType_strings[7] = {};

static const char ThreatEntryType_names[] =
  "CERT"
  "CHROME_EXTENSION"
  "EXECUTABLE"
  "FILENAME"
  "IP_RANGE"
  "THREAT_ENTRY_TYPE_UNSPECIFIED"
  "URL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatEntryType_entries[] = {
  { {ThreatEntryType_names + 0, 4}, 6 },
  { {ThreatEntryType_names + 4, 16}, 4 },
  { {ThreatEntryType_names + 20, 10}, 2 },
  { {ThreatEntryType_names + 30, 8}, 5 },
  { {ThreatEntryType_names + 38, 8}, 3 },
  { {ThreatEntryType_names + 46, 29}, 0 },
  { {ThreatEntryType_names + 75, 3}, 1 },
};

static const int ThreatEntryType_entries_by_number[] = {
  5, // 0 -> THREAT_ENTRY_TYPE_UNSPECIFIED
  6, // 1 -> URL
  2, // 2 -> EXECUTABLE
  4, // 3 -> IP_RANGE
  1, // 4 -> CHROME_EXTENSION
  3, // 5 -> FILENAME
  0, // 6 -> CERT
};

const std::string& ThreatEntryType_Name(
    ThreatEntryType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatEntryType_entries,
          ThreatEntryType_entries_by_number,
          7, ThreatEntryType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatEntryType_entries,
      ThreatEntryType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatEntryType_strings[idx].get();
}
bool ThreatEntryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatEntryType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatEntryType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ThreatEntryType>(int_value);
  }
  return success;
}

// ===================================================================

class ThreatInfo::_Internal {
 public:
};

ThreatInfo::ThreatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatInfo)
}
ThreatInfo::ThreatInfo(const ThreatInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.threat_types_){from._impl_.threat_types_}
    , decltype(_impl_.platform_types_){from._impl_.platform_types_}
    , decltype(_impl_.threat_entries_){from._impl_.threat_entries_}
    , decltype(_impl_.threat_entry_types_){from._impl_.threat_entry_types_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatInfo)
}

inline void ThreatInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.threat_types_){arena}
    , decltype(_impl_.platform_types_){arena}
    , decltype(_impl_.threat_entries_){arena}
    , decltype(_impl_.threat_entry_types_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ThreatInfo::~ThreatInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.threat_types_.~RepeatedField();
  _impl_.platform_types_.~RepeatedField();
  _impl_.threat_entries_.~RepeatedPtrField();
  _impl_.threat_entry_types_.~RepeatedField();
}

void ThreatInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.threat_types_.Clear();
  _impl_.platform_types_.Clear();
  _impl_.threat_entries_.Clear();
  _impl_.threat_entry_types_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
              _internal_add_threat_types(static_cast<::mozilla::safebrowsing::ThreatType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_threat_types(), ptr, ctx, ::mozilla::safebrowsing::ThreatType_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
              _internal_add_platform_types(static_cast<::mozilla::safebrowsing::PlatformType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_platform_types(), ptr, ctx, ::mozilla::safebrowsing::PlatformType_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_threat_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
              _internal_add_threat_entry_types(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_threat_entry_types(), ptr, ctx, ::mozilla::safebrowsing::ThreatEntryType_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
  for (int i = 0, n = this->_internal_threat_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_threat_types(i), target);
  }

  // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
  for (int i = 0, n = this->_internal_platform_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_platform_types(i), target);
  }

  // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_threat_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_threat_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
  for (int i = 0, n = this->_internal_threat_entry_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_threat_entry_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatInfo)
  return target;
}

size_t ThreatInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_threat_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_threat_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_platform_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_platform_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
  total_size += 1UL * this->_internal_threat_entries_size();
  for (const auto& msg : this->_impl_.threat_entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_threat_entry_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_threat_entry_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatInfo*>(
      &from));
}

void ThreatInfo::MergeFrom(const ThreatInfo& from) {
  ThreatInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.threat_types_.MergeFrom(from._impl_.threat_types_);
  _this->_impl_.platform_types_.MergeFrom(from._impl_.platform_types_);
  _this->_impl_.threat_entries_.MergeFrom(from._impl_.threat_entries_);
  _this->_impl_.threat_entry_types_.MergeFrom(from._impl_.threat_entry_types_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatInfo::CopyFrom(const ThreatInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatInfo::IsInitialized() const {
  return true;
}

void ThreatInfo::InternalSwap(ThreatInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.threat_types_.InternalSwap(&other->_impl_.threat_types_);
  _impl_.platform_types_.InternalSwap(&other->_impl_.platform_types_);
  _impl_.threat_entries_.InternalSwap(&other->_impl_.threat_entries_);
  _impl_.threat_entry_types_.InternalSwap(&other->_impl_.threat_entry_types_);
}

std::string ThreatInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatInfo";
}


// ===================================================================

class ThreatMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatMatch>()._impl_._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::mozilla::safebrowsing::ThreatEntry& threat(const ThreatMatch* msg);
  static void set_has_threat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ThreatEntryMetadata& threat_entry_metadata(const ThreatMatch* msg);
  static void set_has_threat_entry_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mozilla::safebrowsing::Duration& cache_duration(const ThreatMatch* msg);
  static void set_has_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::mozilla::safebrowsing::ThreatEntry&
ThreatMatch::_Internal::threat(const ThreatMatch* msg) {
  return *msg->_impl_.threat_;
}
const ::mozilla::safebrowsing::ThreatEntryMetadata&
ThreatMatch::_Internal::threat_entry_metadata(const ThreatMatch* msg) {
  return *msg->_impl_.threat_entry_metadata_;
}
const ::mozilla::safebrowsing::Duration&
ThreatMatch::_Internal::cache_duration(const ThreatMatch* msg) {
  return *msg->_impl_.cache_duration_;
}
ThreatMatch::ThreatMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatMatch)
}
ThreatMatch::ThreatMatch(const ThreatMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatMatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threat_){nullptr}
    , decltype(_impl_.threat_entry_metadata_){nullptr}
    , decltype(_impl_.cache_duration_){nullptr}
    , decltype(_impl_.threat_type_){}
    , decltype(_impl_.platform_type_){}
    , decltype(_impl_.threat_entry_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_threat()) {
    _this->_impl_.threat_ = new ::mozilla::safebrowsing::ThreatEntry(*from._impl_.threat_);
  }
  if (from._internal_has_threat_entry_metadata()) {
    _this->_impl_.threat_entry_metadata_ = new ::mozilla::safebrowsing::ThreatEntryMetadata(*from._impl_.threat_entry_metadata_);
  }
  if (from._internal_has_cache_duration()) {
    _this->_impl_.cache_duration_ = new ::mozilla::safebrowsing::Duration(*from._impl_.cache_duration_);
  }
  ::memcpy(&_impl_.threat_type_, &from._impl_.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.threat_entry_type_) -
    reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatMatch)
}

inline void ThreatMatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threat_){nullptr}
    , decltype(_impl_.threat_entry_metadata_){nullptr}
    , decltype(_impl_.cache_duration_){nullptr}
    , decltype(_impl_.threat_type_){0}
    , decltype(_impl_.platform_type_){0}
    , decltype(_impl_.threat_entry_type_){0}
  };
}

ThreatMatch::~ThreatMatch() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.threat_;
  if (this != internal_default_instance()) delete _impl_.threat_entry_metadata_;
  if (this != internal_default_instance()) delete _impl_.cache_duration_;
}

void ThreatMatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.threat_ != nullptr);
      _impl_.threat_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.threat_entry_metadata_ != nullptr);
      _impl_.threat_entry_metadata_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cache_duration_ != nullptr);
      _impl_.cache_duration_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.threat_entry_type_) -
        reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.threat_entry_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_entry_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Duration cache_duration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cache_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::threat(this),
        _Internal::threat(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::threat_entry_metadata(this),
        _Internal::threat_entry_metadata(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.Duration cache_duration = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::cache_duration(this),
        _Internal::cache_duration(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatMatch)
  return target;
}

size_t ThreatMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.threat_);
    }

    // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.threat_entry_metadata_);
    }

    // optional .mozilla.safebrowsing.Duration cache_duration = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cache_duration_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatMatch::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatMatch*>(
      &from));
}

void ThreatMatch::MergeFrom(const ThreatMatch& from) {
  ThreatMatch* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatMatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_threat()->::mozilla::safebrowsing::ThreatEntry::MergeFrom(
          from._internal_threat());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_threat_entry_metadata()->::mozilla::safebrowsing::ThreatEntryMetadata::MergeFrom(
          from._internal_threat_entry_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cache_duration()->::mozilla::safebrowsing::Duration::MergeFrom(
          from._internal_cache_duration());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.threat_type_ = from._impl_.threat_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.platform_type_ = from._impl_.platform_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.threat_entry_type_ = from._impl_.threat_entry_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatMatch::CopyFrom(const ThreatMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatMatch::IsInitialized() const {
  return true;
}

void ThreatMatch::InternalSwap(ThreatMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatMatch, _impl_.threat_entry_type_)
      + sizeof(ThreatMatch::_impl_.threat_entry_type_)
      - PROTOBUF_FIELD_OFFSET(ThreatMatch, _impl_.threat_)>(
          reinterpret_cast<char*>(&_impl_.threat_),
          reinterpret_cast<char*>(&other->_impl_.threat_));
}

std::string ThreatMatch::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatMatch";
}


// ===================================================================

class FindThreatMatchesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FindThreatMatchesRequest>()._impl_._has_bits_);
  static const ::mozilla::safebrowsing::ClientInfo& client(const FindThreatMatchesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ThreatInfo& threat_info(const FindThreatMatchesRequest* msg);
  static void set_has_threat_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::ClientInfo&
FindThreatMatchesRequest::_Internal::client(const FindThreatMatchesRequest* msg) {
  return *msg->_impl_.client_;
}
const ::mozilla::safebrowsing::ThreatInfo&
FindThreatMatchesRequest::_Internal::threat_info(const FindThreatMatchesRequest* msg) {
  return *msg->_impl_.threat_info_;
}
FindThreatMatchesRequest::FindThreatMatchesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FindThreatMatchesRequest)
}
FindThreatMatchesRequest::FindThreatMatchesRequest(const FindThreatMatchesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FindThreatMatchesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_){nullptr}
    , decltype(_impl_.threat_info_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client()) {
    _this->_impl_.client_ = new ::mozilla::safebrowsing::ClientInfo(*from._impl_.client_);
  }
  if (from._internal_has_threat_info()) {
    _this->_impl_.threat_info_ = new ::mozilla::safebrowsing::ThreatInfo(*from._impl_.threat_info_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindThreatMatchesRequest)
}

inline void FindThreatMatchesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_){nullptr}
    , decltype(_impl_.threat_info_){nullptr}
  };
}

FindThreatMatchesRequest::~FindThreatMatchesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindThreatMatchesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindThreatMatchesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.client_;
  if (this != internal_default_instance()) delete _impl_.threat_info_;
}

void FindThreatMatchesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FindThreatMatchesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.client_ != nullptr);
      _impl_.client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.threat_info_ != nullptr);
      _impl_.threat_info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FindThreatMatchesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindThreatMatchesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client(this),
        _Internal::client(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::threat_info(this),
        _Internal::threat_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FindThreatMatchesRequest)
  return target;
}

size_t FindThreatMatchesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_);
    }

    // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.threat_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindThreatMatchesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FindThreatMatchesRequest*>(
      &from));
}

void FindThreatMatchesRequest::MergeFrom(const FindThreatMatchesRequest& from) {
  FindThreatMatchesRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(
          from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_threat_info()->::mozilla::safebrowsing::ThreatInfo::MergeFrom(
          from._internal_threat_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FindThreatMatchesRequest::CopyFrom(const FindThreatMatchesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindThreatMatchesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindThreatMatchesRequest::IsInitialized() const {
  return true;
}

void FindThreatMatchesRequest::InternalSwap(FindThreatMatchesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FindThreatMatchesRequest, _impl_.threat_info_)
      + sizeof(FindThreatMatchesRequest::_impl_.threat_info_)
      - PROTOBUF_FIELD_OFFSET(FindThreatMatchesRequest, _impl_.client_)>(
          reinterpret_cast<char*>(&_impl_.client_),
          reinterpret_cast<char*>(&other->_impl_.client_));
}

std::string FindThreatMatchesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FindThreatMatchesRequest";
}


// ===================================================================

class FindThreatMatchesResponse::_Internal {
 public:
};

FindThreatMatchesResponse::FindThreatMatchesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FindThreatMatchesResponse)
}
FindThreatMatchesResponse::FindThreatMatchesResponse(const FindThreatMatchesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FindThreatMatchesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.matches_){from._impl_.matches_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindThreatMatchesResponse)
}

inline void FindThreatMatchesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.matches_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FindThreatMatchesResponse::~FindThreatMatchesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindThreatMatchesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindThreatMatchesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matches_.~RepeatedPtrField();
}

void FindThreatMatchesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FindThreatMatchesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matches_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FindThreatMatchesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindThreatMatchesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matches_size()); i < n; i++) {
    const auto& repfield = this->_internal_matches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FindThreatMatchesResponse)
  return target;
}

size_t FindThreatMatchesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->_impl_.matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindThreatMatchesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FindThreatMatchesResponse*>(
      &from));
}

void FindThreatMatchesResponse::MergeFrom(const FindThreatMatchesResponse& from) {
  FindThreatMatchesResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matches_.MergeFrom(from._impl_.matches_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FindThreatMatchesResponse::CopyFrom(const FindThreatMatchesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindThreatMatchesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindThreatMatchesResponse::IsInitialized() const {
  return true;
}

void FindThreatMatchesResponse::InternalSwap(FindThreatMatchesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.matches_.InternalSwap(&other->_impl_.matches_);
}

std::string FindThreatMatchesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FindThreatMatchesResponse";
}


// ===================================================================

class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>()._impl_._has_bits_);
  static void set_has_max_update_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_database_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.supported_compressions_){from._impl_.supported_compressions_}
    , decltype(_impl_.region_){}
    , decltype(_impl_.max_update_entries_){}
    , decltype(_impl_.max_database_entries_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_region()) {
    _this->_impl_.region_.Set(from._internal_region(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.max_update_entries_, &from._impl_.max_update_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_database_entries_) -
    reinterpret_cast<char*>(&_impl_.max_update_entries_)) + sizeof(_impl_.max_database_entries_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}

inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.supported_compressions_){arena}
    , decltype(_impl_.region_){}
    , decltype(_impl_.max_update_entries_){0}
    , decltype(_impl_.max_database_entries_){0}
  };
  _impl_.region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.supported_compressions_.~RepeatedField();
  _impl_.region_.Destroy();
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.supported_compressions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.region_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.max_update_entries_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_database_entries_) -
        reinterpret_cast<char*>(&_impl_.max_update_entries_)) + sizeof(_impl_.max_database_entries_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 max_update_entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_max_update_entries(&has_bits);
          _impl_.max_update_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_database_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_max_database_entries(&has_bits);
          _impl_.max_database_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string region = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_region();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::CompressionType_IsValid(val))) {
              _internal_add_supported_compressions(static_cast<::mozilla::safebrowsing::CompressionType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_supported_compressions(), ptr, ctx, ::mozilla::safebrowsing::CompressionType_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 max_update_entries = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_update_entries(), target);
  }

  // optional int32 max_database_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_max_database_entries(), target);
  }

  // optional string region = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_region(), target);
  }

  // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
  for (int i = 0, n = this->_internal_supported_compressions_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_supported_compressions(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  return target;
}

size_t FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_compressions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_supported_compressions(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string region = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region());
    }

    // optional int32 max_update_entries = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_update_entries());
    }

    // optional int32 max_database_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_database_entries());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
      &from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.supported_compressions_.MergeFrom(from._impl_.supported_compressions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_region(from._internal_region());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.max_update_entries_ = from._impl_.max_update_entries_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_database_entries_ = from._impl_.max_database_entries_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.supported_compressions_.InternalSwap(&other->_impl_.supported_compressions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.region_, lhs_arena,
      &other->_impl_.region_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints, _impl_.max_database_entries_)
      + sizeof(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_impl_.max_database_entries_)
      - PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints, _impl_.max_update_entries_)>(
          reinterpret_cast<char*>(&_impl_.max_update_entries_),
          reinterpret_cast<char*>(&other->_impl_.max_update_entries_));
}

std::string FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints";
}


// ===================================================================

class FetchThreatListUpdatesRequest_ListUpdateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest_ListUpdateRequest>()._impl_._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest* msg);
  static void set_has_constraints(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&
FetchThreatListUpdatesRequest_ListUpdateRequest::_Internal::constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest* msg) {
  return *msg->_impl_.constraints_;
}
FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}
FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FetchThreatListUpdatesRequest_ListUpdateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){}
    , decltype(_impl_.constraints_){nullptr}
    , decltype(_impl_.threat_type_){}
    , decltype(_impl_.platform_type_){}
    , decltype(_impl_.threat_entry_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_state()) {
    _this->_impl_.state_.Set(from._internal_state(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_constraints()) {
    _this->_impl_.constraints_ = new ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(*from._impl_.constraints_);
  }
  ::memcpy(&_impl_.threat_type_, &from._impl_.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.threat_entry_type_) -
    reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}

inline void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){}
    , decltype(_impl_.constraints_){nullptr}
    , decltype(_impl_.threat_type_){0}
    , decltype(_impl_.platform_type_){0}
    , decltype(_impl_.threat_entry_type_){0}
  };
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FetchThreatListUpdatesRequest_ListUpdateRequest::~FetchThreatListUpdatesRequest_ListUpdateRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.state_.Destroy();
  if (this != internal_default_instance()) delete _impl_.constraints_;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.constraints_ != nullptr);
      _impl_.constraints_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.threat_entry_type_) -
        reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.threat_entry_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesRequest_ListUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_constraints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesRequest_ListUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional bytes state = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_state(), target);
  }

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::constraints(this),
        _Internal::constraints(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  return target;
}

size_t FetchThreatListUpdatesRequest_ListUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes state = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_state());
    }

    // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraints_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesRequest_ListUpdateRequest*>(
      &from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
  FetchThreatListUpdatesRequest_ListUpdateRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_state(from._internal_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_constraints()->::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(
          from._internal_constraints());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.threat_type_ = from._impl_.threat_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.platform_type_ = from._impl_.platform_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.threat_entry_type_ = from._impl_.threat_entry_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.state_, lhs_arena,
      &other->_impl_.state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest_ListUpdateRequest, _impl_.threat_entry_type_)
      + sizeof(FetchThreatListUpdatesRequest_ListUpdateRequest::_impl_.threat_entry_type_)
      - PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest_ListUpdateRequest, _impl_.constraints_)>(
          reinterpret_cast<char*>(&_impl_.constraints_),
          reinterpret_cast<char*>(&other->_impl_.constraints_));
}

std::string FetchThreatListUpdatesRequest_ListUpdateRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest";
}


// ===================================================================

class FetchThreatListUpdatesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest>()._impl_._has_bits_);
  static const ::mozilla::safebrowsing::ClientInfo& client(const FetchThreatListUpdatesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ChromeClientInfo& chrome_client_info(const FetchThreatListUpdatesRequest* msg);
  static void set_has_chrome_client_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::ClientInfo&
FetchThreatListUpdatesRequest::_Internal::client(const FetchThreatListUpdatesRequest* msg) {
  return *msg->_impl_.client_;
}
const ::mozilla::safebrowsing::ChromeClientInfo&
FetchThreatListUpdatesRequest::_Internal::chrome_client_info(const FetchThreatListUpdatesRequest* msg) {
  return *msg->_impl_.chrome_client_info_;
}
FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
}
FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FetchThreatListUpdatesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.list_update_requests_){from._impl_.list_update_requests_}
    , decltype(_impl_.client_){nullptr}
    , decltype(_impl_.chrome_client_info_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client()) {
    _this->_impl_.client_ = new ::mozilla::safebrowsing::ClientInfo(*from._impl_.client_);
  }
  if (from._internal_has_chrome_client_info()) {
    _this->_impl_.chrome_client_info_ = new ::mozilla::safebrowsing::ChromeClientInfo(*from._impl_.chrome_client_info_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
}

inline void FetchThreatListUpdatesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.list_update_requests_){arena}
    , decltype(_impl_.client_){nullptr}
    , decltype(_impl_.chrome_client_info_){nullptr}
  };
}

FetchThreatListUpdatesRequest::~FetchThreatListUpdatesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.list_update_requests_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.client_;
  if (this != internal_default_instance()) delete _impl_.chrome_client_info_;
}

void FetchThreatListUpdatesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FetchThreatListUpdatesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.list_update_requests_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.client_ != nullptr);
      _impl_.client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.chrome_client_info_ != nullptr);
      _impl_.chrome_client_info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list_update_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_client_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client(this),
        _Internal::client(this).GetCachedSize(), target, stream);
  }

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_list_update_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_list_update_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::chrome_client_info(this),
        _Internal::chrome_client_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  return target;
}

size_t FetchThreatListUpdatesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  total_size += 1UL * this->_internal_list_update_requests_size();
  for (const auto& msg : this->_impl_.list_update_requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_);
    }

    // optional .mozilla.safebrowsing.ChromeClientInfo chrome_client_info = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chrome_client_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesRequest*>(
      &from));
}

void FetchThreatListUpdatesRequest::MergeFrom(const FetchThreatListUpdatesRequest& from) {
  FetchThreatListUpdatesRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.list_update_requests_.MergeFrom(from._impl_.list_update_requests_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(
          from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_chrome_client_info()->::mozilla::safebrowsing::ChromeClientInfo::MergeFrom(
          from._internal_chrome_client_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesRequest::CopyFrom(const FetchThreatListUpdatesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest::InternalSwap(FetchThreatListUpdatesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.list_update_requests_.InternalSwap(&other->_impl_.list_update_requests_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest, _impl_.chrome_client_info_)
      + sizeof(FetchThreatListUpdatesRequest::_impl_.chrome_client_info_)
      - PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest, _impl_.client_)>(
          reinterpret_cast<char*>(&_impl_.client_),
          reinterpret_cast<char*>(&other->_impl_.client_));
}

std::string FetchThreatListUpdatesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesRequest";
}


// ===================================================================

class FetchThreatListUpdatesResponse_ListUpdateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesResponse_ListUpdateResponse>()._impl_._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_response_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_new_client_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::Checksum& checksum(const FetchThreatListUpdatesResponse_ListUpdateResponse* msg);
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::Checksum&
FetchThreatListUpdatesResponse_ListUpdateResponse::_Internal::checksum(const FetchThreatListUpdatesResponse_ListUpdateResponse* msg) {
  return *msg->_impl_.checksum_;
}
FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}
FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FetchThreatListUpdatesResponse_ListUpdateResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.additions_){from._impl_.additions_}
    , decltype(_impl_.removals_){from._impl_.removals_}
    , decltype(_impl_.new_client_state_){}
    , decltype(_impl_.checksum_){nullptr}
    , decltype(_impl_.threat_type_){}
    , decltype(_impl_.threat_entry_type_){}
    , decltype(_impl_.platform_type_){}
    , decltype(_impl_.response_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.new_client_state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_client_state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_client_state()) {
    _this->_impl_.new_client_state_.Set(from._internal_new_client_state(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_checksum()) {
    _this->_impl_.checksum_ = new ::mozilla::safebrowsing::Checksum(*from._impl_.checksum_);
  }
  ::memcpy(&_impl_.threat_type_, &from._impl_.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.response_type_) -
    reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.response_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}

inline void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.additions_){arena}
    , decltype(_impl_.removals_){arena}
    , decltype(_impl_.new_client_state_){}
    , decltype(_impl_.checksum_){nullptr}
    , decltype(_impl_.threat_type_){0}
    , decltype(_impl_.threat_entry_type_){0}
    , decltype(_impl_.platform_type_){0}
    , decltype(_impl_.response_type_){0}
  };
  _impl_.new_client_state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_client_state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FetchThreatListUpdatesResponse_ListUpdateResponse::~FetchThreatListUpdatesResponse_ListUpdateResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additions_.~RepeatedPtrField();
  _impl_.removals_.~RepeatedPtrField();
  _impl_.new_client_state_.Destroy();
  if (this != internal_default_instance()) delete _impl_.checksum_;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additions_.Clear();
  _impl_.removals_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.new_client_state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.checksum_ != nullptr);
      _impl_.checksum_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.response_type_) -
        reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.response_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesResponse_ListUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(val))) {
            _internal_set_response_type(static_cast<::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_removals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes new_client_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_new_client_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Checksum checksum = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_checksum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesResponse_ListUpdateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_threat_entry_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_platform_type(), target);
  }

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_response_type(), target);
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additions_size()); i < n; i++) {
    const auto& repfield = this->_internal_additions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_removals_size()); i < n; i++) {
    const auto& repfield = this->_internal_removals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes new_client_state = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_new_client_state(), target);
  }

  // optional .mozilla.safebrowsing.Checksum checksum = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::checksum(this),
        _Internal::checksum(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  return target;
}

size_t FetchThreatListUpdatesResponse_ListUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
  total_size += 1UL * this->_internal_additions_size();
  for (const auto& msg : this->_impl_.additions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
  total_size += 1UL * this->_internal_removals_size();
  for (const auto& msg : this->_impl_.removals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes new_client_state = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_client_state());
    }

    // optional .mozilla.safebrowsing.Checksum checksum = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.checksum_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_response_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesResponse_ListUpdateResponse*>(
      &from));
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
  FetchThreatListUpdatesResponse_ListUpdateResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additions_.MergeFrom(from._impl_.additions_);
  _this->_impl_.removals_.MergeFrom(from._impl_.removals_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_new_client_state(from._internal_new_client_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_checksum()->::mozilla::safebrowsing::Checksum::MergeFrom(
          from._internal_checksum());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.threat_type_ = from._impl_.threat_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.threat_entry_type_ = from._impl_.threat_entry_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.platform_type_ = from._impl_.platform_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.response_type_ = from._impl_.response_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesResponse_ListUpdateResponse::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::InternalSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.additions_.InternalSwap(&other->_impl_.additions_);
  _impl_.removals_.InternalSwap(&other->_impl_.removals_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_client_state_, lhs_arena,
      &other->_impl_.new_client_state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesResponse_ListUpdateResponse, _impl_.response_type_)
      + sizeof(FetchThreatListUpdatesResponse_ListUpdateResponse::_impl_.response_type_)
      - PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesResponse_ListUpdateResponse, _impl_.checksum_)>(
          reinterpret_cast<char*>(&_impl_.checksum_),
          reinterpret_cast<char*>(&other->_impl_.checksum_));
}

std::string FetchThreatListUpdatesResponse_ListUpdateResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse";
}


// ===================================================================

class FetchThreatListUpdatesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesResponse>()._impl_._has_bits_);
  static const ::mozilla::safebrowsing::Duration& minimum_wait_duration(const FetchThreatListUpdatesResponse* msg);
  static void set_has_minimum_wait_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::mozilla::safebrowsing::Duration&
FetchThreatListUpdatesResponse::_Internal::minimum_wait_duration(const FetchThreatListUpdatesResponse* msg) {
  return *msg->_impl_.minimum_wait_duration_;
}
FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
}
FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FetchThreatListUpdatesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.list_update_responses_){from._impl_.list_update_responses_}
    , decltype(_impl_.minimum_wait_duration_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_minimum_wait_duration()) {
    _this->_impl_.minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration(*from._impl_.minimum_wait_duration_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
}

inline void FetchThreatListUpdatesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.list_update_responses_){arena}
    , decltype(_impl_.minimum_wait_duration_){nullptr}
  };
}

FetchThreatListUpdatesResponse::~FetchThreatListUpdatesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.list_update_responses_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.minimum_wait_duration_;
}

void FetchThreatListUpdatesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FetchThreatListUpdatesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.list_update_responses_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.minimum_wait_duration_ != nullptr);
    _impl_.minimum_wait_duration_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list_update_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minimum_wait_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_list_update_responses_size()); i < n; i++) {
    const auto& repfield = this->_internal_list_update_responses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::minimum_wait_duration(this),
        _Internal::minimum_wait_duration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  return target;
}

size_t FetchThreatListUpdatesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  total_size += 1UL * this->_internal_list_update_responses_size();
  for (const auto& msg : this->_impl_.list_update_responses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.minimum_wait_duration_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesResponse*>(
      &from));
}

void FetchThreatListUpdatesResponse::MergeFrom(const FetchThreatListUpdatesResponse& from) {
  FetchThreatListUpdatesResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.list_update_responses_.MergeFrom(from._impl_.list_update_responses_);
  if (from._internal_has_minimum_wait_duration()) {
    _this->_internal_mutable_minimum_wait_duration()->::mozilla::safebrowsing::Duration::MergeFrom(
        from._internal_minimum_wait_duration());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesResponse::CopyFrom(const FetchThreatListUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesResponse::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesResponse::InternalSwap(FetchThreatListUpdatesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.list_update_responses_.InternalSwap(&other->_impl_.list_update_responses_);
  swap(_impl_.minimum_wait_duration_, other->_impl_.minimum_wait_duration_);
}

std::string FetchThreatListUpdatesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FetchThreatListUpdatesResponse";
}


// ===================================================================

class FindFullHashesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FindFullHashesRequest>()._impl_._has_bits_);
  static const ::mozilla::safebrowsing::ClientInfo& client(const FindFullHashesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ThreatInfo& threat_info(const FindFullHashesRequest* msg);
  static void set_has_threat_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::ClientInfo&
FindFullHashesRequest::_Internal::client(const FindFullHashesRequest* msg) {
  return *msg->_impl_.client_;
}
const ::mozilla::safebrowsing::ThreatInfo&
FindFullHashesRequest::_Internal::threat_info(const FindFullHashesRequest* msg) {
  return *msg->_impl_.threat_info_;
}
FindFullHashesRequest::FindFullHashesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FindFullHashesRequest)
}
FindFullHashesRequest::FindFullHashesRequest(const FindFullHashesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FindFullHashesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_states_){from._impl_.client_states_}
    , decltype(_impl_.client_){nullptr}
    , decltype(_impl_.threat_info_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client()) {
    _this->_impl_.client_ = new ::mozilla::safebrowsing::ClientInfo(*from._impl_.client_);
  }
  if (from._internal_has_threat_info()) {
    _this->_impl_.threat_info_ = new ::mozilla::safebrowsing::ThreatInfo(*from._impl_.threat_info_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindFullHashesRequest)
}

inline void FindFullHashesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_states_){arena}
    , decltype(_impl_.client_){nullptr}
    , decltype(_impl_.threat_info_){nullptr}
  };
}

FindFullHashesRequest::~FindFullHashesRequest() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindFullHashesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindFullHashesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_states_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.client_;
  if (this != internal_default_instance()) delete _impl_.threat_info_;
}

void FindFullHashesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FindFullHashesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindFullHashesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.client_states_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.client_ != nullptr);
      _impl_.client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.threat_info_ != nullptr);
      _impl_.threat_info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FindFullHashesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes client_states = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_client_states();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindFullHashesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FindFullHashesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client(this),
        _Internal::client(this).GetCachedSize(), target, stream);
  }

  // repeated bytes client_states = 2;
  for (int i = 0, n = this->_internal_client_states_size(); i < n; i++) {
    const auto& s = this->_internal_client_states(i);
    target = stream->WriteBytes(2, s, target);
  }

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::threat_info(this),
        _Internal::threat_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FindFullHashesRequest)
  return target;
}

size_t FindFullHashesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindFullHashesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes client_states = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.client_states_.size());
  for (int i = 0, n = _impl_.client_states_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.client_states_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mozilla.safebrowsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_);
    }

    // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.threat_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindFullHashesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FindFullHashesRequest*>(
      &from));
}

void FindFullHashesRequest::MergeFrom(const FindFullHashesRequest& from) {
  FindFullHashesRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindFullHashesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.client_states_.MergeFrom(from._impl_.client_states_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_client()->::mozilla::safebrowsing::ClientInfo::MergeFrom(
          from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_threat_info()->::mozilla::safebrowsing::ThreatInfo::MergeFrom(
          from._internal_threat_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FindFullHashesRequest::CopyFrom(const FindFullHashesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindFullHashesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindFullHashesRequest::IsInitialized() const {
  return true;
}

void FindFullHashesRequest::InternalSwap(FindFullHashesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.client_states_.InternalSwap(&other->_impl_.client_states_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FindFullHashesRequest, _impl_.threat_info_)
      + sizeof(FindFullHashesRequest::_impl_.threat_info_)
      - PROTOBUF_FIELD_OFFSET(FindFullHashesRequest, _impl_.client_)>(
          reinterpret_cast<char*>(&_impl_.client_),
          reinterpret_cast<char*>(&other->_impl_.client_));
}

std::string FindFullHashesRequest::GetTypeName() const {
  return "mozilla.safebrowsing.FindFullHashesRequest";
}


// ===================================================================

class FindFullHashesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FindFullHashesResponse>()._impl_._has_bits_);
  static const ::mozilla::safebrowsing::Duration& minimum_wait_duration(const FindFullHashesResponse* msg);
  static void set_has_minimum_wait_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::Duration& negative_cache_duration(const FindFullHashesResponse* msg);
  static void set_has_negative_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mozilla::safebrowsing::Duration&
FindFullHashesResponse::_Internal::minimum_wait_duration(const FindFullHashesResponse* msg) {
  return *msg->_impl_.minimum_wait_duration_;
}
const ::mozilla::safebrowsing::Duration&
FindFullHashesResponse::_Internal::negative_cache_duration(const FindFullHashesResponse* msg) {
  return *msg->_impl_.negative_cache_duration_;
}
FindFullHashesResponse::FindFullHashesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.FindFullHashesResponse)
}
FindFullHashesResponse::FindFullHashesResponse(const FindFullHashesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FindFullHashesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matches_){from._impl_.matches_}
    , decltype(_impl_.minimum_wait_duration_){nullptr}
    , decltype(_impl_.negative_cache_duration_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_minimum_wait_duration()) {
    _this->_impl_.minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration(*from._impl_.minimum_wait_duration_);
  }
  if (from._internal_has_negative_cache_duration()) {
    _this->_impl_.negative_cache_duration_ = new ::mozilla::safebrowsing::Duration(*from._impl_.negative_cache_duration_);
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.FindFullHashesResponse)
}

inline void FindFullHashesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.matches_){arena}
    , decltype(_impl_.minimum_wait_duration_){nullptr}
    , decltype(_impl_.negative_cache_duration_){nullptr}
  };
}

FindFullHashesResponse::~FindFullHashesResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.FindFullHashesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindFullHashesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matches_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.minimum_wait_duration_;
  if (this != internal_default_instance()) delete _impl_.negative_cache_duration_;
}

void FindFullHashesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FindFullHashesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.FindFullHashesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matches_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.minimum_wait_duration_ != nullptr);
      _impl_.minimum_wait_duration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.negative_cache_duration_ != nullptr);
      _impl_.negative_cache_duration_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FindFullHashesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minimum_wait_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_negative_cache_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindFullHashesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.FindFullHashesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matches_size()); i < n; i++) {
    const auto& repfield = this->_internal_matches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::minimum_wait_duration(this),
        _Internal::minimum_wait_duration(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::negative_cache_duration(this),
        _Internal::negative_cache_duration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.FindFullHashesResponse)
  return target;
}

size_t FindFullHashesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.FindFullHashesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->_impl_.matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.minimum_wait_duration_);
    }

    // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.negative_cache_duration_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindFullHashesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FindFullHashesResponse*>(
      &from));
}

void FindFullHashesResponse::MergeFrom(const FindFullHashesResponse& from) {
  FindFullHashesResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.FindFullHashesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matches_.MergeFrom(from._impl_.matches_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_minimum_wait_duration()->::mozilla::safebrowsing::Duration::MergeFrom(
          from._internal_minimum_wait_duration());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_negative_cache_duration()->::mozilla::safebrowsing::Duration::MergeFrom(
          from._internal_negative_cache_duration());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FindFullHashesResponse::CopyFrom(const FindFullHashesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.FindFullHashesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindFullHashesResponse::IsInitialized() const {
  return true;
}

void FindFullHashesResponse::InternalSwap(FindFullHashesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.matches_.InternalSwap(&other->_impl_.matches_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FindFullHashesResponse, _impl_.negative_cache_duration_)
      + sizeof(FindFullHashesResponse::_impl_.negative_cache_duration_)
      - PROTOBUF_FIELD_OFFSET(FindFullHashesResponse, _impl_.minimum_wait_duration_)>(
          reinterpret_cast<char*>(&_impl_.minimum_wait_duration_),
          reinterpret_cast<char*>(&other->_impl_.minimum_wait_duration_));
}

std::string FindFullHashesResponse::GetTypeName() const {
  return "mozilla.safebrowsing.FindFullHashesResponse";
}


// ===================================================================

class ThreatHit_ThreatSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatHit_ThreatSource>()._impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remote_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_referrer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ThreatHit_ThreatSource::ThreatHit_ThreatSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
}
ThreatHit_ThreatSource::ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatHit_ThreatSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.remote_ip_){}
    , decltype(_impl_.referrer_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.remote_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_remote_ip()) {
    _this->_impl_.remote_ip_.Set(from._internal_remote_ip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.referrer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_referrer()) {
    _this->_impl_.referrer_.Set(from._internal_referrer(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
}

inline void ThreatHit_ThreatSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.remote_ip_){}
    , decltype(_impl_.referrer_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.remote_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referrer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ThreatHit_ThreatSource::~ThreatHit_ThreatSource() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit.ThreatSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatHit_ThreatSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
  _impl_.remote_ip_.Destroy();
  _impl_.referrer_.Destroy();
}

void ThreatHit_ThreatSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatHit_ThreatSource::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.remote_ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.referrer_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatHit_ThreatSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatHit_ThreatSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::mozilla::safebrowsing::ThreatHit_ThreatSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string remote_ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_remote_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string referrer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_referrer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatHit_ThreatSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional string remote_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_remote_ip(), target);
  }

  // optional string referrer = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_referrer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatHit.ThreatSource)
  return target;
}

size_t ThreatHit_ThreatSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string remote_ip = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_remote_ip());
    }

    // optional string referrer = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer());
    }

    // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatHit_ThreatSource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatHit_ThreatSource*>(
      &from));
}

void ThreatHit_ThreatSource::MergeFrom(const ThreatHit_ThreatSource& from) {
  ThreatHit_ThreatSource* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_remote_ip(from._internal_remote_ip());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_referrer(from._internal_referrer());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatHit_ThreatSource::CopyFrom(const ThreatHit_ThreatSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit.ThreatSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit_ThreatSource::IsInitialized() const {
  return true;
}

void ThreatHit_ThreatSource::InternalSwap(ThreatHit_ThreatSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_ip_, lhs_arena,
      &other->_impl_.remote_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.referrer_, lhs_arena,
      &other->_impl_.referrer_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string ThreatHit_ThreatSource::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit.ThreatSource";
}


// ===================================================================

class ThreatHit_UserInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatHit_UserInfo>()._impl_._has_bits_);
  static void set_has_region_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThreatHit_UserInfo::ThreatHit_UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatHit.UserInfo)
}
ThreatHit_UserInfo::ThreatHit_UserInfo(const ThreatHit_UserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatHit_UserInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_code_){}
    , decltype(_impl_.user_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.region_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_region_code()) {
    _this->_impl_.region_code_.Set(from._internal_region_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_id()) {
    _this->_impl_.user_id_.Set(from._internal_user_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit.UserInfo)
}

inline void ThreatHit_UserInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.region_code_){}
    , decltype(_impl_.user_id_){}
  };
  _impl_.region_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ThreatHit_UserInfo::~ThreatHit_UserInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit.UserInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatHit_UserInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.region_code_.Destroy();
  _impl_.user_id_.Destroy();
}

void ThreatHit_UserInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatHit_UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.region_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.user_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatHit_UserInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string region_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_region_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes user_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatHit_UserInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string region_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_region_code(), target);
  }

  // optional bytes user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatHit.UserInfo)
  return target;
}

size_t ThreatHit_UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string region_code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region_code());
    }

    // optional bytes user_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatHit_UserInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatHit_UserInfo*>(
      &from));
}

void ThreatHit_UserInfo::MergeFrom(const ThreatHit_UserInfo& from) {
  ThreatHit_UserInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_region_code(from._internal_region_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_user_id(from._internal_user_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatHit_UserInfo::CopyFrom(const ThreatHit_UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit_UserInfo::IsInitialized() const {
  return true;
}

void ThreatHit_UserInfo::InternalSwap(ThreatHit_UserInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.region_code_, lhs_arena,
      &other->_impl_.region_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_id_, lhs_arena,
      &other->_impl_.user_id_, rhs_arena
  );
}

std::string ThreatHit_UserInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit.UserInfo";
}


// ===================================================================

class ThreatHit::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatHit>()._impl_._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mozilla::safebrowsing::ThreatEntry& entry(const ThreatHit* msg);
  static void set_has_entry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::ClientInfo& client_info(const ThreatHit* msg);
  static void set_has_client_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mozilla::safebrowsing::ThreatHit_UserInfo& user_info(const ThreatHit* msg);
  static void set_has_user_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::mozilla::safebrowsing::ThreatEntry&
ThreatHit::_Internal::entry(const ThreatHit* msg) {
  return *msg->_impl_.entry_;
}
const ::mozilla::safebrowsing::ClientInfo&
ThreatHit::_Internal::client_info(const ThreatHit* msg) {
  return *msg->_impl_.client_info_;
}
const ::mozilla::safebrowsing::ThreatHit_UserInfo&
ThreatHit::_Internal::user_info(const ThreatHit* msg) {
  return *msg->_impl_.user_info_;
}
ThreatHit::ThreatHit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatHit)
}
ThreatHit::ThreatHit(const ThreatHit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatHit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resources_){from._impl_.resources_}
    , decltype(_impl_.entry_){nullptr}
    , decltype(_impl_.client_info_){nullptr}
    , decltype(_impl_.user_info_){nullptr}
    , decltype(_impl_.threat_type_){}
    , decltype(_impl_.platform_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_entry()) {
    _this->_impl_.entry_ = new ::mozilla::safebrowsing::ThreatEntry(*from._impl_.entry_);
  }
  if (from._internal_has_client_info()) {
    _this->_impl_.client_info_ = new ::mozilla::safebrowsing::ClientInfo(*from._impl_.client_info_);
  }
  if (from._internal_has_user_info()) {
    _this->_impl_.user_info_ = new ::mozilla::safebrowsing::ThreatHit_UserInfo(*from._impl_.user_info_);
  }
  ::memcpy(&_impl_.threat_type_, &from._impl_.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.platform_type_) -
    reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.platform_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatHit)
}

inline void ThreatHit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resources_){arena}
    , decltype(_impl_.entry_){nullptr}
    , decltype(_impl_.client_info_){nullptr}
    , decltype(_impl_.user_info_){nullptr}
    , decltype(_impl_.threat_type_){0}
    , decltype(_impl_.platform_type_){0}
  };
}

ThreatHit::~ThreatHit() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatHit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatHit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.resources_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.entry_;
  if (this != internal_default_instance()) delete _impl_.client_info_;
  if (this != internal_default_instance()) delete _impl_.user_info_;
}

void ThreatHit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatHit::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatHit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.resources_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.entry_ != nullptr);
      _impl_.entry_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.client_info_ != nullptr);
      _impl_.client_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.user_info_ != nullptr);
      _impl_.user_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.platform_type_) -
        reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.platform_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatHit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_entry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatHit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatHit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::entry(this),
        _Internal::entry(this).GetCachedSize(), target, stream);
  }

  // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resources_size()); i < n; i++) {
    const auto& repfield = this->_internal_resources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::client_info(this),
        _Internal::client_info(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::user_info(this),
        _Internal::user_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatHit)
  return target;
}

size_t ThreatHit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatHit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
  total_size += 1UL * this->_internal_resources_size();
  for (const auto& msg : this->_impl_.resources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.entry_);
    }

    // optional .mozilla.safebrowsing.ClientInfo client_info = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.client_info_);
    }

    // optional .mozilla.safebrowsing.ThreatHit.UserInfo user_info = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_info_);
    }

    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatHit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatHit*>(
      &from));
}

void ThreatHit::MergeFrom(const ThreatHit& from) {
  ThreatHit* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatHit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.resources_.MergeFrom(from._impl_.resources_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_entry()->::mozilla::safebrowsing::ThreatEntry::MergeFrom(
          from._internal_entry());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_client_info()->::mozilla::safebrowsing::ClientInfo::MergeFrom(
          from._internal_client_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_user_info()->::mozilla::safebrowsing::ThreatHit_UserInfo::MergeFrom(
          from._internal_user_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.threat_type_ = from._impl_.threat_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.platform_type_ = from._impl_.platform_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatHit::CopyFrom(const ThreatHit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatHit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit::IsInitialized() const {
  return true;
}

void ThreatHit::InternalSwap(ThreatHit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.resources_.InternalSwap(&other->_impl_.resources_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatHit, _impl_.platform_type_)
      + sizeof(ThreatHit::_impl_.platform_type_)
      - PROTOBUF_FIELD_OFFSET(ThreatHit, _impl_.entry_)>(
          reinterpret_cast<char*>(&_impl_.entry_),
          reinterpret_cast<char*>(&other->_impl_.entry_));
}

std::string ThreatHit::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatHit";
}


// ===================================================================

class ClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientInfo>()._impl_._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientInfo::ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ClientInfo)
}
ClientInfo::ClientInfo(const ClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ClientInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_id_){}
    , decltype(_impl_.client_version_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_id()) {
    _this->_impl_.client_id_.Set(from._internal_client_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.client_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_version()) {
    _this->_impl_.client_version_.Set(from._internal_client_version(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ClientInfo)
}

inline void ClientInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_id_){}
    , decltype(_impl_.client_version_){}
  };
  _impl_.client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientInfo::~ClientInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ClientInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_id_.Destroy();
  _impl_.client_version_.Destroy();
}

void ClientInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ClientInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.client_version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string client_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_client_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ClientInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_id(), target);
  }

  // optional string client_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_client_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ClientInfo)
  return target;
}

size_t ClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ClientInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string client_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_id());
    }

    // optional string client_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientInfo*>(
      &from));
}

void ClientInfo::MergeFrom(const ClientInfo& from) {
  ClientInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ClientInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_id(from._internal_client_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_client_version(from._internal_client_version());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientInfo::CopyFrom(const ClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientInfo::IsInitialized() const {
  return true;
}

void ClientInfo::InternalSwap(ClientInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_id_, lhs_arena,
      &other->_impl_.client_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_version_, lhs_arena,
      &other->_impl_.client_version_, rhs_arena
  );
}

std::string ClientInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ClientInfo";
}


// ===================================================================

class ChromeClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeClientInfo>()._impl_._has_bits_);
  static void set_has_reporting_population(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChromeClientInfo::ChromeClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ChromeClientInfo)
}
ChromeClientInfo::ChromeClientInfo(const ChromeClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ChromeClientInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reporting_population_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.reporting_population_ = from._impl_.reporting_population_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ChromeClientInfo)
}

inline void ChromeClientInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reporting_population_){0}
  };
}

ChromeClientInfo::~ChromeClientInfo() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ChromeClientInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeClientInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChromeClientInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChromeClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ChromeClientInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reporting_population_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeClientInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(val))) {
            _internal_set_reporting_population(static_cast<::mozilla::safebrowsing::ChromeClientInfo_SafeBrowsingReportingPopulation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeClientInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ChromeClientInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reporting_population(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ChromeClientInfo)
  return target;
}

size_t ChromeClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ChromeClientInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .mozilla.safebrowsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_reporting_population());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeClientInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeClientInfo*>(
      &from));
}

void ChromeClientInfo::MergeFrom(const ChromeClientInfo& from) {
  ChromeClientInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ChromeClientInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reporting_population()) {
    _this->_internal_set_reporting_population(from._internal_reporting_population());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeClientInfo::CopyFrom(const ChromeClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ChromeClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeClientInfo::IsInitialized() const {
  return true;
}

void ChromeClientInfo::InternalSwap(ChromeClientInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.reporting_population_, other->_impl_.reporting_population_);
}

std::string ChromeClientInfo::GetTypeName() const {
  return "mozilla.safebrowsing.ChromeClientInfo";
}


// ===================================================================

class Checksum::_Internal {
 public:
  using HasBits = decltype(std::declval<Checksum>()._impl_._has_bits_);
  static void set_has_sha256(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Checksum::Checksum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.Checksum)
}
Checksum::Checksum(const Checksum& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Checksum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sha256_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.sha256_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sha256()) {
    _this->_impl_.sha256_.Set(from._internal_sha256(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.Checksum)
}

inline void Checksum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sha256_){}
  };
  _impl_.sha256_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Checksum::~Checksum() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.Checksum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Checksum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sha256_.Destroy();
}

void Checksum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Checksum::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.Checksum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.sha256_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Checksum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes sha256 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sha256();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Checksum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.Checksum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes sha256 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_sha256(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.Checksum)
  return target;
}

size_t Checksum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.Checksum)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes sha256 = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha256());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Checksum::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Checksum*>(
      &from));
}

void Checksum::MergeFrom(const Checksum& from) {
  Checksum* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.Checksum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sha256()) {
    _this->_internal_set_sha256(from._internal_sha256());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Checksum::CopyFrom(const Checksum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.Checksum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Checksum::IsInitialized() const {
  return true;
}

void Checksum::InternalSwap(Checksum* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sha256_, lhs_arena,
      &other->_impl_.sha256_, rhs_arena
  );
}

std::string Checksum::GetTypeName() const {
  return "mozilla.safebrowsing.Checksum";
}


// ===================================================================

class ThreatEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntry>()._impl_._has_bits_);
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThreatEntry::ThreatEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatEntry)
}
ThreatEntry::ThreatEntry(const ThreatEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.url_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntry)
}

inline void ThreatEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hash_){}
    , decltype(_impl_.url_){}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ThreatEntry::~ThreatEntry() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_.Destroy();
  _impl_.url_.Destroy();
}

void ThreatEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  // optional string url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatEntry)
  return target;
}

size_t ThreatEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional string url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatEntry*>(
      &from));
}

void ThreatEntry::MergeFrom(const ThreatEntry& from) {
  ThreatEntry* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url(from._internal_url());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatEntry::CopyFrom(const ThreatEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntry::IsInitialized() const {
  return true;
}

void ThreatEntry::InternalSwap(ThreatEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
}

std::string ThreatEntry::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntry";
}


// ===================================================================

class ThreatEntrySet::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntrySet>()._impl_._has_bits_);
  static void set_has_compression_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mozilla::safebrowsing::RawHashes& raw_hashes(const ThreatEntrySet* msg);
  static void set_has_raw_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mozilla::safebrowsing::RawIndices& raw_indices(const ThreatEntrySet* msg);
  static void set_has_raw_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mozilla::safebrowsing::RiceDeltaEncoding& rice_hashes(const ThreatEntrySet* msg);
  static void set_has_rice_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mozilla::safebrowsing::RiceDeltaEncoding& rice_indices(const ThreatEntrySet* msg);
  static void set_has_rice_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::mozilla::safebrowsing::RawHashes&
ThreatEntrySet::_Internal::raw_hashes(const ThreatEntrySet* msg) {
  return *msg->_impl_.raw_hashes_;
}
const ::mozilla::safebrowsing::RawIndices&
ThreatEntrySet::_Internal::raw_indices(const ThreatEntrySet* msg) {
  return *msg->_impl_.raw_indices_;
}
const ::mozilla::safebrowsing::RiceDeltaEncoding&
ThreatEntrySet::_Internal::rice_hashes(const ThreatEntrySet* msg) {
  return *msg->_impl_.rice_hashes_;
}
const ::mozilla::safebrowsing::RiceDeltaEncoding&
ThreatEntrySet::_Internal::rice_indices(const ThreatEntrySet* msg) {
  return *msg->_impl_.rice_indices_;
}
ThreatEntrySet::ThreatEntrySet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatEntrySet)
}
ThreatEntrySet::ThreatEntrySet(const ThreatEntrySet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatEntrySet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.raw_hashes_){nullptr}
    , decltype(_impl_.raw_indices_){nullptr}
    , decltype(_impl_.rice_hashes_){nullptr}
    , decltype(_impl_.rice_indices_){nullptr}
    , decltype(_impl_.compression_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_raw_hashes()) {
    _this->_impl_.raw_hashes_ = new ::mozilla::safebrowsing::RawHashes(*from._impl_.raw_hashes_);
  }
  if (from._internal_has_raw_indices()) {
    _this->_impl_.raw_indices_ = new ::mozilla::safebrowsing::RawIndices(*from._impl_.raw_indices_);
  }
  if (from._internal_has_rice_hashes()) {
    _this->_impl_.rice_hashes_ = new ::mozilla::safebrowsing::RiceDeltaEncoding(*from._impl_.rice_hashes_);
  }
  if (from._internal_has_rice_indices()) {
    _this->_impl_.rice_indices_ = new ::mozilla::safebrowsing::RiceDeltaEncoding(*from._impl_.rice_indices_);
  }
  _this->_impl_.compression_type_ = from._impl_.compression_type_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntrySet)
}

inline void ThreatEntrySet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.raw_hashes_){nullptr}
    , decltype(_impl_.raw_indices_){nullptr}
    , decltype(_impl_.rice_hashes_){nullptr}
    , decltype(_impl_.rice_indices_){nullptr}
    , decltype(_impl_.compression_type_){0}
  };
}

ThreatEntrySet::~ThreatEntrySet() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntrySet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatEntrySet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.raw_hashes_;
  if (this != internal_default_instance()) delete _impl_.raw_indices_;
  if (this != internal_default_instance()) delete _impl_.rice_hashes_;
  if (this != internal_default_instance()) delete _impl_.rice_indices_;
}

void ThreatEntrySet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatEntrySet::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntrySet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.raw_hashes_ != nullptr);
      _impl_.raw_hashes_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.raw_indices_ != nullptr);
      _impl_.raw_indices_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.rice_hashes_ != nullptr);
      _impl_.rice_hashes_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.rice_indices_ != nullptr);
      _impl_.rice_indices_->Clear();
    }
  }
  _impl_.compression_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatEntrySet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::CompressionType_IsValid(val))) {
            _internal_set_compression_type(static_cast<::mozilla::safebrowsing::CompressionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_hashes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_indices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rice_hashes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rice_indices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatEntrySet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatEntrySet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_compression_type(), target);
  }

  // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::raw_hashes(this),
        _Internal::raw_hashes(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::raw_indices(this),
        _Internal::raw_indices(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rice_hashes(this),
        _Internal::rice_hashes(this).GetCachedSize(), target, stream);
  }

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::rice_indices(this),
        _Internal::rice_indices(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatEntrySet)
  return target;
}

size_t ThreatEntrySet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntrySet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.raw_hashes_);
    }

    // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.raw_indices_);
    }

    // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rice_hashes_);
    }

    // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rice_indices_);
    }

    // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_compression_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntrySet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatEntrySet*>(
      &from));
}

void ThreatEntrySet::MergeFrom(const ThreatEntrySet& from) {
  ThreatEntrySet* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntrySet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_raw_hashes()->::mozilla::safebrowsing::RawHashes::MergeFrom(
          from._internal_raw_hashes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_raw_indices()->::mozilla::safebrowsing::RawIndices::MergeFrom(
          from._internal_raw_indices());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_rice_hashes()->::mozilla::safebrowsing::RiceDeltaEncoding::MergeFrom(
          from._internal_rice_hashes());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_rice_indices()->::mozilla::safebrowsing::RiceDeltaEncoding::MergeFrom(
          from._internal_rice_indices());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.compression_type_ = from._impl_.compression_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatEntrySet::CopyFrom(const ThreatEntrySet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntrySet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntrySet::IsInitialized() const {
  return true;
}

void ThreatEntrySet::InternalSwap(ThreatEntrySet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatEntrySet, _impl_.compression_type_)
      + sizeof(ThreatEntrySet::_impl_.compression_type_)
      - PROTOBUF_FIELD_OFFSET(ThreatEntrySet, _impl_.raw_hashes_)>(
          reinterpret_cast<char*>(&_impl_.raw_hashes_),
          reinterpret_cast<char*>(&other->_impl_.raw_hashes_));
}

std::string ThreatEntrySet::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntrySet";
}


// ===================================================================

class RawIndices::_Internal {
 public:
};

RawIndices::RawIndices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.RawIndices)
}
RawIndices::RawIndices(const RawIndices& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RawIndices* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.indices_){from._impl_.indices_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RawIndices)
}

inline void RawIndices::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.indices_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RawIndices::~RawIndices() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RawIndices)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RawIndices::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.indices_.~RepeatedField();
}

void RawIndices::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RawIndices::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RawIndices)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.indices_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RawIndices::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 indices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_indices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RawIndices::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.RawIndices)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 indices = 1;
  for (int i = 0, n = this->_internal_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_indices(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.RawIndices)
  return target;
}

size_t RawIndices::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RawIndices)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 indices = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.indices_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_indices_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RawIndices::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RawIndices*>(
      &from));
}

void RawIndices::MergeFrom(const RawIndices& from) {
  RawIndices* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RawIndices)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.indices_.MergeFrom(from._impl_.indices_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RawIndices::CopyFrom(const RawIndices& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RawIndices)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawIndices::IsInitialized() const {
  return true;
}

void RawIndices::InternalSwap(RawIndices* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.indices_.InternalSwap(&other->_impl_.indices_);
}

std::string RawIndices::GetTypeName() const {
  return "mozilla.safebrowsing.RawIndices";
}


// ===================================================================

class RawHashes::_Internal {
 public:
  using HasBits = decltype(std::declval<RawHashes>()._impl_._has_bits_);
  static void set_has_prefix_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_raw_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RawHashes::RawHashes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.RawHashes)
}
RawHashes::RawHashes(const RawHashes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RawHashes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.raw_hashes_){}
    , decltype(_impl_.prefix_size_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.raw_hashes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.raw_hashes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_raw_hashes()) {
    _this->_impl_.raw_hashes_.Set(from._internal_raw_hashes(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.prefix_size_ = from._impl_.prefix_size_;
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RawHashes)
}

inline void RawHashes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.raw_hashes_){}
    , decltype(_impl_.prefix_size_){0}
  };
  _impl_.raw_hashes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.raw_hashes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RawHashes::~RawHashes() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RawHashes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RawHashes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.raw_hashes_.Destroy();
}

void RawHashes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RawHashes::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RawHashes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.raw_hashes_.ClearNonDefaultToEmpty();
  }
  _impl_.prefix_size_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RawHashes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 prefix_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_prefix_size(&has_bits);
          _impl_.prefix_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes raw_hashes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_raw_hashes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RawHashes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.RawHashes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 prefix_size = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_prefix_size(), target);
  }

  // optional bytes raw_hashes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_raw_hashes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.RawHashes)
  return target;
}

size_t RawHashes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RawHashes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes raw_hashes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_hashes());
    }

    // optional int32 prefix_size = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prefix_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RawHashes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RawHashes*>(
      &from));
}

void RawHashes::MergeFrom(const RawHashes& from) {
  RawHashes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RawHashes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_raw_hashes(from._internal_raw_hashes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.prefix_size_ = from._impl_.prefix_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RawHashes::CopyFrom(const RawHashes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RawHashes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawHashes::IsInitialized() const {
  return true;
}

void RawHashes::InternalSwap(RawHashes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.raw_hashes_, lhs_arena,
      &other->_impl_.raw_hashes_, rhs_arena
  );
  swap(_impl_.prefix_size_, other->_impl_.prefix_size_);
}

std::string RawHashes::GetTypeName() const {
  return "mozilla.safebrowsing.RawHashes";
}


// ===================================================================

class RiceDeltaEncoding::_Internal {
 public:
  using HasBits = decltype(std::declval<RiceDeltaEncoding>()._impl_._has_bits_);
  static void set_has_first_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rice_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_encoded_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RiceDeltaEncoding::RiceDeltaEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.RiceDeltaEncoding)
}
RiceDeltaEncoding::RiceDeltaEncoding(const RiceDeltaEncoding& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RiceDeltaEncoding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_){}
    , decltype(_impl_.rice_parameter_){}
    , decltype(_impl_.num_entries_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encoded_data()) {
    _this->_impl_.encoded_data_.Set(from._internal_encoded_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.first_value_, &from._impl_.first_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_entries_) -
    reinterpret_cast<char*>(&_impl_.first_value_)) + sizeof(_impl_.num_entries_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.RiceDeltaEncoding)
}

inline void RiceDeltaEncoding::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.encoded_data_){}
    , decltype(_impl_.first_value_){int64_t{0}}
    , decltype(_impl_.rice_parameter_){0}
    , decltype(_impl_.num_entries_){0}
  };
  _impl_.encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RiceDeltaEncoding::~RiceDeltaEncoding() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.RiceDeltaEncoding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RiceDeltaEncoding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.encoded_data_.Destroy();
}

void RiceDeltaEncoding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RiceDeltaEncoding::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.RiceDeltaEncoding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.encoded_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.first_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_entries_) -
        reinterpret_cast<char*>(&_impl_.first_value_)) + sizeof(_impl_.num_entries_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RiceDeltaEncoding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 first_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_first_value(&has_bits);
          _impl_.first_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rice_parameter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rice_parameter(&has_bits);
          _impl_.rice_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_entries(&has_bits);
          _impl_.num_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encoded_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_encoded_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RiceDeltaEncoding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.RiceDeltaEncoding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 first_value = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_first_value(), target);
  }

  // optional int32 rice_parameter = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_rice_parameter(), target);
  }

  // optional int32 num_entries = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_entries(), target);
  }

  // optional bytes encoded_data = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_encoded_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.RiceDeltaEncoding)
  return target;
}

size_t RiceDeltaEncoding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.RiceDeltaEncoding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes encoded_data = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encoded_data());
    }

    // optional int64 first_value = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_first_value());
    }

    // optional int32 rice_parameter = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rice_parameter());
    }

    // optional int32 num_entries = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_entries());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RiceDeltaEncoding::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RiceDeltaEncoding*>(
      &from));
}

void RiceDeltaEncoding::MergeFrom(const RiceDeltaEncoding& from) {
  RiceDeltaEncoding* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.RiceDeltaEncoding)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_encoded_data(from._internal_encoded_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.first_value_ = from._impl_.first_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rice_parameter_ = from._impl_.rice_parameter_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.num_entries_ = from._impl_.num_entries_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RiceDeltaEncoding::CopyFrom(const RiceDeltaEncoding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.RiceDeltaEncoding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RiceDeltaEncoding::IsInitialized() const {
  return true;
}

void RiceDeltaEncoding::InternalSwap(RiceDeltaEncoding* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.encoded_data_, lhs_arena,
      &other->_impl_.encoded_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RiceDeltaEncoding, _impl_.num_entries_)
      + sizeof(RiceDeltaEncoding::_impl_.num_entries_)
      - PROTOBUF_FIELD_OFFSET(RiceDeltaEncoding, _impl_.first_value_)>(
          reinterpret_cast<char*>(&_impl_.first_value_),
          reinterpret_cast<char*>(&other->_impl_.first_value_));
}

std::string RiceDeltaEncoding::GetTypeName() const {
  return "mozilla.safebrowsing.RiceDeltaEncoding";
}


// ===================================================================

class ThreatEntryMetadata_MetadataEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntryMetadata_MetadataEntry>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
}
ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatEntryMetadata_MetadataEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
}

inline void ThreatEntryMetadata_MetadataEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ThreatEntryMetadata_MetadataEntry::~ThreatEntryMetadata_MetadataEntry() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatEntryMetadata_MetadataEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
}

void ThreatEntryMetadata_MetadataEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatEntryMetadata_MetadataEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatEntryMetadata_MetadataEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatEntryMetadata_MetadataEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  return target;
}

size_t ThreatEntryMetadata_MetadataEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntryMetadata_MetadataEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatEntryMetadata_MetadataEntry*>(
      &from));
}

void ThreatEntryMetadata_MetadataEntry::MergeFrom(const ThreatEntryMetadata_MetadataEntry& from) {
  ThreatEntryMetadata_MetadataEntry* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatEntryMetadata_MetadataEntry::CopyFrom(const ThreatEntryMetadata_MetadataEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntryMetadata_MetadataEntry::IsInitialized() const {
  return true;
}

void ThreatEntryMetadata_MetadataEntry::InternalSwap(ThreatEntryMetadata_MetadataEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

std::string ThreatEntryMetadata_MetadataEntry::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry";
}


// ===================================================================

class ThreatEntryMetadata::_Internal {
 public:
};

ThreatEntryMetadata::ThreatEntryMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatEntryMetadata)
}
ThreatEntryMetadata::ThreatEntryMetadata(const ThreatEntryMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatEntryMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatEntryMetadata)
}

inline void ThreatEntryMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ThreatEntryMetadata::~ThreatEntryMetadata() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatEntryMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatEntryMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void ThreatEntryMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatEntryMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatEntryMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatEntryMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatEntryMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatEntryMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatEntryMetadata)
  return target;
}

size_t ThreatEntryMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatEntryMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntryMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatEntryMetadata*>(
      &from));
}

void ThreatEntryMetadata::MergeFrom(const ThreatEntryMetadata& from) {
  ThreatEntryMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatEntryMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatEntryMetadata::CopyFrom(const ThreatEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatEntryMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntryMetadata::IsInitialized() const {
  return true;
}

void ThreatEntryMetadata::InternalSwap(ThreatEntryMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
}

std::string ThreatEntryMetadata::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatEntryMetadata";
}


// ===================================================================

class ThreatListDescriptor::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatListDescriptor>()._impl_._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ThreatListDescriptor::ThreatListDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ThreatListDescriptor)
}
ThreatListDescriptor::ThreatListDescriptor(const ThreatListDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ThreatListDescriptor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threat_type_){}
    , decltype(_impl_.platform_type_){}
    , decltype(_impl_.threat_entry_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.threat_type_, &from._impl_.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.threat_entry_type_) -
    reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ThreatListDescriptor)
}

inline void ThreatListDescriptor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threat_type_){0}
    , decltype(_impl_.platform_type_){0}
    , decltype(_impl_.threat_entry_type_){0}
  };
}

ThreatListDescriptor::~ThreatListDescriptor() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ThreatListDescriptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatListDescriptor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ThreatListDescriptor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatListDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ThreatListDescriptor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.threat_entry_type_) -
        reinterpret_cast<char*>(&_impl_.threat_type_)) + sizeof(_impl_.threat_entry_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatListDescriptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::mozilla::safebrowsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::mozilla::safebrowsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mozilla::safebrowsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::mozilla::safebrowsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatListDescriptor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ThreatListDescriptor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ThreatListDescriptor)
  return target;
}

size_t ThreatListDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ThreatListDescriptor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatListDescriptor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatListDescriptor*>(
      &from));
}

void ThreatListDescriptor::MergeFrom(const ThreatListDescriptor& from) {
  ThreatListDescriptor* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ThreatListDescriptor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.threat_type_ = from._impl_.threat_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.platform_type_ = from._impl_.platform_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.threat_entry_type_ = from._impl_.threat_entry_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatListDescriptor::CopyFrom(const ThreatListDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ThreatListDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatListDescriptor::IsInitialized() const {
  return true;
}

void ThreatListDescriptor::InternalSwap(ThreatListDescriptor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatListDescriptor, _impl_.threat_entry_type_)
      + sizeof(ThreatListDescriptor::_impl_.threat_entry_type_)
      - PROTOBUF_FIELD_OFFSET(ThreatListDescriptor, _impl_.threat_type_)>(
          reinterpret_cast<char*>(&_impl_.threat_type_),
          reinterpret_cast<char*>(&other->_impl_.threat_type_));
}

std::string ThreatListDescriptor::GetTypeName() const {
  return "mozilla.safebrowsing.ThreatListDescriptor";
}


// ===================================================================

class ListThreatListsResponse::_Internal {
 public:
};

ListThreatListsResponse::ListThreatListsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.ListThreatListsResponse)
}
ListThreatListsResponse::ListThreatListsResponse(const ListThreatListsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ListThreatListsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.threat_lists_){from._impl_.threat_lists_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.ListThreatListsResponse)
}

inline void ListThreatListsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.threat_lists_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ListThreatListsResponse::~ListThreatListsResponse() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.ListThreatListsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListThreatListsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.threat_lists_.~RepeatedPtrField();
}

void ListThreatListsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListThreatListsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.ListThreatListsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.threat_lists_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ListThreatListsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_threat_lists(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListThreatListsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.ListThreatListsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_threat_lists_size()); i < n; i++) {
    const auto& repfield = this->_internal_threat_lists(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.ListThreatListsResponse)
  return target;
}

size_t ListThreatListsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.ListThreatListsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
  total_size += 1UL * this->_internal_threat_lists_size();
  for (const auto& msg : this->_impl_.threat_lists_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListThreatListsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ListThreatListsResponse*>(
      &from));
}

void ListThreatListsResponse::MergeFrom(const ListThreatListsResponse& from) {
  ListThreatListsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.ListThreatListsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.threat_lists_.MergeFrom(from._impl_.threat_lists_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListThreatListsResponse::CopyFrom(const ListThreatListsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.ListThreatListsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListThreatListsResponse::IsInitialized() const {
  return true;
}

void ListThreatListsResponse::InternalSwap(ListThreatListsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.threat_lists_.InternalSwap(&other->_impl_.threat_lists_);
}

std::string ListThreatListsResponse::GetTypeName() const {
  return "mozilla.safebrowsing.ListThreatListsResponse";
}


// ===================================================================

class Duration::_Internal {
 public:
  using HasBits = decltype(std::declval<Duration>()._impl_._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nanos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Duration::Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mozilla.safebrowsing.Duration)
}
Duration::Duration(const Duration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Duration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){}
    , decltype(_impl_.nanos_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) -
    reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  // @@protoc_insertion_point(copy_constructor:mozilla.safebrowsing.Duration)
}

inline void Duration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){int64_t{0}}
    , decltype(_impl_.nanos_){0}
  };
}

Duration::~Duration() {
  // @@protoc_insertion_point(destructor:mozilla.safebrowsing.Duration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Duration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Duration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Duration::Clear() {
// @@protoc_insertion_point(message_clear_start:mozilla.safebrowsing.Duration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nanos_) -
        reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Duration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seconds(&has_bits);
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nanos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nanos(&has_bits);
          _impl_.nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Duration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mozilla.safebrowsing.Duration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
  }

  // optional int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mozilla.safebrowsing.Duration)
  return target;
}

size_t Duration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mozilla.safebrowsing.Duration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 seconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
    }

    // optional int32 nanos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nanos());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Duration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Duration*>(
      &from));
}

void Duration::MergeFrom(const Duration& from) {
  Duration* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mozilla.safebrowsing.Duration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.seconds_ = from._impl_.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nanos_ = from._impl_.nanos_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Duration::CopyFrom(const Duration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mozilla.safebrowsing.Duration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Duration::IsInitialized() const {
  return true;
}

void Duration::InternalSwap(Duration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Duration, _impl_.nanos_)
      + sizeof(Duration::_impl_.nanos_)
      - PROTOBUF_FIELD_OFFSET(Duration, _impl_.seconds_)>(
          reinterpret_cast<char*>(&_impl_.seconds_),
          reinterpret_cast<char*>(&other->_impl_.seconds_));
}

std::string Duration::GetTypeName() const {
  return "mozilla.safebrowsing.Duration";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace safebrowsing
}  // namespace mozilla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatInfo*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatMatch*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FindThreatMatchesRequest*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FindThreatMatchesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FindThreatMatchesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FindThreatMatchesResponse*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FindThreatMatchesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FindThreatMatchesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesRequest*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FetchThreatListUpdatesResponse*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FindFullHashesRequest*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FindFullHashesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FindFullHashesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::FindFullHashesResponse*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::FindFullHashesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::FindFullHashesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatHit_ThreatSource*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatHit_ThreatSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatHit_ThreatSource >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatHit_UserInfo*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatHit_UserInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatHit_UserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatHit*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatHit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatHit >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ClientInfo*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ClientInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ChromeClientInfo*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ChromeClientInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ChromeClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::Checksum*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::Checksum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::Checksum >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatEntry*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatEntrySet*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatEntrySet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatEntrySet >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::RawIndices*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::RawIndices >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::RawIndices >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::RawHashes*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::RawHashes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::RawHashes >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::RiceDeltaEncoding*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::RiceDeltaEncoding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::RiceDeltaEncoding >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatEntryMetadata*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatEntryMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatEntryMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ThreatListDescriptor*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ThreatListDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ThreatListDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::ListThreatListsResponse*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::ListThreatListsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::ListThreatListsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::mozilla::safebrowsing::Duration*
Arena::CreateMaybeMessage< ::mozilla::safebrowsing::Duration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mozilla::safebrowsing::Duration >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
